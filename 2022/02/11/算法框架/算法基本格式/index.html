<!DOCTYPE html>
<html lang=en>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="renderer" content="webkit">
  <meta http-equiv="Cache-Control" content="no-transform" />
  <meta http-equiv="Cache-Control" content="no-siteapp" />
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  <meta name="format-detection" content="telephone=no,email=no,adress=no">
  <!-- Color theme for statusbar -->
  <meta name="theme-color" content="#000000" />
  <!-- 强制页面在当前窗口以独立页面显示,防止别人在框架里调用页面 -->
  <meta http-equiv="window-target" content="_top" />
  
  
  <title>算法框架 | Bonjour!</title>
  <meta name="description" content="算法基本格式数组基本方法 二分法 双指针 滑动窗口，和双指针类似，通过窗口大小的变换来解题  哈希表关于哈希表的一些事情常见的哈希表结构 数组 set（unordered_set） map（unordered_map）  适用题型 当我们遇到了要快速判断一个元素是否出现集合里的时候，就要考虑哈希法。 但是哈希法也是牺牲了空间换取了时间，因为我们要使用额外的数组，set或者是map来存放数据，才能">
<meta property="og:type" content="article">
<meta property="og:title" content="算法框架">
<meta property="og:url" content="http://littlewuuu.com/2022/02/11/%E7%AE%97%E6%B3%95%E6%A1%86%E6%9E%B6/%E7%AE%97%E6%B3%95%E5%9F%BA%E6%9C%AC%E6%A0%BC%E5%BC%8F/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="算法基本格式数组基本方法 二分法 双指针 滑动窗口，和双指针类似，通过窗口大小的变换来解题  哈希表关于哈希表的一些事情常见的哈希表结构 数组 set（unordered_set） map（unordered_map）  适用题型 当我们遇到了要快速判断一个元素是否出现集合里的时候，就要考虑哈希法。 但是哈希法也是牺牲了空间换取了时间，因为我们要使用额外的数组，set或者是map来存放数据，才能">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://camo.githubusercontent.com/efed0a1e96c2f77182f3beb78cb01b40867e7c75d11e6957e1f67d21c39dd7de/68747470733a2f2f636f64652d7468696e6b696e672e63646e2e626365626f732e636f6d2f676966732f4b4d50254537254232254245254538254145254232312e676966">
<meta property="og:image" content="https://camo.githubusercontent.com/9ce37d3e9ac54e3ff2d4af9f765451d03982f161546ffc488774f2fe135b18f8/68747470733a2f2f636f64652d7468696e6b696e672e63646e2e626365626f732e636f6d2f706963732f4b4d50254537254232254245254538254145254232382e706e67">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/e6c9d24egy1gzk1c4b5vdj20py0i8t9r.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/e6c9d24egy1gzml9hqbqvj20h009eq49.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/e6c9d24egy1gzml9vv8nlj20i50bzq53.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/008i3skNgy1gz8ts877edj30o40eg74s.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/008i3skNgy1gz8u7n9uupj30l604w74v.jpg">
<meta property="og:image" content="http://littlewuuu.com/Users/wuzilong/Library/Application%20Support/typora-user-images/%E6%88%AA%E5%B1%8F2022-02-10%2016.36.11.png">
<meta property="og:image" content="http://littlewuuu.com/Users/wuzilong/Library/Application%20Support/typora-user-images/%E6%88%AA%E5%B1%8F2022-02-10%2016.46.37.png">
<meta property="og:image" content="http://littlewuuu.com/Users/wuzilong/Library/Application%20Support/typora-user-images/%E6%88%AA%E5%B1%8F2022-02-10%2016.47.46.png">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/008i3skNgy1gz927xanwgj30vy0c2400.jpg">
<meta property="og:image" content="http://littlewuuu.com/Users/wuzilong/Library/Application%20Support/typora-user-images/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f32303231303231393139323035303636362e706e67.png">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/008i3skNgy1gz6h45plamj30ze0gcjtj.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/008i3skNgy1gz6h3wx18cj30ym0msjum.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/008i3skNgy1gz9q852ermj31c60scwk1.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/008i3skNgy1gz9qdbsj1vj31d40sc7b9.jpg">
<meta property="og:image" content="http://littlewuuu.com/Users/wuzilong/Library/Application%20Support/typora-user-images/68747470733a2f2f636f64652d7468696e6b696e672e63646e2e626365626f732e636f6d2f706963732f3133312e2545352538382538362545352538392542322545352539422539452545362539362538372545342542382542322e6a7067.jpeg">
<meta property="og:image" content="https://camo.githubusercontent.com/3f67c171ede9807a17fdeaf91ac87e7813516ad272a3c4ac55ee292514ff2acf/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f3230323031313233323034313334382e706e67">
<meta property="og:image" content="http://littlewuuu.com/Users/wuzilong/Library/Application%20Support/typora-user-images/68747470733a2f2f636f64652d7468696e6b696e672d313235333835353039332e66696c652e6d7971636c6f75642e636f6d2f706963732f32303231303931373130343331352e706e67.png">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/008i3skNgy1gz8saa0s9lj30u01rkwkq.jpg">
<meta property="article:published_time" content="2022-02-10T23:00:00.000Z">
<meta property="article:modified_time" content="2022-02-27T12:00:48.404Z">
<meta property="article:author" content="John Doe">
<meta property="article:tag" content="有点难学的">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://camo.githubusercontent.com/efed0a1e96c2f77182f3beb78cb01b40867e7c75d11e6957e1f67d21c39dd7de/68747470733a2f2f636f64652d7468696e6b696e672e63646e2e626365626f732e636f6d2f676966732f4b4d50254537254232254245254538254145254232312e676966">
  <!-- Canonical links -->
  <link rel="canonical" href="http://littlewuuu.com/2022/02/11/%E7%AE%97%E6%B3%95%E6%A1%86%E6%9E%B6/%E7%AE%97%E6%B3%95%E5%9F%BA%E6%9C%AC%E6%A0%BC%E5%BC%8F/index.html">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png" type="image/x-icon">
  
  
<link rel="stylesheet" href="/css/style.css">

  
  
  
    <link href="//cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.3.5/dist/jquery.fancybox.min.css" rel="stylesheet">
  
  
<meta name="generator" content="Hexo 6.0.0"></head>


<body class="main-center theme-blue no-sidebar" itemscope itemtype="http://schema.org/WebPage">
  <header class="header" itemscope itemtype="http://schema.org/WPHeader">
  <div class="slimContent">
    <div class="navbar-header">
      
      
      <div class="profile-block text-center">
        <a id="avatar" href="https://github.com/littlewuuu" target="_blank">
          <img class="img-circle img-rotate" src="/images/mee.jpg" width="200" height="200">
        </a>
        <h2 id="name" class="hidden-xs hidden-sm">Wuuu</h2>
        <h3 id="title" class="hidden-xs hidden-sm hidden-md">un étudiant</h3>
        <small id="location" class="text-muted hidden-xs hidden-sm"><i class="icon icon-map-marker"></i> Nantes,France</small>
      </div>
      
      <div class="search" id="search-form-wrap">

    <form class="search-form sidebar-form">
        <div class="input-group">
            <input type="text" class="search-form-input form-control" placeholder="Search" />
            <span class="input-group-btn">
                <button type="submit" class="search-form-submit btn btn-flat" onclick="return false;"><i class="icon icon-search"></i></button>
            </span>
        </div>
    </form>
    <div class="ins-search">
  <div class="ins-search-mask"></div>
  <div class="ins-search-container">
    <div class="ins-input-wrapper">
      <input type="text" class="ins-search-input" placeholder="Type something..." x-webkit-speech />
      <button type="button" class="close ins-close ins-selectable" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">×</span></button>
    </div>
    <div class="ins-section-wrapper">
      <div class="ins-section-container"></div>
    </div>
  </div>
</div>


</div>
      <button class="navbar-toggle collapsed" type="button" data-toggle="collapse" data-target="#main-navbar" aria-controls="main-navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
    </div>
    <nav id="main-navbar" class="collapse navbar-collapse" itemscope itemtype="http://schema.org/SiteNavigationElement" role="navigation">
      <ul class="nav navbar-nav main-nav ">
        
        
        <li class="menu-item menu-item-archives">
          <a href="/archives">
            
            <i class="icon icon-archives-fill"></i>
            
            <span class="menu-title">Archives</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-categories">
          <a href="/categories">
            
            <i class="icon icon-folder"></i>
            
            <span class="menu-title">Categories</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-links">
          <a href="/links">
            
            <i class="icon icon-friendship"></i>
            
            <span class="menu-title">Links</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-about">
          <a href="/about">
            
            <i class="icon icon-cup-fill"></i>
            
            <span class="menu-title">About</span>
          </a>
        </li>
        
      </ul>
      
	
    <ul class="social-links">
    	
        <li><a href="https://github.com/littlewuuu" target="_blank" title="Github" data-toggle=tooltip data-placement=top><i class="icon icon-github"></i></a></li>
        
        <li><a href="https://weibo.com/littlewuu" target="_blank" title="Weibo" data-toggle=tooltip data-placement=top><i class="icon icon-weibo"></i></a></li>
        
        <li><a href="https://huaban.com/littlewuuu" target="_blank" title="花瓣" data-toggle=tooltip data-placement=top><i class="icon icon-花瓣"></i></a></li>
        
    </ul>

    </nav>
  </div>
</header>

  
    <aside class="sidebar" itemscope itemtype="http://schema.org/WPSideBar">
  <div class="slimContent">
    
      <div class="widget">
    <h3 class="widget-title">Board</h3>
    <div class="widget-body">
        <div id="board">
            <div class="content">
                <p> <img src="https://i.imgur.com/wB20Vsp.jpg" width=70%/> <br/> 新年快乐~ </p>
            </div>
        </div>
    </div>
</div>

    
      
  <div class="widget">
    <h3 class="widget-title">Categories</h3>
    <div class="widget-body">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/COURS/">COURS</a><span class="category-list-count">7</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/SKILLS/">SKILLS</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/le-francais/">le français</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/skills/">skills</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%81%9A%E9%A5%AD%E5%8C%BA/">做饭区</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%94%9F%E6%B4%BB/">生活</a><span class="category-list-count">3</span></li></ul>
    </div>
  </div>


    
      
  <div class="widget">
    <h3 class="widget-title">Tags</h3>
    <div class="widget-body">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/ECN/" rel="tag">ECN</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ENG/" rel="tag">ENG</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/le-francais/" rel="tag">le français</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%B8%80%E4%BA%9B%E5%A5%87%E5%A5%87%E6%80%AA%E6%80%AA%E7%9A%84%E5%90%83%E7%9A%84/" rel="tag">一些奇奇怪怪的吃的</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%B8%80%E4%BA%9B%E6%AD%A3%E6%AD%A3%E7%BB%8F%E7%BB%8F%E7%9A%84%E5%90%83%E7%9A%84/" rel="tag">一些正正经经的吃的</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%88%B0%E5%A4%84%E7%8E%A9/" rel="tag">到处玩</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%A5%BD%E5%A5%BD%E7%94%9F%E6%B4%BB/" rel="tag">好好生活</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%AD%A6%E4%BA%86%E5%8F%88%E5%BF%98%E7%9A%84%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/" rel="tag">学了又忘的杂七杂八</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%9C%89%E7%82%B9%E9%9A%BE%E5%AD%A6%E7%9A%84/" rel="tag">有点难学的</a><span class="tag-list-count">2</span></li></ul>
    </div>
  </div>


    
      
  <div class="widget">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget-body tagcloud">
      <a href="/tags/ECN/" style="font-size: 14px;">ECN</a> <a href="/tags/ENG/" style="font-size: 13px;">ENG</a> <a href="/tags/le-francais/" style="font-size: 13.33px;">le français</a> <a href="/tags/%E4%B8%80%E4%BA%9B%E5%A5%87%E5%A5%87%E6%80%AA%E6%80%AA%E7%9A%84%E5%90%83%E7%9A%84/" style="font-size: 13px;">一些奇奇怪怪的吃的</a> <a href="/tags/%E4%B8%80%E4%BA%9B%E6%AD%A3%E6%AD%A3%E7%BB%8F%E7%BB%8F%E7%9A%84%E5%90%83%E7%9A%84/" style="font-size: 13px;">一些正正经经的吃的</a> <a href="/tags/%E5%88%B0%E5%A4%84%E7%8E%A9/" style="font-size: 13px;">到处玩</a> <a href="/tags/%E5%A5%BD%E5%A5%BD%E7%94%9F%E6%B4%BB/" style="font-size: 13px;">好好生活</a> <a href="/tags/%E5%AD%A6%E4%BA%86%E5%8F%88%E5%BF%98%E7%9A%84%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/" style="font-size: 13.67px;">学了又忘的杂七杂八</a> <a href="/tags/%E6%9C%89%E7%82%B9%E9%9A%BE%E5%AD%A6%E7%9A%84/" style="font-size: 13.33px;">有点难学的</a>
    </div>
  </div>

    
      
  <div class="widget">
    <h3 class="widget-title">Archive</h3>
    <div class="widget-body">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/04/">April 2022</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/02/">February 2022</a><span class="archive-list-count">6</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/01/">January 2022</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/12/">December 2021</a><span class="archive-list-count">6</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/02/">February 2021</a><span class="archive-list-count">1</span></li></ul>
    </div>
  </div>


    
  </div>
</aside>

  
  
<aside class="sidebar sidebar-toc collapse" id="collapseToc" itemscope itemtype="http://schema.org/WPSideBar">
  <div class="slimContent">
    <nav id="toc" class="article-toc">
      <h3 class="toc-title">Catalogue</h3>
      <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E5%9F%BA%E6%9C%AC%E6%A0%BC%E5%BC%8F"><span class="toc-number">1.</span> <span class="toc-text">算法基本格式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E7%BB%84"><span class="toc-number">1.1.</span> <span class="toc-text">数组</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%96%B9%E6%B3%95"><span class="toc-number">1.1.1.</span> <span class="toc-text">基本方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%93%88%E5%B8%8C%E8%A1%A8"><span class="toc-number">1.2.</span> <span class="toc-text">哈希表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E4%BA%8E%E5%93%88%E5%B8%8C%E8%A1%A8%E7%9A%84%E4%B8%80%E4%BA%9B%E4%BA%8B%E6%83%85"><span class="toc-number">1.2.1.</span> <span class="toc-text">关于哈希表的一些事情</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84%E5%93%88%E5%B8%8C%E8%A1%A8%E7%BB%93%E6%9E%84"><span class="toc-number">1.2.1.1.</span> <span class="toc-text">常见的哈希表结构</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%82%E7%94%A8%E9%A2%98%E5%9E%8B"><span class="toc-number">1.2.2.</span> <span class="toc-text">适用题型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">1.3.</span> <span class="toc-text">字符串</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#KMP-%E7%AE%97%E6%B3%95"><span class="toc-number">1.3.1.</span> <span class="toc-text">KMP 算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-next-%E6%95%B0%E7%BB%84"><span class="toc-number">1.3.1.1.</span> <span class="toc-text">1. next 数组</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%98%9F%E5%88%97%E4%B8%8E%E6%A0%88"><span class="toc-number">1.4.</span> <span class="toc-text">队列与栈</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%88"><span class="toc-number">1.4.1.</span> <span class="toc-text">栈</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E6%A0%88"><span class="toc-number">1.4.1.1.</span> <span class="toc-text">队列实现栈</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97"><span class="toc-number">1.4.1.2.</span> <span class="toc-text">栈实现队列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8B%AC%E5%8F%B7%E5%8C%B9%E9%85%8D%E9%97%AE%E9%A2%98"><span class="toc-number">1.4.1.3.</span> <span class="toc-text">括号匹配问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%86%E6%B3%A2%E5%85%B0%E5%BC%8F%E6%B1%82%E5%80%BC"><span class="toc-number">1.4.1.4.</span> <span class="toc-text">逆波兰式求值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97"><span class="toc-number">1.4.1.5.</span> <span class="toc-text">单调队列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%89%8D-k-%E4%B8%AA%E9%AB%98%E9%A2%91%E5%85%83%E7%B4%A0"><span class="toc-number">1.4.1.6.</span> <span class="toc-text">前 k 个高频元素</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%88%91%E7%9A%84%E6%83%B3%E6%B3%95"><span class="toc-number">1.4.1.6.1.</span> <span class="toc-text">我的想法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-map%EF%BC%8Cpriority-queue%EF%BC%8C"><span class="toc-number">1.4.1.6.2.</span> <span class="toc-text">使用 map，priority_queue，</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A0%86%EF%BC%88heap%EF%BC%89"><span class="toc-number">1.5.</span> <span class="toc-text">堆（heap）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E5%AD%98%E5%82%A8%E5%A0%86"><span class="toc-number">1.5.1.</span> <span class="toc-text">数组存储堆</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A0%86%E7%9A%84%E6%93%8D%E4%BD%9C"><span class="toc-number">1.5.2.</span> <span class="toc-text">堆的操作</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%91%F0%9F%8C%B2"><span class="toc-number">1.6.</span> <span class="toc-text">树🌲</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A1%86%E6%9E%B6"><span class="toc-number">1.6.1.</span> <span class="toc-text">框架</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%91%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">1.6.2.</span> <span class="toc-text">树的基本概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">1.6.3.</span> <span class="toc-text">二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">1.6.3.1.</span> <span class="toc-text">二叉树基本概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="toc-number">1.6.3.2.</span> <span class="toc-text">二叉树的存储结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86"><span class="toc-number">1.6.3.3.</span> <span class="toc-text">二叉树遍历</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">1.6.3.4.</span> <span class="toc-text">翻转二叉树</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A4%E6%96%AD%E4%BA%8C%E5%8F%89%E6%A0%91%E6%98%AF%E5%90%A6%E5%B7%A6%E5%8F%B3%E9%95%9C%E5%83%8F"><span class="toc-number">1.6.3.5.</span> <span class="toc-text">判断二叉树是否左右镜像</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6"><span class="toc-number">1.6.3.6.</span> <span class="toc-text">二叉树最大深度</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">1.6.3.7.</span> <span class="toc-text">线索二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BB%93%E6%9E%84"><span class="toc-number">1.6.3.7.1.</span> <span class="toc-text">结构</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%AD%E5%BA%8F%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9E%84%E9%80%A0"><span class="toc-number">1.6.3.7.2.</span> <span class="toc-text">中序线索二叉树的构造</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9E%E6%BA%AF%E6%B3%95"><span class="toc-number">1.7.</span> <span class="toc-text">回溯法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E9%A2%98%E5%9E%8B%EF%BC%9A"><span class="toc-number">1.7.1.</span> <span class="toc-text">基本题型：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E4%BA%8E%E5%9B%9E%E6%BA%AF%E7%9A%84%E4%B8%80%E4%BA%9B%E4%BA%8B%E6%83%85"><span class="toc-number">1.7.2.</span> <span class="toc-text">关于回溯的一些事情</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9E%E6%BA%AF%E6%A1%86%E6%9E%B6"><span class="toc-number">1.7.3.</span> <span class="toc-text">回溯框架</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#N%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98"><span class="toc-number">1.7.4.</span> <span class="toc-text">N皇后问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%84%E5%90%88%E9%97%AE%E9%A2%98"><span class="toc-number">1.7.5.</span> <span class="toc-text">组合问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%84%E5%90%88%E9%97%AE%E9%A2%98-1"><span class="toc-number">1.7.5.1.</span> <span class="toc-text">组合问题 1</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C-1"><span class="toc-number">1.7.5.2.</span> <span class="toc-text">组合总和 1</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C-2"><span class="toc-number">1.7.5.3.</span> <span class="toc-text">组合总和 2</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%84%E5%90%88%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93%EF%BC%9A"><span class="toc-number">1.7.5.4.</span> <span class="toc-text">组合问题总结：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88"><span class="toc-number">1.7.5.5.</span> <span class="toc-text">电话号码的字母组合</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E5%89%B2%E9%97%AE%E9%A2%98"><span class="toc-number">1.7.6.</span> <span class="toc-text">分割问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E4%B8%B2"><span class="toc-number">1.7.6.1.</span> <span class="toc-text">分割回文串</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%90%E9%9B%86%E9%97%AE%E9%A2%98"><span class="toc-number">1.7.7.</span> <span class="toc-text">子集问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%90%E9%9B%861"><span class="toc-number">1.7.7.1.</span> <span class="toc-text">子集1</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%90%E9%9B%86-2"><span class="toc-number">1.7.7.2.</span> <span class="toc-text">子集 2</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95"><span class="toc-number">1.8.</span> <span class="toc-text">贪心算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E9%A2%98%E5%9E%8B"><span class="toc-number">1.8.1.</span> <span class="toc-text">基本题型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E4%BA%8E%E8%B4%AA%E5%BF%83%E7%9A%84%E4%B8%80%E4%BA%9B%E4%BA%8B%E6%83%85"><span class="toc-number">1.8.2.</span> <span class="toc-text">关于贪心的一些事情</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92"><span class="toc-number">1.9.</span> <span class="toc-text">动态规划</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E9%A2%98%E5%9E%8B-1"><span class="toc-number">1.9.1.</span> <span class="toc-text">基本题型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E4%BA%8E%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%9A%84%E4%B8%80%E4%BA%9B%E4%BA%8B%E6%83%85"><span class="toc-number">1.9.2.</span> <span class="toc-text">关于动态规划的一些事情</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E6%A1%86%E6%9E%B6"><span class="toc-number">1.9.3.</span> <span class="toc-text">动态规划框架</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%94%E9%83%A8%E6%9B%B2%EF%BC%9A"><span class="toc-number">1.9.3.1.</span> <span class="toc-text">五部曲：</span></a></li></ol></li></ol></li></ol></li></ol>
    </nav>
  </div>
</aside>

<main class="main" role="main">
  <div class="content">
  <article id="post-算法框架/算法基本格式" class="article article-type-post" itemscope itemtype="http://schema.org/BlogPosting">
    
    <div class="article-header">
      
        
  
    <h1 class="article-title" itemprop="name">
      算法框架
    </h1>
  

      
      <div class="article-meta">
        <span class="article-date">
    <i class="icon icon-calendar-check"></i>
	<a href="/2022/02/11/%E7%AE%97%E6%B3%95%E6%A1%86%E6%9E%B6/%E7%AE%97%E6%B3%95%E5%9F%BA%E6%9C%AC%E6%A0%BC%E5%BC%8F/" class="article-date">
	  <time datetime="2022-02-10T23:00:00.000Z" itemprop="datePublished">2022-02-11</time>
	</a>
</span>
        
  <span class="article-category">
    <i class="icon icon-folder"></i>
    <a class="article-category-link" href="/categories/COURS/">COURS</a>
  </span>

        
  <span class="article-tag">
    <i class="icon icon-tags"></i>
	<a class="article-tag-link-link" href="/tags/%E6%9C%89%E7%82%B9%E9%9A%BE%E5%AD%A6%E7%9A%84/" rel="tag">有点难学的</a>
  </span>


        

        <span class="post-comment"><i class="icon icon-comment"></i> <a href="/2022/02/11/%E7%AE%97%E6%B3%95%E6%A1%86%E6%9E%B6/%E7%AE%97%E6%B3%95%E5%9F%BA%E6%9C%AC%E6%A0%BC%E5%BC%8F/#comments" class="article-comment-link">Comments</a></span>
        
	
		<span class="post-wordcount hidden-xs" itemprop="wordCount">Word Count: 6k(words)</span>
	
	
		<span class="post-readcount hidden-xs" itemprop="timeRequired">Read Count: 25(minutes)</span>
	

      </div>
    </div>
    <div class="article-entry marked-body" itemprop="articleBody">
      
        <hr>
<h1 id="算法基本格式"><a href="#算法基本格式" class="headerlink" title="算法基本格式"></a>算法基本格式</h1><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h3 id="基本方法"><a href="#基本方法" class="headerlink" title="基本方法"></a>基本方法</h3><ol>
<li>二分法</li>
<li>双指针</li>
<li>滑动窗口，和双指针类似，通过窗口大小的变换来解题</li>
</ol>
<h2 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h2><h3 id="关于哈希表的一些事情"><a href="#关于哈希表的一些事情" class="headerlink" title="关于哈希表的一些事情"></a>关于哈希表的一些事情</h3><h4 id="常见的哈希表结构"><a href="#常见的哈希表结构" class="headerlink" title="常见的哈希表结构"></a>常见的哈希表结构</h4><ol>
<li>数组</li>
<li>set（unordered_set）</li>
<li>map（unordered_map）</li>
</ol>
<h3 id="适用题型"><a href="#适用题型" class="headerlink" title="适用题型"></a>适用题型</h3><blockquote>
<p><strong>当我们遇到了要快速判断一个元素是否出现集合里的时候，就要考虑哈希法</strong>。</p>
<p>但是哈希法也是<strong>牺牲了空间换取了时间</strong>，因为我们要使用额外的数组，set或者是map来存放数据，才能实现快速的查找。</p>
</blockquote>
<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><h3 id="KMP-算法"><a href="#KMP-算法" class="headerlink" title="KMP 算法"></a>KMP 算法</h3><blockquote>
<p>在一个串里查找是否出现过另外一个串</p>
</blockquote>
<h4 id="1-next-数组"><a href="#1-next-数组" class="headerlink" title="1. next 数组"></a>1. next 数组</h4><blockquote>
<p>next 数组就是一个前缀表</p>
<p><strong>前缀表是用来回退的，它记录了模式串与主串(文本串)不匹配的时候，模式串应该从哪里开始重新匹配。</strong></p>
<p>next数组就可以是前缀表，但是很多实现都是把前缀表统一减一（右移一位，初始位置为-1）之后作为next数组。</p>
</blockquote>
<p><img src="https://camo.githubusercontent.com/efed0a1e96c2f77182f3beb78cb01b40867e7c75d11e6957e1f67d21c39dd7de/68747470733a2f2f636f64652d7468696e6b696e672e63646e2e626365626f732e636f6d2f676966732f4b4d50254537254232254245254538254145254232312e676966" alt="KMP详解1"></p>
<p>求前缀表：</p>
<blockquote>
<img src="https://camo.githubusercontent.com/9ce37d3e9ac54e3ff2d4af9f765451d03982f161546ffc488774f2fe135b18f8/68747470733a2f2f636f64652d7468696e6b696e672e63646e2e626365626f732e636f6d2f706963732f4b4d50254537254232254245254538254145254232382e706e67" alt="KMP精讲8" style="zoom: 50%;" />
</blockquote>
<h2 id="队列与栈"><a href="#队列与栈" class="headerlink" title="队列与栈"></a>队列与栈</h2><h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><blockquote>
<p> <strong>栈是以底层容器完成其所有的工作，对外提供统一的接口，底层容器是可插拔的（也就是说我们可以控制使用哪种容器来实现栈的功能）。</strong></p>
<p>所以STL中栈和队列往往不被归类为容器，而被归类为container adapter（容器适配器）。</p>
<p>队列中先进先出的数据结构，栈先进后出的数据结构，不允许有遍历行为，不提供迭代器</p>
</blockquote>
<p>从下图中可以看出，栈的内部结构，栈的底层实现可以是vector，deque，list 都是可以的， 主要就是数组和链表的底层实现。</p>
<img src="https://tva1.sinaimg.cn/large/e6c9d24egy1gzk1c4b5vdj20py0i8t9r.jpg" alt="栈与队列理论3" style="zoom:33%;" />

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">默认使用deque 实现栈的底层结构</span><br><span class="line">std::stack&lt;<span class="keyword">int</span>, std::vector&lt;<span class="keyword">int</span>&gt; &gt; third;  <span class="comment">// 指定使用vector为底层容器的栈</span></span><br></pre></td></tr></table></figure>

<h4 id="队列实现栈"><a href="#队列实现栈" class="headerlink" title="队列实现栈"></a>队列实现栈</h4><p>输出栈顶元素的时候只需要不断把队列的头取出来重新添加到队列中（除了最后一个元素），然后从队列中取出来的就是栈的顺序（注意队列取出只能按照先进先出）</p>
<h4 id="栈实现队列"><a href="#栈实现队列" class="headerlink" title="栈实现队列"></a>栈实现队列</h4><p>两个栈，一个输入栈，一个输出栈，输出的时候如果输出栈有元素则输出，没有则把输入栈里所有元素弹出添加到输出栈里面</p>
<h4 id="括号匹配问题"><a href="#括号匹配问题" class="headerlink" title="括号匹配问题"></a>括号匹配问题</h4><p>使用栈解决的经典问题，栈适合做对称匹配类的问题</p>
<p>有三种情况：</p>
<ol>
<li>括号匹配完成了但是栈里还剩有元素，说明括号对应个数不一样。</li>
<li>栈已经空了，但是表达式还没有匹配完。</li>
<li>栈里和表达式的匹配不上。</li>
</ol>
<blockquote>
<p><strong>stack.empty()</strong> returns 1 if stack is empty, return 0 if is not empty.</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValid</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        stack&lt;<span class="keyword">int</span>&gt; st;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == <span class="string">&#x27;(&#x27;</span>) st.<span class="built_in">push</span>(<span class="string">&#x27;)&#x27;</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (s[i] == <span class="string">&#x27;&#123;&#x27;</span>) st.<span class="built_in">push</span>(<span class="string">&#x27;&#125;&#x27;</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (s[i] == <span class="string">&#x27;[&#x27;</span>) st.<span class="built_in">push</span>(<span class="string">&#x27;]&#x27;</span>);</span><br><span class="line">            <span class="comment">// 第三种情况：遍历字符串匹配的过程中，栈已经为空了，没有匹配的字符了，说明右括号没有找到对应的左括号 return false</span></span><br><span class="line">            <span class="comment">// 第二种情况：遍历字符串匹配的过程中，发现栈里没有我们要匹配的字符。所以return false。即字符串还没有匹配完栈已经空了</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (st.<span class="built_in">empty</span>() || st.<span class="built_in">top</span>() != s[i]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">else</span> st.<span class="built_in">pop</span>(); <span class="comment">// st.top() 与 s[i]相等，栈弹出元素</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 第一种情况：此时我们已经遍历完了字符串，但是栈不为空，说明有相应的左括号没有右括号来匹配，所以return false，否则就return true</span></span><br><span class="line">        <span class="keyword">return</span> st.<span class="built_in">empty</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="逆波兰式求值"><a href="#逆波兰式求值" class="headerlink" title="逆波兰式求值"></a>逆波兰式求值</h4><blockquote>
<p>逆波兰式是一个后缀表达式</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">evalRPN</span><span class="params">(vector&lt;string&gt;&amp; tokens)</span> </span>&#123;</span><br><span class="line">        stack&lt;<span class="keyword">int</span>&gt; st;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tokens.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="comment">//如果碰到运算符，就取出栈中的两个元素进行运算然后再把结果压入栈里</span></span><br><span class="line">            <span class="keyword">if</span> (tokens[i] == <span class="string">&quot;+&quot;</span> || tokens[i] == <span class="string">&quot;-&quot;</span> || tokens[i] == <span class="string">&quot;*&quot;</span> || tokens[i] == <span class="string">&quot;/&quot;</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> num1 = st.<span class="built_in">top</span>();</span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">int</span> num2 = st.<span class="built_in">top</span>();</span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">if</span> (tokens[i] == <span class="string">&quot;+&quot;</span>) st.<span class="built_in">push</span>(num2 + num1);</span><br><span class="line">                <span class="keyword">if</span> (tokens[i] == <span class="string">&quot;-&quot;</span>) st.<span class="built_in">push</span>(num2 - num1);</span><br><span class="line">                <span class="keyword">if</span> (tokens[i] == <span class="string">&quot;*&quot;</span>) st.<span class="built_in">push</span>(num2 * num1);</span><br><span class="line">                <span class="keyword">if</span> (tokens[i] == <span class="string">&quot;/&quot;</span>) st.<span class="built_in">push</span>(num2 / num1);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;<span class="comment">//碰到元素直接入栈</span></span><br><span class="line">                st.<span class="built_in">push</span>(<span class="built_in">stoi</span>(tokens[i]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> result = st.<span class="built_in">top</span>();</span><br><span class="line">        st.<span class="built_in">pop</span>(); <span class="comment">// 把栈里最后一个元素弹出（其实不弹出也没事）</span></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="单调队列"><a href="#单调队列" class="headerlink" title="单调队列"></a>单调队列</h4><blockquote>
<p>给定一个数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。</p>
<p>返回滑动窗口中的最大值。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">MyQueue</span> &#123;</span> <span class="comment">//单调队列（从大到小）</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        deque&lt;<span class="keyword">int</span>&gt; que; <span class="comment">// 使用deque来实现单调队列</span></span><br><span class="line">        <span class="comment">// 每次弹出的时候，比较当前要弹出的数值是否等于队列出口元素的数值，如果相等则弹出。</span></span><br><span class="line">        <span class="comment">// 同时pop之前判断队列当前是否为空。</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (!que.<span class="built_in">empty</span>() &amp;&amp; value == que.<span class="built_in">front</span>()) &#123;</span><br><span class="line">                que.<span class="built_in">pop_front</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果push的数值大于入口元素的数值，那么就将队列后端的数值弹出，直到push的数值小于等于队列入口元素的数值为止。</span></span><br><span class="line">        <span class="comment">// 这样就保持了队列里的数值是单调从大到小的了。</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (!que.<span class="built_in">empty</span>() &amp;&amp; value &gt; que.<span class="built_in">back</span>()) &#123;</span><br><span class="line">                que.<span class="built_in">pop_back</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            que.<span class="built_in">push_back</span>(value);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 查询当前队列里的最大值 直接返回队列前端也就是front就可以了。</span></span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">front</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> que.<span class="built_in">front</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">maxSlidingWindow</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        MyQueue que;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123; <span class="comment">// 先将前k的元素放进队列</span></span><br><span class="line">            que.<span class="built_in">push</span>(nums[i]);<span class="comment">//push()时就确保队列是单调的了</span></span><br><span class="line">        &#125;</span><br><span class="line">        result.<span class="built_in">push_back</span>(que.<span class="built_in">front</span>()); <span class="comment">// result 记录前k的元素的最大值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = k; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            que.<span class="built_in">pop</span>(nums[i - k]); <span class="comment">// 滑动窗口移除最前面元素</span></span><br><span class="line">            que.<span class="built_in">push</span>(nums[i]); <span class="comment">// 滑动窗口前加入最后面的元素</span></span><br><span class="line">            result.<span class="built_in">push_back</span>(que.<span class="built_in">front</span>()); <span class="comment">// 记录对应的最大值</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="前-k-个高频元素"><a href="#前-k-个高频元素" class="headerlink" title="前 k 个高频元素"></a>前 k 个高频元素</h4><blockquote>
<p>给定一个非空的整数数组，返回其中出现频率前 k 高的元素。</p>
<p>三步：</p>
<ol>
<li><p>统计出现频率（用 map），一般统计频率的都用 map</p>
<p> &lt;key, value&gt; key存储元素，value 存储元素的出现次数</p>
</li>
<li><p>排序，使用 priority_queue</p>
</li>
<li><p>取出前 k 个，就要在使用优先队列排序的时候控制队列的大小为 k，如果大于 k，就弹出元素，最后把队列中的所有元素输出即可。</p>
</li>
</ol>
</blockquote>
<h5 id="我的想法"><a href="#我的想法" class="headerlink" title="我的想法"></a>我的想法</h5><p>哈希表（和 map 一个道理）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="keyword">int</span>&gt; nums;<span class="comment">//给的数组</span></span><br><span class="line">results[];<span class="comment">//结果</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++)</span><br><span class="line">&#123;</span><br><span class="line">    nums[i]++;  <span class="comment">//nums[i]就是 i 出现的次数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="使用-map，priority-queue，"><a href="#使用-map，priority-queue，" class="headerlink" title="使用 map，priority_queue，"></a>使用 map，priority_queue，</h5><h2 id="堆（heap）"><a href="#堆（heap）" class="headerlink" title="堆（heap）"></a>堆（heap）</h2><ol>
<li>堆是<strong>完全二叉树</strong>，大根堆就是根节点的数值大于左右结点</li>
<li>优先队列，堆排序，快速找到一个集合中的最值</li>
<li>堆顶元素总是最值，但是另一个最值不确定在哪里</li>
</ol>
<h3 id="数组存储堆"><a href="#数组存储堆" class="headerlink" title="数组存储堆"></a>数组存储堆</h3><blockquote>
<p>一般都用数组来表示存储堆，i结点的父结点下标就为(i–1)/2。它的左右子结点下标分别为2 * i + 1和2 * i + 2。如第0个结点左右子结点下标分别为1和2。一个结点（i）的根节点就是 i/2（整除）</p>
</blockquote>
<h3 id="堆的操作"><a href="#堆的操作" class="headerlink" title="堆的操作"></a>堆的操作</h3><ol>
<li><p>插入：新元素被加入到heap的末尾，然后更新树以恢复堆的次序。</p>
 <img src="https://tva1.sinaimg.cn/large/e6c9d24egy1gzml9hqbqvj20h009eq49.jpg" alt="650075-68959377359ac140" style="zoom:50%;" /></li>
<li><p>删除：按定义，堆中每次都删除第0个数据。为了便于重建堆，实际的操作是将最后一个数据的值赋给根结点，然后再从根结点开始进行一次从上向下的调整。</p>
 <img src="https://tva1.sinaimg.cn/large/e6c9d24egy1gzml9vv8nlj20i50bzq53.jpg" alt="650075-87c918e6477027d2" style="zoom:50%;" /></li>
<li><p><strong>堆排序</strong><br> 堆建好之后堆中第0个数据是堆中最大的数据。取出这个数据再执行下堆的删除操作。这样堆中第0个数据又是堆中最大的数据，重复上述步骤直至堆中只有一个数据时就直接取出这个数据。</p>
</li>
</ol>
<p>​                </p>
<h2 id="树🌲"><a href="#树🌲" class="headerlink" title="树🌲"></a>树🌲</h2><h3 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h3><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gz8ts877edj30o40eg74s.jpg" alt="截屏2022-02-10 16.19.06" style="zoom:50%;" />

<h3 id="树的基本概念"><a href="#树的基本概念" class="headerlink" title="树的基本概念"></a>树的基本概念</h3><ol>
<li><p>定义</p>
<ol>
<li>是一种递归的数据结构</li>
<li>一个结点的孩子数为该节点的度，结点的最大度数为树的度</li>
<li>度为 0 的结点为叶子结点</li>
</ol>
</li>
<li><p>高度和深度</p>
<ol>
<li>高度是针对整棵树来说的，是深度的最大值（根节点深度为 1）</li>
<li>深度就是从根结点向下走，高度从下往上走</li>
</ol>
</li>
<li><p>有序树和无序树</p>
<ol>
<li>有序树的结点的左右子树有顺序不能换</li>
</ol>
</li>
<li><p>路径和长度</p>
<ol>
<li>树中两个结点之间的路径是这两个结点之间经过的结点序列构成的，路径长度是路径上边的个数</li>
<li>路径是从父节点到子节点，有方向的。所以同一结点的两个孩子之间没有路径</li>
</ol>
</li>
<li><p>性质</p>
 <img src="https://tva1.sinaimg.cn/large/008i3skNgy1gz8u7n9uupj30l604w74v.jpg" alt="截屏2022-02-10 16.33.52" style="zoom:50%;" /></li>
</ol>
<h3 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h3><h4 id="二叉树基本概念"><a href="#二叉树基本概念" class="headerlink" title="二叉树基本概念"></a>二叉树基本概念</h4><ol>
<li><p>是有序树，左右结点不能互换</p>
</li>
<li><img src="/Users/wuzilong/Library/Application%20Support/typora-user-images/%E6%88%AA%E5%B1%8F2022-02-10%2016.36.11.png" alt="截屏2022-02-10 16.36.11" style="zoom:50%;" /></li>
<li><p>二叉树与度为 2 的有序树的区别</p>
<ol>
<li>二叉树可以是空树，有序树至少有三个结点</li>
<li>如果一个二叉树结点只有左子树，那么还是要区分左右，右子树为空树</li>
</ol>
</li>
<li><p>特殊二叉树</p>
<ol>
<li><p>满二叉树</p>
</li>
<li><p>完全二叉树</p>
</li>
<li><p>二叉排序树</p>
<ol>
<li>左子树上所有结点的关键字都小于根节点的关键字</li>
<li>右子树上所有结点的关键字都大于根节点的关键字</li>
</ol>
</li>
<li><p>平衡二叉树</p>
<ol>
<li>任意结点的左子树和右子树的深度之差 &lt; = 1</li>
</ol>
</li>
<li><p>二叉树的性质</p>
<ol>
<li><p>$$<br> n_0 = n_2 +1<br> $$</p>
</li>
<li><p>第 k 层至多结点数<br> $$<br> 2^{k-1}<br> $$</p>
</li>
<li><p>高度为 h 的二叉树至多节点数<br> $$<br> 2^h-1(h&gt;=1)<br> $$</p>
</li>
<li><img src="/Users/wuzilong/Library/Application%20Support/typora-user-images/%E6%88%AA%E5%B1%8F2022-02-10%2016.46.37.png" alt="截屏2022-02-10 16.46.37" style="zoom:33%;" /></li>
</ol>
</li>
</ol>
</li>
</ol>
<h4 id="二叉树的存储结构"><a href="#二叉树的存储结构" class="headerlink" title="二叉树的存储结构"></a>二叉树的存储结构</h4><ol>
<li>顺序存储<ol>
<li><img src="/Users/wuzilong/Library/Application%20Support/typora-user-images/%E6%88%AA%E5%B1%8F2022-02-10%2016.47.46.png" alt="截屏2022-02-10 16.47.46" style="zoom:33%;" /></li>
</ol>
</li>
<li>链式存储</li>
</ol>
<h4 id="二叉树遍历"><a href="#二叉树遍历" class="headerlink" title="二叉树遍历"></a>二叉树遍历</h4><blockquote>
<p>递归写法：</p>
<ol>
<li>确定递归函数的参数和返回值</li>
<li>确定终止条件</li>
<li>确定单层递归的逻辑</li>
</ol>
</blockquote>
<ol>
<li><p>先序</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PreOrder</span><span class="params">(BiTree T, vector&lt;T&gt;&amp; result)</span></span>&#123; <span class="comment">//result for recording the order</span></span><br><span class="line">  <span class="keyword">if</span>(T != <span class="literal">NULL</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">visit</span>(T);</span><br><span class="line">    <span class="built_in">PreOrder</span>(T-&gt;LeftChild);</span><br><span class="line">    <span class="built_in">PreOrder</span>(T-&gt;RightChild);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//时间复杂度O(n)</span></span><br><span class="line"><span class="comment">//空间复杂度O(n)</span></span><br></pre></td></tr></table></figure></li>
<li><p>中序</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PreOrder</span><span class="params">(BiTree T)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(T != <span class="literal">NULL</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">PreOrder</span>(T-&gt;LeftChild);</span><br><span class="line">    <span class="built_in">visit</span>(T);</span><br><span class="line">    <span class="built_in">PreOrder</span>(T-&gt;RightChild);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>后序</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PreOrder</span><span class="params">(BiTree T)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(T != <span class="literal">NULL</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">PreOrder</span>(T-&gt;LeftChild);</span><br><span class="line">    <span class="built_in">PreOrder</span>(T-&gt;RightChild);</span><br><span class="line">    <span class="built_in">visit</span>(T);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>递归算法和非递归算法的转换（栈）</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//中序遍历的非递归实现</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InOrder</span><span class="params">(BiTree)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">InitStack</span>(s); <span class="comment">//初始化栈</span></span><br><span class="line">	BiTree p = T;  <span class="comment">//p 是遍历指针</span></span><br><span class="line">	<span class="keyword">while</span>(p||!<span class="built_in">isEmpty</span>(s))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(p)<span class="comment">//遍历左子树</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">Push</span>(s,p);</span><br><span class="line">			p=p-&gt;LeftChild;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="comment">//出栈，并转向出栈结点的右子树</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">Pop</span>(s,p);<span class="built_in">visit</span>(p);<span class="comment">//栈顶元素出栈，访问出栈元素</span></span><br><span class="line">			p=p-&gt;RightChild;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>层次遍历（队列）</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LevelOrder</span><span class="params">(BiTree T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">InitQueue</span>(Q);</span><br><span class="line">	BiTree p;</span><br><span class="line">	<span class="built_in">EnQueue</span>(Q,T);</span><br><span class="line">	<span class="keyword">while</span>(!<span class="built_in">IsEmpty</span>(Q))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">DeQueue</span>(Q,p);</span><br><span class="line">		<span class="built_in">visit</span>(p);</span><br><span class="line">		<span class="keyword">if</span>(p-&gt;leftchild != <span class="literal">NULL</span>)</span><br><span class="line">			<span class="built_in">EnQueue</span>(Q,p-&gt;leftchild);</span><br><span class="line">		<span class="keyword">if</span>(p-&gt;leftchild != <span class="literal">NULL</span>)</span><br><span class="line">			<span class="built_in">EnQueue</span>(Q,p-&gt;rightchild)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="翻转二叉树"><a href="#翻转二叉树" class="headerlink" title="翻转二叉树"></a>翻转二叉树</h4><p>可以用递归方式，先序后序都可以用</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inverse</span><span class="params">(BiTree T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">swap</span>(T-&gt;left,T-&gt;right);</span><br><span class="line">    <span class="built_in">inverse</span>(T-&gt;left);</span><br><span class="line">    <span class="built_in">inverse</span>(T-&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="判断二叉树是否左右镜像"><a href="#判断二叉树是否左右镜像" class="headerlink" title="判断二叉树是否左右镜像"></a>判断二叉树是否左右镜像</h4><p>递归三部曲</p>
<ol>
<li><p>确定递归参数和返回值</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">compare</span><span class="params">(TreeNode* left, TreeNode* right)</span></span></span><br></pre></td></tr></table></figure></li>
<li><p>确定终止条件</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (left == <span class="literal">NULL</span> &amp;&amp; right != <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (left != <span class="literal">NULL</span> &amp;&amp; right == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (left == <span class="literal">NULL</span> &amp;&amp; right == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (left-&gt;val != right-&gt;val) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 注意这里我没有使用else</span></span><br></pre></td></tr></table></figure></li>
<li><p>确定单层递归逻辑</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> outside = <span class="built_in">compare</span>(left-&gt;left, right-&gt;right);   <span class="comment">// 左子树：左、 右子树：右</span></span><br><span class="line"><span class="keyword">bool</span> inside = <span class="built_in">compare</span>(left-&gt;right, right-&gt;left);    <span class="comment">// 左子树：右、 右子树：左</span></span><br><span class="line"><span class="keyword">bool</span> isSame = outside &amp;&amp; inside;                    <span class="comment">// 左子树：中、 右子树：中（逻辑处理）</span></span><br><span class="line"><span class="keyword">return</span> isSame;</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="二叉树最大深度"><a href="#二叉树最大深度" class="headerlink" title="二叉树最大深度"></a>二叉树最大深度</h4><ol>
<li><p>递归法</p>
<ol>
<li><p>确定参数和返回值</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getdepth</span><span class="params">(treenode *node)</span></span></span><br></pre></td></tr></table></figure></li>
<li><p>确定终止条件</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(node == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure></li>
<li><p>确定单层递归逻辑</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxdepth</span><span class="params">(treenode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == null) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + <span class="built_in">max</span>(<span class="built_in">maxdepth</span>(root-&gt;left), <span class="built_in">maxdepth</span>(root-&gt;right));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>层序遍历</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxdepth</span><span class="params">(treenode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> depth = <span class="number">0</span>;</span><br><span class="line">        queue&lt;treenode*&gt; que;</span><br><span class="line">        que.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span>(!que.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">int</span> size = que.<span class="built_in">size</span>();</span><br><span class="line">            depth++; <span class="comment">// 记录深度</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">                treenode* node = que.<span class="built_in">front</span>();</span><br><span class="line">                que.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;left) que.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;right) que.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> depth;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h4 id="线索二叉树"><a href="#线索二叉树" class="headerlink" title="线索二叉树"></a>线索二叉树</h4><blockquote>
<p>遍历二叉树就是逸一定的规则将二叉树中的结点排成一个线性序列，该序列中每个节点（除了开始和结束）都有一个直接前驱和直接后继</p>
<p>引入线索二叉树是为了加快查找结点的前驱和后继的速度</p>
<img src="https://tva1.sinaimg.cn/large/008i3skNgy1gz927xanwgj30vy0c2400.jpg" alt="截屏2022-02-10 21.10.59" style="zoom: 33%;" />
</blockquote>
<h5 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ThreadNode</span>&#123;</span></span><br><span class="line">	ElemType data;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ThreadNode</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span></span><br><span class="line">	<span class="keyword">int</span> ltag,rtag;<span class="comment">//判断左右子树指针指向左右子树还是前后驱结点</span></span><br><span class="line">&#125;TreadNode;</span><br></pre></td></tr></table></figure>

<h5 id="中序线索二叉树的构造"><a href="#中序线索二叉树的构造" class="headerlink" title="中序线索二叉树的构造"></a>中序线索二叉树的构造</h5><blockquote>
<p>将二叉链表的空指针改为指向前驱后驱的线索，而前后驱结点的消息只有在遍历的时候能得到，所以线索化的实质是遍历一次二叉树</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateInTread</span><span class="params">(TreadNode T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	TreadTree pre = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">if</span>(T!=<span class="literal">NULL</span>)<span class="comment">//非空二叉树，线索化</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">Intread</span>(T,pre);<span class="comment">//线索化</span></span><br><span class="line">		pre-&gt;rchild = <span class="literal">NULL</span>;<span class="comment">//处理遍历最后一个结点</span></span><br><span class="line">		pre-&gt;rtag = <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Intread</span><span class="params">(TreadTree &amp;p,ThreadTree &amp;pre)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(p!=<span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">Intread</span>(p-&gt;lchild,pre);<span class="comment">//线索化左子树</span></span><br><span class="line">		<span class="keyword">if</span>(p-&gt;lchild == <span class="literal">NULL</span>)<span class="comment">//左子树为空，建立前驱线索</span></span><br><span class="line">		&#123;</span><br><span class="line">			p-&gt;lchild = pre;</span><br><span class="line">			ltag = <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(pre!=<span class="literal">NULL</span> &amp;&amp; pre-&gt;rchild == <span class="literal">NULL</span>)<span class="comment">//建立前驱结点的后继线索</span></span><br><span class="line">		&#123;</span><br><span class="line">			pre-&gt;rchild = p;</span><br><span class="line">			pre-&gt;rtag = <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		pre = p;</span><br><span class="line">		<span class="built_in">Intread</span>(p-&gt;rchild,pre);<span class="comment">//线索化右子树</span></span><br><span class="line">	&#125;<span class="comment">//end of if(p!=NULL)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="回溯法"><a href="#回溯法" class="headerlink" title="回溯法"></a>回溯法</h2><h3 id="基本题型："><a href="#基本题型：" class="headerlink" title="基本题型："></a>基本题型：</h3><img src="/Users/wuzilong/Library/Application%20Support/typora-user-images/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f32303231303231393139323035303636362e706e67.png" alt="68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f32303231303231393139323035303636362e706e67" style="zoom:50%;" />

<h3 id="关于回溯的一些事情"><a href="#关于回溯的一些事情" class="headerlink" title="关于回溯的一些事情"></a>关于回溯的一些事情</h3><ol>
<li><p><strong>因为回溯的本质是穷举，穷举所有可能，然后选出我们想要的答案</strong>，如果想让回溯法高效一些，可以加一些剪枝的操作，但也改不了回溯法就是穷举的本质。</p>
</li>
<li><p>所有回溯法的问题都可以抽象为树形结构！因为回溯法解决的都是在集合中递归查找子集，<strong>集合的大小就构成了树的宽度，递归的深度，都构成的树的深度</strong>。</p>
</li>
<li><p>递归就要有终止条件，所以必然是一棵高度有限的树（N叉树）。</p>
</li>
</ol>
<h3 id="回溯框架"><a href="#回溯框架" class="headerlink" title="回溯框架"></a>回溯框架</h3><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gz6h45plamj30ze0gcjtj.jpg" alt="截屏2022-02-08 11.18.12" style="zoom: 40%;" />

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">backtracking</span><span class="params">(参数)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (终止条件) &#123;</span><br><span class="line">        存放结果;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) &#123;</span><br><span class="line">        处理节点;</span><br><span class="line">        <span class="built_in">backtracking</span>(路径，选择列表); <span class="comment">// 递归</span></span><br><span class="line">        回溯，撤销处理结果</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="N皇后问题"><a href="#N皇后问题" class="headerlink" title="N皇后问题"></a>N皇后问题</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">vector&lt;vector&lt;string&gt;&gt; result;<span class="comment">//存放结果棋盘们</span></span><br><span class="line"><span class="comment">// n 为输入的棋盘大小</span></span><br><span class="line"><span class="comment">// row 是当前递归到棋盘的第几行了</span></span><br><span class="line"><span class="comment">// 回溯函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">backtracking</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> row, vector&lt;string&gt;&amp; chessboard)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (row == n) &#123;</span><br><span class="line">        result.<span class="built_in">push_back</span>(chessboard);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> col = <span class="number">0</span>; col &lt; n; col++) &#123;<span class="comment">//判断 row 这一行那个位置可以放</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isValid</span>(row, col, chessboard, n)) &#123; <span class="comment">// 验证合法就可以放</span></span><br><span class="line">            chessboard[row][col] = <span class="string">&#x27;Q&#x27;</span>; <span class="comment">// 放置皇后</span></span><br><span class="line">            <span class="built_in">backtracking</span>(n, row + <span class="number">1</span>, chessboard);<span class="comment">//寻找下一行可以放的位置</span></span><br><span class="line">            chessboard[row][col] = <span class="string">&#x27;.&#x27;</span>; <span class="comment">// 回溯，撤销皇后</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断(row,col)这个位置可不可以放</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isValid</span><span class="params">(<span class="keyword">int</span> row, <span class="keyword">int</span> col, vector&lt;string&gt;&amp; chessboard, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 检查列(i,col)</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; i++) &#123; <span class="comment">// 这是一个剪枝</span></span><br><span class="line">        <span class="keyword">if</span> (chessboard[i][col] == <span class="string">&#x27;Q&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 检查 45度角是否有皇后</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = row - <span class="number">1</span>, j = col - <span class="number">1</span>; i &gt;=<span class="number">0</span> &amp;&amp; j &gt;= <span class="number">0</span>; i--, j--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (chessboard[i][j] == <span class="string">&#x27;Q&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 检查 135度角是否有皇后</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = row - <span class="number">1</span>, j = col + <span class="number">1</span>; i &gt;= <span class="number">0</span> &amp;&amp; j &lt; n; i--, j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (chessboard[i][j] == <span class="string">&#x27;Q&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; <span class="built_in">solveNQueens</span>(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        result.<span class="built_in">clear</span>();</span><br><span class="line">        <span class="function">std::vector&lt;std::string&gt; <span class="title">chessboard</span><span class="params">(n, std::string(n, <span class="string">&#x27;.&#x27;</span>))</span></span>;</span><br><span class="line">        <span class="built_in">backtracking</span>(n, <span class="number">0</span>, chessboard);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="组合问题"><a href="#组合问题" class="headerlink" title="组合问题"></a>组合问题</h3><h4 id="组合问题-1"><a href="#组合问题-1" class="headerlink" title="组合问题 1"></a>组合问题 1</h4><p>给定两个整数 n 和 k，返回 1 … n 中所有可能的 k 个数的组合。每个元素只能用一次</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; result;<span class="comment">//存放结果</span></span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; path;<span class="comment">//保存每次选取结果</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backtracking</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k, <span class="keyword">int</span> startIndex)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (path.<span class="built_in">size</span>() == k) &#123; <span class="comment">//已经选取 k 个数了，该次递归结束</span></span><br><span class="line">            result.<span class="built_in">push_back</span>(path);<span class="comment">//存入结果集</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = startIndex; i &lt;= n - (k - path.<span class="built_in">size</span>()) + <span class="number">1</span>; i++) &#123; <span class="comment">// 优化的地方</span></span><br><span class="line">          <span class="comment">//就是说剩下的元素已经小于 K 了，那么无论怎么组合都选取不到 k 个，可以提前结束</span></span><br><span class="line">          <span class="comment">//n - (k - path.size()) + 1 就是最后满足条件的坐标 </span></span><br><span class="line">            path.<span class="built_in">push_back</span>(i); <span class="comment">// 处理节点</span></span><br><span class="line">            <span class="built_in">backtracking</span>(n, k, i + <span class="number">1</span>);</span><br><span class="line">            path.<span class="built_in">pop_back</span>(); <span class="comment">// 回溯，撤销处理的节点</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">combine</span>(<span class="keyword">int</span> n, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="built_in">backtracking</span>(n, k, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gz6h3wx18cj30ym0msjum.jpg" alt="截屏2022-02-08 15.29.28"></p>
<h4 id="组合总和-1"><a href="#组合总和-1" class="headerlink" title="组合总和 1"></a>组合总和 1</h4><blockquote>
<p>给你一个 <em><strong>无重复元素</strong></em> 的整数数组 candidates 和一个目标整数 target ，找出 candidates 中可以使数字和为目标数 target 的 所有 不同组合 ，并以列表形式返回。你可以按 任意顺序 返回这些组合。</p>
<p>candidates 中的 同一个 数字可以 无限制重复被选取 。如果至少一个数字的被选数量不同，则两种组合是不同的。 </p>
<p>对于给定的输入，保证和为 target 的不同组合数少于 150 个。</p>
<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/combination-sum">https://leetcode-cn.com/problems/combination-sum</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">combinationSum</span>(vector&lt;<span class="keyword">int</span>&gt;&amp; candidates, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="built_in">backtracking</span>(target,<span class="number">0</span>,candidates,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; result;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; path;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backtracking</span><span class="params">(<span class="keyword">int</span> targetsum,<span class="keyword">int</span> sum,<span class="keyword">const</span> vector&lt;<span class="keyword">int</span>&gt; candidates,<span class="keyword">int</span> startindex)</span><span class="comment">//如何解决重复的结果：可重复选取当前的元素</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(sum&gt;targetsum)<span class="comment">//另外一种结束出口</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(sum == targetsum)<span class="comment">//找到组合 </span></span><br><span class="line">        &#123;</span><br><span class="line">            result.<span class="built_in">push_back</span>(path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = startindex;i&lt;candidates.<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            path.<span class="built_in">push_back</span>(candidates[i]);</span><br><span class="line">            sum+=candidates[i];</span><br><span class="line">            <span class="built_in">backtracking</span>(targetsum,sum,candidates,i);</span><br><span class="line">            sum-=candidates[i];</span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">        for(int i = startindex;i&lt;candidates.size();i++) //注意这里使用了 startindex 而不是从 0 开始，因为如果从 0 开始当前元素前面的元素也会纳入计算，就会使得结果重复，</span></span><br><span class="line"><span class="comment">        &#123;</span></span><br><span class="line"><span class="comment">            path.push_back(candidates[i]);</span></span><br><span class="line"><span class="comment">            sum+=candidates[i];</span></span><br><span class="line"><span class="comment">            backtracking(targetsum,sum,candidates,i);//i不用+1，当前元素也可以选取</span></span><br><span class="line"><span class="comment">            sum-=candidates[i];</span></span><br><span class="line"><span class="comment">            path.pop_back();</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h4 id="组合总和-2"><a href="#组合总和-2" class="headerlink" title="组合总和 2"></a>组合总和 2</h4><blockquote>
<p>给定一个数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。</p>
<p>candidates 中的每个数字在每个组合中只能使用一次。canadidates 的元素可以重复</p>
<p>说明： 所有数字（包括目标数）都是正整数。 解集不能包含重复的组合。 </p>
<p>示例 1: 输入: candidates = [10,1,2,7,6,1,5], target = 8, 所求解集为: [ [1, 7], [1, 2, 5], [2, 6], [1, 1, 6] ]</p>
<p>示例 2: 输入: candidates = [2,5,2,1,2], target = 5, 所求解集为: [  [1,2,2],  [5] ]</p>
</blockquote>
<img src="https://tva1.sinaimg.cn/large/008i3skNgy1gz9q852ermj31c60scwk1.jpg" alt="68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f32303230313132333230323733363338342e706e67" style="zoom:33%;" />

<p>为实现去重，要先对数组排序，然后设置 used 数组记录同一层的相同元素是否被使用过</p>
<img src="https://tva1.sinaimg.cn/large/008i3skNgy1gz9qdbsj1vj31d40sc7b9.jpg" alt="68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f32303230313132333230323831373937332e706e67" style="zoom:33%;" />

<h4 id="组合问题总结："><a href="#组合问题总结：" class="headerlink" title="组合问题总结："></a>组合问题总结：</h4><ol>
<li>给你一个无重复的 candidate 数组，里面的数字不可以重复使用，使其和等于target，那么下一层的 startindex 就是当前层的 stratindex 的下一个</li>
<li>给你一个无重复的 candidate 数组，里面的数字可以重复使用，使其和等于target，那么下一层的startindex和当前的一样。</li>
<li>给你一个重复的 candidate 数组，那么同一树层不能用相同的元素，同一树枝可以用相同的元素</li>
</ol>
<h4 id="电话号码的字母组合"><a href="#电话号码的字母组合" class="headerlink" title="电话号码的字母组合"></a>电话号码的字母组合</h4><blockquote>
<p>给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。答案可以按 任意顺序 返回。</p>
<p>给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。</p>
<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number">https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">letterCombinations</span><span class="params">(string digits)</span> </span>&#123;</span><br><span class="line">        result.<span class="built_in">clear</span>();</span><br><span class="line">        path.<span class="built_in">clear</span>();</span><br><span class="line">        <span class="keyword">if</span>(digits.<span class="built_in">size</span>() == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">        <span class="built_in">backtracking</span>(digits,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;string&gt; result;<span class="comment">//存放结果集</span></span><br><span class="line">    string path;<span class="comment">//存放每次的结果</span></span><br><span class="line">    <span class="keyword">const</span> string lettermap[<span class="number">10</span>]= &#123;<span class="comment">//建立数字字母映射关系</span></span><br><span class="line">        <span class="string">&quot;&quot;</span>,<span class="comment">//0</span></span><br><span class="line">        <span class="string">&quot;&quot;</span>,<span class="comment">//1</span></span><br><span class="line">        <span class="string">&quot;abc&quot;</span>,<span class="comment">//2</span></span><br><span class="line">        <span class="string">&quot;def&quot;</span>,<span class="comment">//3</span></span><br><span class="line">        <span class="string">&quot;ghi&quot;</span>,<span class="comment">//4</span></span><br><span class="line">        <span class="string">&quot;jkl&quot;</span>,<span class="comment">//5</span></span><br><span class="line">        <span class="string">&quot;mno&quot;</span>,<span class="comment">//6</span></span><br><span class="line">        <span class="string">&quot;pqrs&quot;</span>,<span class="comment">//7</span></span><br><span class="line">        <span class="string">&quot;tuv&quot;</span>,<span class="comment">//8</span></span><br><span class="line">        <span class="string">&quot;wxyz&quot;</span>,<span class="comment">//9</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backtracking</span><span class="params">(<span class="keyword">const</span> string &amp;digits, <span class="keyword">int</span> index)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(path.<span class="built_in">size</span>() == digits.<span class="built_in">size</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            result.<span class="built_in">push_back</span>(path);</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> digit = digits[index] - <span class="string">&#x27;0&#x27;</span>;<span class="comment">//获得 index 指向的 digit 字符串中的数字</span></span><br><span class="line">        string letters = lettermap[digit];<span class="comment">//获取该数字对应的字符集</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;letters.<span class="built_in">size</span>();i++)<span class="comment">//对获取到的字符集进行遍历</span></span><br><span class="line">        &#123;</span><br><span class="line">            path.<span class="built_in">push_back</span>(letters[i]);</span><br><span class="line">            <span class="built_in">backtracking</span>(digits,index+<span class="number">1</span>);</span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="分割问题"><a href="#分割问题" class="headerlink" title="分割问题"></a>分割问题</h3><h4 id="分割回文串"><a href="#分割回文串" class="headerlink" title="分割回文串"></a>分割回文串</h4><img src="/Users/wuzilong/Library/Application%20Support/typora-user-images/68747470733a2f2f636f64652d7468696e6b696e672e63646e2e626365626f732e636f6d2f706963732f3133312e2545352538382538362545352538392542322545352539422539452545362539362538372545342542382542322e6a7067.jpeg" alt="68747470733a2f2f636f64652d7468696e6b696e672e63646e2e626365626f732e636f6d2f706963732f3133312e2545352538382538362545352538392542322545352539422539452545362539362538372545342542382542322e6a7067" style="zoom:33%;" />

<p>当下一层的开始元素和当前层不一样的时候，就需要使用 startindex</p>
<h3 id="子集问题"><a href="#子集问题" class="headerlink" title="子集问题"></a>子集问题</h3><p>如果把 子集问题、组合问题、分割问题都抽象为一棵树的话，<strong>那么组合问题和分割问题都是收集树的叶子节点，而子集问题是找树的所有节点！</strong>    </p>
<h4 id="子集1"><a href="#子集1" class="headerlink" title="子集1"></a>子集1</h4><blockquote>
<p>给定一组<strong>不含重复</strong>元素的整数数组 nums，返回该数组所有可能的子集（幂集）。</p>
<p>说明：解集不能包含重复的子集。</p>
</blockquote>
<img src="https://camo.githubusercontent.com/3f67c171ede9807a17fdeaf91ac87e7813516ad272a3c4ac55ee292514ff2acf/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f3230323031313233323034313334382e706e67" alt="78.子集" style="zoom:50%;" />



<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">subsets</span>(vector&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">   result.<span class="built_in">clear</span>();</span><br><span class="line">        path.<span class="built_in">clear</span>();</span><br><span class="line">        <span class="built_in">back</span>(<span class="number">0</span>,nums);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; path;</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; result;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">back</span><span class="params">(<span class="keyword">int</span> startindex,vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        result.<span class="built_in">push_back</span>(path);<span class="comment">//和组合排列问题的差别主要体现在这里</span></span><br><span class="line">        <span class="comment">//每次向下递归的时候都要收集结果</span></span><br><span class="line">        <span class="keyword">if</span>(startindex&gt;=nums.<span class="built_in">size</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = startindex;i&lt;nums.<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            path.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">            <span class="built_in">back</span>(i + <span class="number">1</span>,nums);</span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="子集-2"><a href="#子集-2" class="headerlink" title="子集 2"></a>子集 2</h4><blockquote>
<p>给你一个整数数组 nums ，其中可能包含重复元素，请你返回该数组所有可能的子集（幂集）。</p>
<p>解集 不能 包含重复的子集。返回的解集中，子集可以按 任意顺序 排列。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">subsetsWithDup</span>(vector&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">bool</span>&gt; <span class="title">used</span><span class="params">(nums.size(), <span class="literal">false</span>)</span></span>;</span><br><span class="line">        <span class="built_in">backtracking</span>(nums, <span class="number">0</span>, used);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:    </span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; path;</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; result;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backtracking</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums,<span class="keyword">int</span> startindex,vector&lt;<span class="keyword">bool</span>&gt;&amp; used)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        result.<span class="built_in">push_back</span>(path);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = startindex; i &lt; nums.<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// used[i - 1] == true，说明同一树枝candidates[i - 1]使用过</span></span><br><span class="line">            <span class="comment">// used[i - 1] == false，说明同一树层candidates[i - 1]使用过</span></span><br><span class="line">            <span class="comment">// 而我们要对同一树层使用过的元素进行跳过</span></span><br><span class="line">            <span class="keyword">if</span>(i&gt;<span class="number">0</span> &amp;&amp; nums[i] == nums[i<span class="number">-1</span>] &amp;&amp; used[i<span class="number">-1</span>] == <span class="literal">false</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            path.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">            used[i] = <span class="literal">true</span>;</span><br><span class="line">            <span class="built_in">backtracking</span>(nums, i + <span class="number">1</span>, used);</span><br><span class="line">            used[i] = <span class="literal">false</span>;</span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>







<h2 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h2><h3 id="基本题型"><a href="#基本题型" class="headerlink" title="基本题型"></a>基本题型</h3><img src="/Users/wuzilong/Library/Application%20Support/typora-user-images/68747470733a2f2f636f64652d7468696e6b696e672d313235333835353039332e66696c652e6d7971636c6f75642e636f6d2f706963732f32303231303931373130343331352e706e67.png" alt="68747470733a2f2f636f64652d7468696e6b696e672d313235333835353039332e66696c652e6d7971636c6f75642e636f6d2f706963732f32303231303931373130343331352e706e67" style="zoom:33%;" />

<h3 id="关于贪心的一些事情"><a href="#关于贪心的一些事情" class="headerlink" title="关于贪心的一些事情"></a>关于贪心的一些事情</h3><ol>
<li><strong>贪心的本质是选择每一阶段的局部最优，从而达到全局最优</strong>。</li>
<li>验证问题是不是可以用贪心，可以举几个例子看结果是不是最优的</li>
</ol>
<h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><h3 id="基本题型-1"><a href="#基本题型-1" class="headerlink" title="基本题型"></a>基本题型</h3><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gz8saa0s9lj30u01rkwkq.jpg" alt="68747470733a2f2f636f64652d7468696e6b696e672e63646e2e626365626f732e636f6d2f706963732fe58aa8e68081e8a784e588922de680bbe7bb93e5a4a7e7bab2312e6a7067" style="zoom: 33%;" />

<h3 id="关于动态规划的一些事情"><a href="#关于动态规划的一些事情" class="headerlink" title="关于动态规划的一些事情"></a>关于动态规划的一些事情</h3><ol>
<li>如果某一问题有很多重叠子问题，使用动态规划是最有效的。</li>
<li>动态规划中<em><strong>每一个状态一定是由上一个状态推导</strong></em>出来的，<strong>这一点就区分于贪心</strong>，贪心没有状态推导（和上一个状态没有关系），而是从局部直接选最优的，</li>
<li>所以贪心解决不了动态规划的问题。</li>
</ol>
<h3 id="动态规划框架"><a href="#动态规划框架" class="headerlink" title="动态规划框架"></a>动态规划框架</h3><h4 id="五部曲："><a href="#五部曲：" class="headerlink" title="五部曲："></a>五部曲：</h4><ol>
<li>确定 dp数组及其下标含义</li>
<li>确定递推公式</li>
<li>初始化 dp 数组</li>
<li>确定遍历顺序</li>
<li>举例推导 dp 数组</li>
</ol>

      
    </div>
    <div class="article-footer">
      <blockquote class="mt-2x">
  <ul class="post-copyright list-unstyled">
    
    <li class="post-copyright-link hidden-xs">
      <strong>本文链接：</strong>
      <a href="http://littlewuuu.com/2022/02/11/%E7%AE%97%E6%B3%95%E6%A1%86%E6%9E%B6/%E7%AE%97%E6%B3%95%E5%9F%BA%E6%9C%AC%E6%A0%BC%E5%BC%8F/" title="算法框架" target="_blank" rel="external">http://littlewuuu.com/2022/02/11/算法框架/算法基本格式/</a>
    </li>
    
    <li class="post-copyright-license">
      <strong>版权声明： </strong> 本博客所有文章除特别声明外，均采用 <a href="http://creativecommons.org/licenses/by/4.0/deed.zh" target="_blank" rel="external">CC BY 4.0 CN协议</a> 许可协议。转载请注明出处！
    </li>
  </ul>
</blockquote>


<div class="panel panel-default panel-badger">
  <div class="panel-body">
    <figure class="media">
      <div class="media-left">
        <a href="https://github.com/littlewuuu" target="_blank" class="img-burn thumb-sm visible-lg">
          <img src="/images/mee.jpg" class="img-rounded w-full" alt="">
        </a>
      </div>
      <div class="media-body">
        <h3 class="media-heading"><a href="https://github.com/littlewuuu" target="_blank"><span class="text-dark">Wuuu</span><small class="ml-1x">un étudiant</small></a></h3>
        <div>争取每天都能思考</div>
      </div>
    </figure>
  </div>
</div>


    </div>
  </article>
  
    
  <section id="comments">
  	
      <div id="vcomments"></div>
    
  </section>


  
</div>

  <nav class="bar bar-footer clearfix" data-stick-bottom>
  <div class="bar-inner">
  
  <ul class="pager pull-left">
    
    <li class="prev">
      <a href="/2022/02/27/HTML+CSS/HTML+CSS/" title="HTML+CSS"><i class="icon icon-angle-left" aria-hidden="true"></i><span>&nbsp;&nbsp;Newer</span></a>
    </li>
    
    
    <li class="next">
      <a href="/2022/02/06/ENGLISH/SIX%20MINUTES/" title="6 Minute English and ECN"><span>Older&nbsp;&nbsp;</span><i class="icon icon-angle-right" aria-hidden="true"></i></a>
    </li>
    
    
    <li class="toggle-toc">
      <a class="toggle-btn collapsed" data-toggle="collapse" href="#collapseToc" aria-expanded="false" title="Catalogue" role="button">
        <span>[&nbsp;</span><span>Catalogue</span>
        <i class="text-collapsed icon icon-anchor"></i>
        <i class="text-in icon icon-close"></i>
        <span>]</span>
      </a>
    </li>
    
  </ul>
  
  
  
  <div class="bar-right">
    
  </div>
  </div>
</nav>
  


</main>

  <footer class="footer" itemscope itemtype="http://schema.org/WPFooter">
	
	
    <ul class="social-links">
    	
        <li><a href="https://github.com/littlewuuu" target="_blank" title="Github" data-toggle=tooltip data-placement=top><i class="icon icon-github"></i></a></li>
        
        <li><a href="https://weibo.com/littlewuu" target="_blank" title="Weibo" data-toggle=tooltip data-placement=top><i class="icon icon-weibo"></i></a></li>
        
        <li><a href="https://huaban.com/littlewuuu" target="_blank" title="花瓣" data-toggle=tooltip data-placement=top><i class="icon icon-花瓣"></i></a></li>
        
    </ul>

    <div class="copyright">
    	
        <div class="publishby">
        	Theme by <a href="https://github.com/cofess" target="_blank"> cofess </a>base on <a href="https://github.com/cofess/hexo-theme-pure" target="_blank">pure</a>.
        </div>
    </div>
</footer>
  <script src="//cdn.jsdelivr.net/npm/jquery@1.12.4/dist/jquery.min.js"></script>
<script>
window.jQuery || document.write('<script src="js/jquery.min.js"><\/script>')
</script>

<script src="/js/plugin.min.js"></script>


<script src="/js/application.js"></script>


    <script>
(function (window) {
    var INSIGHT_CONFIG = {
        TRANSLATION: {
            POSTS: 'Posts',
            PAGES: 'Pages',
            CATEGORIES: 'Categories',
            TAGS: 'Tags',
            UNTITLED: '(Untitled)',
        },
        ROOT_URL: '/',
        CONTENT_URL: '/content.json',
    };
    window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);
</script>

<script src="/js/insight.js"></script>






   




   
    
  <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/valine"></script>
  <script type="text/javascript">
  var GUEST = ['nick', 'mail', 'link'];
  var meta = 'nick,mail,link';
  meta = meta.split(',').filter(function(item) {
    return GUEST.indexOf(item) > -1;
  });
  new Valine({
    el: '#vcomments',
    verify: false,
    notify: false,
    appId: 'Pa4f8w5r06eQiW8omEO65tSa-MdYXbMMI',
    appKey: 'Tk8949QkzxjnbpStpWDrDHJT',
    placeholder: 'Not ready yet',
    avatar: 'mm',
    meta: meta,
    pageSize: '10' || 10,
    visitor: false
  });
  </script>

     



  <script src="//cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.3.5/dist/jquery.fancybox.min.js"></script>
  <script>
  //利用 FancyBox 实现点击图片放大
  $(document).ready(function() {
    $('article img').not('[hidden]').not('.panel-body img').each(function() {
      var $image = $(this);
      var imageCaption = $image.attr('alt');
      var $imageWrapLink = $image.parent('a');
      if ($imageWrapLink.length < 1) {
        var src = this.getAttribute('src');
        var idx = src.lastIndexOf('?');
        if (idx != -1) {
          src = src.substring(0, idx);
        }
        $imageWrapLink = $image.wrap('<a href="' + src + '"></a>').parent('a');
      }
      $imageWrapLink.attr('data-fancybox', 'images');
      if (imageCaption) {
        $imageWrapLink.attr('data-caption', imageCaption);
      }
    });
    $().fancybox({
      selector: '[data-fancybox="images"]',
      hash: false,
      loop: false,
    });
  });
  </script>





</body>
</html>