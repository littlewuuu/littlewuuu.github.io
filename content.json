{"meta":{"title":"hexo","subtitle":"","description":"","author":"Zilong WU","url":"http://littlewuuu.com","root":"/"},"pages":[{"title":"404 Not Found：该页无法显示","date":"2022-02-20T19:43:53.445Z","updated":"2021-12-30T15:37:54.580Z","comments":false,"path":"/404.html","permalink":"http://littlewuuu.com/404.html","excerpt":"","text":""},{"title":"没怎么读过书 😄","date":"2022-02-20T19:43:53.393Z","updated":"2021-12-30T19:46:11.373Z","comments":false,"path":"books/index.html","permalink":"http://littlewuuu.com/books/index.html","excerpt":"","text":""},{"title":"分类","date":"2022-02-20T19:43:53.462Z","updated":"2021-12-30T15:37:54.580Z","comments":false,"path":"categories/index.html","permalink":"http://littlewuuu.com/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2022-02-20T19:43:53.405Z","updated":"2021-12-30T15:37:54.580Z","comments":false,"path":"tags/index.html","permalink":"http://littlewuuu.com/tags/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2022-02-20T19:44:10.874Z","updated":"2021-12-30T19:05:33.332Z","comments":false,"path":"repository/index.html","permalink":"http://littlewuuu.com/repository/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2022-02-20T19:43:53.413Z","updated":"2021-12-30T15:37:54.580Z","comments":true,"path":"links/index.html","permalink":"http://littlewuuu.com/links/index.html","excerpt":"","text":""},{"title":"关于我","date":"2022-02-20T19:43:53.380Z","updated":"2021-12-30T19:49:30.276Z","comments":false,"path":"about/index.html","permalink":"http://littlewuuu.com/about/index.html","excerpt":"","text":"个人详细介绍：个人不想详细介绍"}],"posts":[{"title":"Memoriser","slug":"Francaise/à memoriser","date":"2022-11-05T23:00:00.000Z","updated":"2022-11-15T16:04:06.871Z","comments":true,"path":"2022/11/06/Francaise/à memoriser/","link":"","permalink":"http://littlewuuu.com/2022/11/06/Francaise/a%CC%80%20memoriser/","excerpt":"","text":"les connecteurs logiques 用途 例子 ajouter une idée L’ADDITION Ensuite, de plus, en outre… De même que / sans compter que /ainsi que /non seulement… mais encore + indicatifQuant à + nom illustrer une idée, apporter un exemple L’ILLUSTRATION Par exemple /ainsi /en effetNotamment /en d’autres termes /c’est-à-dire /autrement dit réfuter l’argument opposé L’OPPOSITION Cependant /pourtant /en revanche /au contraire/ maistandis que, alors que + indicatifAu lieu de + infinitif ou nomContrairement à + nomContrairement à ce que + indicatif apporter des nuances, des paradoxes. LA CONCESSION Toutefois /néanmoins/pourtant/ cependantBien que / quoique /encore que + subjonctif Même si + indicatif (opposition et condition ou condition et hypothèse)C’est un bon réalisateur même s’il n’a pas reçu la Palme d’or.Il ne nous aurait rien dit même s’il l’avait su.Malgré / en dépit de + nom apporter des preuves, des justifications LA CAUSE Parce que / car / en effetPuisque / étant donné que /comme /sous prétexte que / du fait queGrâce à (ce que) + cause positiveÀ cause de (ce que) + cause négativeen raison de (ce que) + cause positive ou neutre montrer les résultats, les conséquences LA CONSÉQUENCE De sorte que / si bien que /de façon que / au point que /tellement… que, si…que… + indicatifFinalement /ainsi /voilà pourquoi /c’est pourquoi /par conséquent / c’est pour cela queAlors / donc / ainsi exprimer un but LE BUT Pour que /de peur que /de crainte que /afin que + subjonctifPour / dans le but de / afin de /en vue de + infinitif exprimer une condition LA CONDITION SiAu cas où + conditionnelÀ condition que + subjonctifEn admettant que / supposons que + subjonctifPourvu que + subjonctif (Exprime l’idée d’espoir) Les prépositions","categories":[{"name":"le français","slug":"le-francais","permalink":"http://littlewuuu.com/categories/le-francais/"}],"tags":[{"name":"le français","slug":"le-francais","permalink":"http://littlewuuu.com/tags/le-francais/"}]},{"title":"遇到的专业词汇","slug":"遇到的专业词汇","date":"2022-10-02T22:00:00.000Z","updated":"2022-10-03T20:13:12.299Z","comments":true,"path":"2022/10/03/遇到的专业词汇/","link":"","permalink":"http://littlewuuu.com/2022/10/03/%E9%81%87%E5%88%B0%E7%9A%84%E4%B8%93%E4%B8%9A%E8%AF%8D%E6%B1%87/","excerpt":"","text":"I noticed starting with version 8 that the Java installer now prepends to （先于）the Windows PATH variable C:\\ProgramData\\Oracle\\Java\\javapath. If I suffixed[/‘sʌfɪks/]（后缀到） it to the end of the Windows PATH variable then Java 8 was always being picked up (Windows searches the directories left-to-right in the PATH variable).","categories":[{"name":"SKILLS","slug":"SKILLS","permalink":"http://littlewuuu.com/categories/SKILLS/"}],"tags":[]},{"title":"GELOG","slug":"GELOG/GELOG_notes","date":"2022-10-02T22:00:00.000Z","updated":"2022-11-10T14:58:32.424Z","comments":true,"path":"2022/10/03/GELOG/GELOG_notes/","link":"","permalink":"http://littlewuuu.com/2022/10/03/GELOG/GELOG_notes/","excerpt":"","text":"I. Diagramme de cas d’utilisation包含关系 &lt;\\&gt;包含关系描述的是一个用例需要某种功能，而该功能被另外一个用例定义，那么在用例的执行过程中，就可以调用已经定义好的用例。 扩展关系一个用例（可选）扩展另一个用例（基本例）的功能，将一些常规的动作放在一个基本用例中，将可选的或只在特定条件下才执行的动作放在它的扩展用例中。 泛化关系（继承）泛化关系指的是一般(父用例)与特殊(子用例)的关系。当多个用例共同拥有一种类似的结构和行为时，可以将它们的共性抽象为父用例，其他的用例作为泛化关系中的子用例。 可以用于 actor 和 case 依赖关系 30-09-2022Agile 灵活的 Projet type(non agile) Expression de besoins (Buget) Cahier des charges (Equipe Projet Planning V0) Specification generales (Planning Chiffrage) Specification détaillées Implém. Valitation (correction) II. Diagrammes de classes et d’objetsClass写在哪一边就表示哪一边有几个实例 1 : un et un seul 0..1 : zéro ou un M..N : de M à N * ou 0.. *: de zéro à plusieurs 1..* : de un à plusieurs privé (-) , protégé (#), public (+) 关联关系用线表示就好了，比如司机和车（开车） Objet III. Diagrame de sequencehttps://blog.csdn.net/fly_zxy/article/details/80911942 所有的执行者都用方框表示。 之间的消息通讯用实线箭头表示 组合片段 DIAGRAMMES DE COMMUNICATION（Collaboration） IV. Diagrammes d’états-transitions V. Diagrammes d’activitéhttps://www.cnblogs.com/wolf-sun/p/3432135.html 2022-10-14Cours d’initiation au DevOps","categories":[{"name":"COURS","slug":"COURS","permalink":"http://littlewuuu.com/categories/COURS/"}],"tags":[{"name":"ECN","slug":"ECN","permalink":"http://littlewuuu.com/tags/ECN/"}]},{"title":"环境变量修改","slug":"MacOS的PATH修改","date":"2022-09-21T22:00:00.000Z","updated":"2022-09-23T19:25:18.709Z","comments":true,"path":"2022/09/22/MacOS的PATH修改/","link":"","permalink":"http://littlewuuu.com/2022/09/22/MacOS%E7%9A%84PATH%E4%BF%AE%E6%94%B9/","excerpt":"","text":"MacOS PATH环境变量相关的文件按下述顺序加载： /etc/profile /etc/paths /etc/bashrc ~/.bash_profile 或 ~/.bashrc ~/.bash_login /etc/profile, /etc/paths, /etc/bashrc 是系统级别配置文件，系统启动就会加载。 后面几个是当前用户级的环境变量，按照从前往后的顺序读取，如果 ~/.bash_profile文件存在，则后面的几个文件就会被忽略不读，如果~/.bash_profile文件不存在，才会以此类推读取后面的文件。 ~/.bashrc没有上述规则，它是bash shell打开的时候载入的。 全局修改用户级别修改一般都是修改~/.bash_profile文件（Linux中是~/.bashrc，而Mac OS是~/.bash_profile） 检查是不是在环境变量里了 1echo $PATH 打开相应文件夹 1open ~/.bash_profile 如果遇到 permission denied，使用 1sudo chown username ~/.bash_profile 修改用户权限 添加后保存 12# 注释export &quot;PATH=路径:$PATH&quot; 输入使修改生效 1source ~/.bash_profile","categories":[{"name":"SKILLS","slug":"SKILLS","permalink":"http://littlewuuu.com/categories/SKILLS/"}],"tags":[]},{"title":"JAVA","slug":"Java/JavaNotes","date":"2022-09-06T22:00:00.000Z","updated":"2022-11-13T16:17:40.067Z","comments":true,"path":"2022/09/07/Java/JavaNotes/","link":"","permalink":"http://littlewuuu.com/2022/09/07/Java/JavaNotes/","excerpt":"","text":"String 类 使用 Unicode 编码，一个字符（不区分字母汉字）占两个字节 String 是 final 类 属性 private final char value[] 存放字符串内容，指向的地址不能修改，但是地址里的内容可以改 创建 String 的两种方式的区别 如果父类该属性是私有的，就直接报错，即使父类的父类有该属性且不是私有 方法重写 多态 （方法+对象） 1、 方法的多态就是 【重写】 +【 重载】 2、 对象的多态 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172package com.hspedu.poly_.detail_;public class Animal &#123; String name = &quot;动物&quot;; int age = 10; public void sleep()&#123; System.out.println(&quot;睡&quot;); &#125; public void run()&#123; System.out.println(&quot;跑&quot;); &#125; public void eat()&#123; System.out.println(&quot;吃&quot;); &#125; public void show()&#123; System.out.println(&quot;hello,你好&quot;); &#125;&#125;---------------------------package com.hspedu.poly_.detail_;public class Cat extends Animal &#123; public void eat()&#123;//方法重写 System.out.println(&quot;猫吃鱼&quot;); &#125; public void catchMouse()&#123;//Cat特有方法 System.out.println(&quot;猫抓老鼠&quot;); &#125;&#125;---------------------------package com.hspedu.poly_.detail_;public class Dog extends Animal &#123;//Dog是Animal的子类&#125;---------------------------package com.hspedu.poly_.detail_;public class PolyDetail &#123; public static void main(String[] args) &#123; //向上转型: 父类的引用指向了子类的对象 //语法：父类类型引用名 = new 子类类型(); Animal animal = new Cat(); Object obj = new Cat();//可以吗? 可以 Object 也是 Cat的父类 //向上转型调用方法的规则如下: //(1)可以调用父类中的所有成员(需遵守访问权限) //(2)但是不能调用子类的特有的成员 //(#)因为在编译阶段，能调用哪些成员,是由编译类型来决定的 //animal.catchMouse();错误 //(4)最终运行效果看子类(运行类型)的具体实现, 即调用【方法】时，按照从子类(运行类型)开始查找方法 //，然后调用，规则我前面我们讲的方法调用规则一致。 animal.eat();//猫吃鱼.. animal.run();//跑 animal.show();//hello,你好 animal.sleep();//睡 //老师希望，可以调用Cat的 catchMouse方法 //多态的向下转型 //(1)语法：子类类型 引用名 =（子类类型）父类引用; //cat 的编译类型 Cat,运行类型是 Cat Cat cat = (Cat) animal;//之前的 animal 本来就是指向 Cat，所以可以向下转型 cat.catchMouse();//猫抓老鼠 //(2)要求父类的引用必须指向的是当前目标类型的对象 Dog dog = (Dog) animal; //不可以 System.out.println(&quot;ok~~&quot;); &#125;&#125; 3、instanceof 判断对象的【运行类型】是否为 XX 类型或其子类 123456789101112131415161718192021222324package com.hspedu.poly_.detail_;public class PolyDetail03 &#123; public static void main(String[] args) &#123; BB bb = new BB(); System.out.println(bb instanceof BB);// true System.out.println(bb instanceof AA);// true //aa 编译类型 AA, 运行类型是BB //BB是AA子类 AA aa = new BB(); System.out.println(aa instanceof AA); System.out.println(aa instanceof BB); Object obj = new Object(); System.out.println(obj instanceof AA);//false String str = &quot;hello&quot;; //System.out.println(str instanceof AA); System.out.println(str instanceof Object);//true &#125;&#125;class AA &#123;&#125; //父类class BB extends AA &#123;&#125;//子类 4、练习 5、动态绑定机制 1234567891011121314151617181920212223242526272829303132333435363738394041424344package com.hspedu.poly_.dynamic_;public class DynamicBinding &#123; public static void main(String[] args) &#123; //a 的编译类型 A, 运行类型 B A a = new B();//向上转型 System.out.println(a.sum());//?40 -&gt; 30(把 B的 sum（）注释) System.out.println(a.sum1());//?30-&gt; 20（把 B 的 sum1（）注释） &#125;&#125;class A &#123;//父类 public int i = 10; //动态绑定机制: public int sum() &#123;//父类sum() return getI() + 10;//20 + 10 &#125; public int sum1() &#123;//父类sum1() return i + 10;//10 + 10 &#125; public int getI() &#123;//父类getI return i; &#125;&#125;class B extends A &#123;//子类 public int i = 20;// public int sum() &#123;// return i + 20;// &#125; public int getI() &#123;//子类getI() return i; &#125;// public int sum1() &#123;// return i + 10;// &#125;&#125; 多态数组 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128package com.hspedu.poly_.polyarr_;public class Person &#123;//父类 private String name; private int age; public Person(String name, int age) &#123; this.name = name; this.age = age; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public String say() &#123;//返回名字和年龄 return name + &quot;\\t&quot; + age; &#125;&#125;-------------------- package com.hspedu.poly_.polyarr_;public class Student extends Person &#123; private double score; public Student(String name, int age, double score) &#123; super(name, age); this.score = score; &#125; public double getScore() &#123; return score; &#125; public void setScore(double score) &#123; this.score = score; &#125; //重写父类say @Override public String say() &#123; return &quot;学生 &quot; + super.say() + &quot; score=&quot; + score; &#125; //特有的方法 public void study() &#123; System.out.println(&quot;学生 &quot; + getName() + &quot; 正在学java...&quot;); &#125;&#125;------------------- package com.hspedu.poly_.polyarr_;public class Teacher extends Person &#123; private double salary; public Teacher(String name, int age, double salary) &#123; super(name, age); this.salary = salary; &#125; public double getSalary() &#123; return salary; &#125; public void setSalary(double salary) &#123; this.salary = salary; &#125; //写重写父类的say方法 @Override public String say() &#123; return &quot;老师 &quot; + super.say() + &quot; salary=&quot; + salary; &#125; //特有方法 public void teach() &#123; System.out.println(&quot;老师 &quot; + getName() + &quot; 正在讲java课程...&quot;); &#125;&#125;------------- package com.hspedu.poly_.polyarr_;public class PloyArray &#123; public static void main(String[] args) &#123; //应用实例:现有一个继承结构如下：要求创建1个Person对象、 // 2个Student 对象和2个Teacher对象, 统一放在数组中，并调用每个对象say方法 Person[] persons = new Person[5]; persons[0] = new Person(&quot;jack&quot;, 20); persons[1] = new Student(&quot;mary&quot;, 18, 100); persons[2] = new Student(&quot;smith&quot;, 19, 30.1); persons[3] = new Teacher(&quot;scott&quot;, 30, 20000); persons[4] = new Teacher(&quot;king&quot;, 50, 25000); //循环遍历多态数组，调用say for (int i = 0; i &lt; persons.length; i++) &#123; //老师提示: person[i] 编译类型是 Person ,运行类型是是根据实际情况有JVM来判断 System.out.println(persons[i].say());//动态绑定机制 //这里大家聪明. 使用 类型判断 + 向下转型. if(persons[i] instanceof Student) &#123;//判断person[i] 的运行类型是不是Student Student student = (Student)persons[i];//向下转型 student.study(); //小伙伴也可以使用一条语句 ((Student)persons[i]).study(); &#125; else if(persons[i] instanceof Teacher) &#123; Teacher teacher = (Teacher)persons[i]; teacher.teach(); &#125; else if(persons[i] instanceof Person)&#123; //System.out.println(&quot;你的类型有误, 请自己检查...&quot;); &#125; else &#123; System.out.println(&quot;你的类型有误, 请自己检查...&quot;); &#125; &#125; &#125;&#125; 多态参数 形参父类，实参可以是子类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108package com.hspedu.poly_.polyparameter_;public class Employee &#123; private String name; private double salary; public Employee(String name, double salary) &#123; this.name = name; this.salary = salary; &#125; //得到年工资的方法 public double getAnnual() &#123; return 12 * salary; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public double getSalary() &#123; return salary; &#125; public void setSalary(double salary) &#123; this.salary = salary; &#125;&#125;---------------------- package com.hspedu.poly_.polyparameter_;public class Manager extends Employee&#123; private double bonus; public Manager(String name, double salary, double bonus) &#123; super(name, salary); this.bonus = bonus; &#125; public double getBonus() &#123; return bonus; &#125; public void setBonus(double bonus) &#123; this.bonus = bonus; &#125; public void manage() &#123; System.out.println(&quot;经理 &quot; + getName() + &quot; is managing&quot;); &#125; //重写获取年薪方法 @Override public double getAnnual() &#123; return super.getAnnual() + bonus; &#125;&#125;-------------------- package com.hspedu.poly_.polyparameter_;public class Worker extends Employee &#123; public Worker(String name, double salary) &#123; super(name, salary); &#125; public void work() &#123; System.out.println(&quot;普通员工 &quot; + getName() + &quot; is working&quot;); &#125; @Override public double getAnnual() &#123; //因为普通员工没有其它收入，则直接调用父类方法 return super.getAnnual(); &#125;&#125;----------------------- package com.hspedu.poly_.polyparameter_;public class PloyParameter &#123; public static void main(String[] args) &#123; Worker tom = new Worker(&quot;tom&quot;, 2500); Manager milan = new Manager(&quot;milan&quot;, 5000, 200000); PloyParameter ployParameter = new PloyParameter(); ployParameter.showEmpAnnual(tom); ployParameter.showEmpAnnual(milan); ployParameter.testWork(tom); ployParameter.testWork(milan); &#125; //showEmpAnnual(Employee e) //实现获取任何员工对象的年工资,并在main方法中调用该方法 [e.getAnnual()] public void showEmpAnnual(Employee e) &#123; System.out.println(e.getAnnual());//动态绑定机制. &#125; //添加一个方法，testWork,如果是普通员工，则调用work方法，如果是经理，则调用manage方法 public void testWork(Employee e) &#123; if(e instanceof Worker) &#123; ((Worker) e).work();//有向下转型操作 &#125; else if(e instanceof Manager) &#123; ((Manager) e).manage();//有向下转型操作 &#125; else &#123; System.out.println(&quot;不做处理...&quot;); &#125; &#125;&#125; 当一个方法是 static 时，可以直接通过类名调用 匿名对象：new Person().show() 继承 123456789101112131415public class test &#123; public static void main(String[] args) &#123; person stu = new student(); student.show(); //注意这里虽然是父类里面的方法的 this，但是 this 其实还是 stu 的，因为只有一个 this。 &#125;&#125;class person&#123; public void show()&#123; System.out.println(this.getClass()); &#125;&#125; class student extends person&#123;&#125; 集合 Java集合大致可以分为两大体系，一个是Collection，另一个是Map Collection ：主要由List、Set、Queue接口组成 List代表有序、重复的集合； ArrayList ArrayList是一个动态数组结构，支持随机存取，尾部插入删除方便，内部插入删除效率低（因为要移动数组元素）；如果内部数组容量不足则自动扩容，因此当数组很大时，效率较低。 1List&lt;String&gt; list = new ArrayList&lt;&gt;(); LinkedList LinkedList是一个双向链表结构，在任意位置插入删除都很方便，但是不支持随机取值，每次都只能从一端开始遍历，直到找到查询的对象，然后返回；不过，它不像 ArrayList 那样需要进行内存拷贝，因此相对来说效率较高，但是因为存在额外的前驱和后继节点指针，因此占用的内存比 ArrayList 多一些。 Vector Set代表无序、不可重复的集合； HashSet： HashSet类按照哈希算法来存取集合中的对象，存取速度比较快 TreeSet ：TreeSet类实现了SortedSet接口，能够对集合中的对象进行排序 Queue代表一种队列集合实现。 Map：则代表具有映射关系的键值对集合。 HashMap 重复放入key-value并不会有任何问题，但是一个key只能关联一个value。新加入的会覆盖掉原来的。也就是说 key不能重复，但是 value 可以重复。 无序 123456789101112public class Main &#123; public static void main(String[] args) &#123; Student s = new Student(&quot;Xiao Ming&quot;, 99); Map&lt;String, Student&gt; map = new HashMap&lt;&gt;(); map.put(&quot;Xiao Ming&quot;, s); // 将&quot;Xiao Ming&quot;和Student实例映射并关联 Student target = map.get(&quot;Xiao Ming&quot;); // 通过key查找并返回映射的Student实例 System.out.println(target == s); // true，同一个实例 System.out.println(target.score); // 99 Student another = map.get(&quot;Bob&quot;); // 通过另一个key查找 System.out.println(another); // 未找到返回null &#125;&#125; 泛型 E 具体的数据类型在定义 Person 对象的时候指定,即在编译期间，就确定 E 是什么类型 Tiger 后面泛型，所以我们把 Tiger 就称为自定义泛型类 T, R, M 泛型的标识符, 一般是单个大写字母 泛型标识符可以有多个. 普通成员可以使用泛型 (属性、方法) 使用泛型的数组，不能初始化 (new) 因为数组在 new 不能确定 T 的类型，就无法在内存开空间 静态方法中不能使用类的泛型 因为静态是和类相关的，在类加载时，对象还没有创建 所以，如果静态方法和静态属性使用了泛型，JVM 就无法完成初始化 所以如果static方法要使用泛型能力，就必须使其成为泛型方法。 无论何时，如果你能做到，你就该尽量使用泛型方法。也就是说，如果使用泛型方法将整个类泛型化， 那么就应该使用泛型方法。另外对于一个static的方法而已，无法访问泛型类型的参数。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475public class GenericTest &#123; //这个类是个泛型类，在上面已经介绍过 public class Generic&lt;T&gt;&#123; private T key; public Generic(T key) &#123; this.key = key; &#125; //我想说的其实是这个，虽然在方法中使用了泛型，但是这并不是一个泛型方法。 //这只是类中一个普通的成员方法，只不过他的返回值是在声明泛型类已经声明过的泛型。 //所以在这个方法中才可以继续使用 T 这个泛型。 public T getKey()&#123; return key; &#125; /** * 这个方法显然是有问题的，在编译器会给我们提示这样的错误信息&quot;cannot reslove symbol E&quot; * 因为在类的声明中并未声明泛型E，所以在使用E做形参和返回值类型时，编译器会无法识别。 public E setKey(E key)&#123; this.key = keu &#125; */ &#125; /** * 这才是一个真正的泛型方法。 * 首先在public与返回值之间的&lt;T&gt;必不可少，这表明这是一个泛型方法，并且声明了一个泛型T * T 表示的是返回值类型 * 这个T可以出现在这个泛型方法的任意位置. * 泛型的数量也可以为任意多个 * 如：public &lt;T,K&gt; K showKeyName(Generic&lt;T&gt; container)&#123; * ... * &#125; */ public &lt;T&gt; T showKeyName(Generic&lt;T&gt; container)&#123; System.out.println(&quot;container key :&quot; + container.getKey()); //当然这个例子举的不太合适，只是为了说明泛型方法的特性。 T test = container.getKey(); return test; &#125; //这也不是一个泛型方法，这就是一个普通的方法，只是使用了Generic&lt;Number&gt;这个泛型类做形参而已。 public void showKeyValue1(Generic&lt;Number&gt; obj)&#123; Log.d(&quot;泛型测试&quot;,&quot;key value is &quot; + obj.getKey()); &#125; //这也不是一个泛型方法，这也是一个普通的方法，只不过使用了泛型通配符? //同时这也印证了泛型通配符章节所描述的，?是一种类型实参，可以看做为Number等所有类的父类 public void showKeyValue2(Generic&lt;?&gt; obj)&#123; Log.d(&quot;泛型测试&quot;,&quot;key value is &quot; + obj.getKey()); &#125; /** * 这个方法是有问题的，编译器会为我们提示错误信息：&quot;UnKnown class &#x27;E&#x27; &quot; * 虽然我们声明了&lt;T&gt;,也表明了这是一个可以处理泛型的类型的泛型方法。 * 但是只声明了泛型类型T，并未声明泛型类型E，因此编译器并不知道该如何处理E这个类型。 public &lt;T&gt; T showKeyName(Generic&lt;E&gt; container)&#123; ... &#125; */ /** * 这个方法也是有问题的，编译器会为我们提示错误信息：&quot;UnKnown class &#x27;T&#x27; &quot; * 对于编译器来说T这个类型并未项目中声明过，因此编译也不知道该如何编译这个类。 * 所以这也不是一个正确的泛型方法声明。 public void showkey(T genericObj)&#123; &#125; */ public static void main(String[] args) &#123; &#125;&#125; 反射 12345678910111213141516171819202122232425public class ReflectionQuestion &#123; public static void main(String[] args) throws IOException, ClassNotFoundException, IllegalAccessException, InstantiationException, NoSuchMethodException, InvocationTargetException, NoSuchFieldException &#123;//1. 使用 Properties 类, 可以读写配置文件 Properties properties = new Properties(); properties.load(new FileInputStream(&quot;src\\\\re.properties&quot;)); //得到类名 String classfullpath = properties.get(&quot;classfullpath&quot;).toString();//&quot;com.hspedu.Cat&quot; //得到方法 String methodName = properties.get(&quot;method&quot;).toString();//&quot;hi&quot; System.out.println(&quot;classfullpath=&quot; + classfullpath); System.out.println(&quot;method=&quot; + methodName); //(1) 加载类, 返回 Class 类型的对象 cls Class cls = Class.forName(classfullpath); //(2) 通过 cls 得到你加载的类 com.hspedu.Cat 的对象实例 Object o = cls.newInstance(); System.out.println(&quot;o 的运行类型=&quot; + o.getClass()); //运行类型 //(3) 通过 cls 得到你加载的类 com.hspedu.Cat 的 methodName&quot;hi&quot; 的方法对象 // 即：在反射中，可以把方法视为对象（万物皆对象） Method method1 = cls.getMethod(methodName); //(4) 通过 method1 调用方法: 即通过方法对象来实现调用方法 System.out.println(&quot;=============================&quot;); method1.invoke(o); //传统方法 对象.方法() , 反射机制 方法.invoke(对象)&#125; 多线程使用 vector 安全 线程什么时候生成和退出 静态方法重写 父类的静态方法不能被重写（overide），可以被重载。 在编译时所分配的内存会一直存在（不会被回收），直到程序退出内存才会释放这个空间，在实例化之前这个方法就已经存在于内存，跟类的对象没什么关系。子类中如果定义了相同名称的静态方法，并不会重写，而应该是在内存中又分配了一块给子类的静态方法，没有重写这一说，只是单纯的名字重复了。 12345678910111213141516171819202122public class Fu &#123; public static void show() &#123; System.out.println(&quot;父类的静态方法&quot;); &#125; public void method() &#123; System.out.println(&quot;父类的一般方法&quot;); &#125; &#125;public class Zi extends Fu &#123; public static void main(String[] args) &#123; Fu fu = new Zi(); fu.show(); fu.method(); &#125; public static void show() &#123; System.out.println(&quot;子类的静态&quot;); &#125; public void method() &#123; System.out.println(&quot;子类的一般方法&quot;); &#125;&#125; 输出结果： 父类的静态方法 子类的一般方法 ArrayList 的 contains() 方法 12345678910111213141516171819202122232425public boolean contains(Object o) &#123; return indexOf(o) &gt;= 0;&#125;public int indexOf(Object o) &#123; return indexOfRange(o, 0, size);&#125;int indexOfRange(Object o, int start, int end) &#123; Object[] es = elementData; if (o == null) &#123; for (int i = start; i &lt; end; i++) &#123; if (es[i] == null) &#123; return i; &#125; &#125; &#125; else &#123; for (int i = start; i &lt; end; i++) &#123; if (o.equals(es[i])) &#123; //注意有没有重写 equals() return i; &#125; &#125; &#125; return -1;&#125; 法语 Modèle de gestion de la mémoire en Java Mode de passage des parametre aux fonctions passage par valeur passage par reference/addresse Passage de parametre de type simple ou primitif Copie 1. Théorie 2. Copie Superfificielle 3. Copie profonde","categories":[{"name":"COURS","slug":"COURS","permalink":"http://littlewuuu.com/categories/COURS/"}],"tags":[{"name":"ECN","slug":"ECN","permalink":"http://littlewuuu.com/tags/ECN/"}]},{"title":"新闻啥的","slug":"Francaise/新闻啥的","date":"2022-08-19T22:00:00.000Z","updated":"2022-08-27T12:17:24.175Z","comments":true,"path":"2022/08/20/Francaise/新闻啥的/","link":"","permalink":"http://littlewuuu.com/2022/08/20/Francaise/%E6%96%B0%E9%97%BB%E5%95%A5%E7%9A%84/","excerpt":"","text":"08-15 manœuvres militaires 军事演习 alors que 当，然而 délégation 代表团 Patlementaire 议员，议会 ouvertement dénoncée par Pékin communiqué 公报 commandement 统帅 patrouille 巡逻 combat 战斗 interarmées 陆、海、空三军的 l’espace aérien 领空 détroit 海峡 démarcation 分界线 amitié 友谊 effrayer 使恐惧 revendiquer 追还 survenir 突如其来 blocus 封锁 engagement 承诺 invasion 入侵 08-16 Elle sera chargée de mettre en place…… ces sept derniers jours On aura à tirer des leçons de ce qui s’est passé 单词 意思 Incendie 火灾 Fiscal,e 国库 sinistre 灾祸 sinistré 受灾的，灾民 cellule 单人间，细胞 suspension 吊起，暂停 pâtir de 吃……的苦 En lien avec 有关 amortisseur 缓冲器 subir 忍受，接受 ravager 摧毁 durablement touchés 持久影响 arriver à échéanceéchéance 满期 到期 report 延期 pouce 拇指 stade 阶段 feux 火 prévention 预防措施 anticipation 提前 payer par anticipation 提前付款 chiffrage 用数字估算 08-17 Si « la situation s’avère plus difficile que d’habitude » pour cette rentrée scolaire du fait d’une pénurie d’enseignants mais les besoins le sont tout autant valoriser 增值 le métier d’enseignant 教师职业 la grille salariale 工资单 ainsi que 以及 s’avérer 被证实 pénurie 匮乏 aveu 承认 ministre délégué 部长助理 contraint,e 受拘束的 les écoles primaires 小学 perplexité 困惑 de la manière 以……的方法 donne 分牌，局面 précédent 先前的 quinquennat 五年任职期 asséner 猛烈地给予（打击） porte-parole 发言人 discours 讲话演说 discours séducteur 吸引人的演讲 habitué,e 习惯于……的 prudent, e 谨慎的 carrière 职业生涯 le plat de résistance 主菜 déceptions 失望 08-18 parce qu’elle fait face à ce chapelet d’îles qui sont des pays avec lesquels elle entretient des relations relativement hostiles conquérir 征服 menace 威胁 autoritaire 专制的 démanteler 拆除 survive à 从……脱险 nier 否认 légitimité 合法性 la République de Chine 中华民国 la République populaire de Chine 中华人民共和国 ingérence 干涉 admettre 接受，承认 revendiquer 追还 souveraineté 主权 unification 统一 impérial 帝国的 annexer 附加，吞并 Défaire 拆除 n’a plus grand-chose à voir 没有什么联系 lors de 在……期间 méridionale 南方的 contrarier 阻碍 hégémonique 霸权主义的 ambitions hégémonique confiner à 接壤 confiner dans 囚禁在 d’une certaine manière 某种程度上 en quelque sorte 某种程度上 relativement 相对的 vital 极其重要的，维持生命必须的 affaiblir 使虚弱 entre autres 尤其是 verrou 门栓 tactique 战术 déni 否认 en mesure 能 en tant que 由于 garant,e 保证的，担保人 éventuelle 可能的 prolifération 迅速繁殖 compter sur 指望 traité 条款 portée 荷载 composante 成分 sous-marins lanceurs d’engins 潜艇发射器 engin 导弹 repérer 定位发现 pister 追查 méridionale 南面的 peu profonde 浅的 trois quarts 四分之三 balistiques 导弹 missile balistique 弹道导弹 sol-sol 地对地 sous-marin 潜水艇 par nature 天性 maritime 沿海的 porter sur 专注于 souveraine 有主权的 importation 进口 inhabité 无人居住的 raviver 使复苏 dispute 争吵 préoccuper 缠住 使担心 convoiter 觊觎 régime de Pékin gain 收益，获胜 indéniable 不可否认的 aisément 轻松的 interrompre 中断 déstabilisation 失稳 hégémonique 霸权的 faire contrepoids à …作为…的平衡力量, 与…抗衡 rivalité 竞争 08-25 approvisionnement 供应 corrosion 腐蚀 flambée 旺火 inédite 新颖的，从未见过的 tendre 拉紧 intermédiaire 中间人，中间的 fourchette 范围，餐叉 soupçonner 怀疑 soudure 连接，焊接 coude 肘关节 circuit 环形线路 sûreté 安全可靠 ultrason 超声波 délestage 切除负载 rattraper 追上 la période de confinement 禁闭期 sans précédent 空前的 08-26Oh je vais regarder un film tiens 你的电影 festivalier 联欢节的参与者 se changer les idées 换换脑子 époustouflant 惊奇的 splendide 辉煌的 magistrale 杰出的 cours magistrale 由老师讲授的课 [与学生参与的实践课相对] usant 损害健康的 nostalgique 思乡的 cinéphile 电影爱好者 hôtesse 女主人 arrondissement 大区 périple 航行，游历 aérer 通风 classique 经典 tituber 蹒跚 allant aller 的现在分词 ivre 喝醉的 sous le signe de 在……的影响下","categories":[{"name":"le français","slug":"le-francais","permalink":"http://littlewuuu.com/categories/le-francais/"}],"tags":[{"name":"le français","slug":"le-francais","permalink":"http://littlewuuu.com/tags/le-francais/"}]},{"title":"HTML & CSS & JavaScript","slug":"HTML+CSS/HTML+CSS","date":"2022-02-26T23:00:00.000Z","updated":"2022-11-14T08:35:41.902Z","comments":true,"path":"2022/02/27/HTML+CSS/HTML+CSS/","link":"","permalink":"http://littlewuuu.com/2022/02/27/HTML+CSS/HTML+CSS/","excerpt":"","text":"Tomcat Tomcat 安装使用 12./startup.sh./shutdown.sh 浏览器地址栏输入：localhost:8080，验证是否成功启动 tomcat 版本：apache-tomcat-8.5.83 目录结构说明： bin 可执行文件目录 conf 配置文件目录 lib 存放lib的目录 logs 日志文件目录 webapps 项目部署的目录 work 工作目录 temp 临时目录 例子：http://localhost:8080/baidu/demo09.html IDEA 配置 Tomcat","categories":[{"name":"SKILLS","slug":"SKILLS","permalink":"http://littlewuuu.com/categories/SKILLS/"}],"tags":[{"name":"学了又忘的杂七杂八","slug":"学了又忘的杂七杂八","permalink":"http://littlewuuu.com/tags/%E5%AD%A6%E4%BA%86%E5%8F%88%E5%BF%98%E7%9A%84%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/"}]},{"title":"算法框架","slug":"算法框架/算法基本格式","date":"2022-02-10T23:00:00.000Z","updated":"2022-02-27T12:00:48.404Z","comments":true,"path":"2022/02/11/算法框架/算法基本格式/","link":"","permalink":"http://littlewuuu.com/2022/02/11/%E7%AE%97%E6%B3%95%E6%A1%86%E6%9E%B6/%E7%AE%97%E6%B3%95%E5%9F%BA%E6%9C%AC%E6%A0%BC%E5%BC%8F/","excerpt":"","text":"算法基本格式数组基本方法 二分法 双指针 滑动窗口，和双指针类似，通过窗口大小的变换来解题 哈希表关于哈希表的一些事情常见的哈希表结构 数组 set（unordered_set） map（unordered_map） 适用题型 当我们遇到了要快速判断一个元素是否出现集合里的时候，就要考虑哈希法。 但是哈希法也是牺牲了空间换取了时间，因为我们要使用额外的数组，set或者是map来存放数据，才能实现快速的查找。 字符串KMP 算法 在一个串里查找是否出现过另外一个串 1. next 数组 next 数组就是一个前缀表 前缀表是用来回退的，它记录了模式串与主串(文本串)不匹配的时候，模式串应该从哪里开始重新匹配。 next数组就可以是前缀表，但是很多实现都是把前缀表统一减一（右移一位，初始位置为-1）之后作为next数组。 求前缀表： 队列与栈栈 栈是以底层容器完成其所有的工作，对外提供统一的接口，底层容器是可插拔的（也就是说我们可以控制使用哪种容器来实现栈的功能）。 所以STL中栈和队列往往不被归类为容器，而被归类为container adapter（容器适配器）。 队列中先进先出的数据结构，栈先进后出的数据结构，不允许有遍历行为，不提供迭代器 从下图中可以看出，栈的内部结构，栈的底层实现可以是vector，deque，list 都是可以的， 主要就是数组和链表的底层实现。 12默认使用deque 实现栈的底层结构std::stack&lt;int, std::vector&lt;int&gt; &gt; third; // 指定使用vector为底层容器的栈 队列实现栈输出栈顶元素的时候只需要不断把队列的头取出来重新添加到队列中（除了最后一个元素），然后从队列中取出来的就是栈的顺序（注意队列取出只能按照先进先出） 栈实现队列两个栈，一个输入栈，一个输出栈，输出的时候如果输出栈有元素则输出，没有则把输入栈里所有元素弹出添加到输出栈里面 括号匹配问题使用栈解决的经典问题，栈适合做对称匹配类的问题 有三种情况： 括号匹配完成了但是栈里还剩有元素，说明括号对应个数不一样。 栈已经空了，但是表达式还没有匹配完。 栈里和表达式的匹配不上。 stack.empty() returns 1 if stack is empty, return 0 if is not empty. 1234567891011121314151617class Solution &#123;public: bool isValid(string s) &#123; stack&lt;int&gt; st; for (int i = 0; i &lt; s.size(); i++) &#123; if (s[i] == &#x27;(&#x27;) st.push(&#x27;)&#x27;); else if (s[i] == &#x27;&#123;&#x27;) st.push(&#x27;&#125;&#x27;); else if (s[i] == &#x27;[&#x27;) st.push(&#x27;]&#x27;); // 第三种情况：遍历字符串匹配的过程中，栈已经为空了，没有匹配的字符了，说明右括号没有找到对应的左括号 return false // 第二种情况：遍历字符串匹配的过程中，发现栈里没有我们要匹配的字符。所以return false。即字符串还没有匹配完栈已经空了 else if (st.empty() || st.top() != s[i]) return false; else st.pop(); // st.top() 与 s[i]相等，栈弹出元素 &#125; // 第一种情况：此时我们已经遍历完了字符串，但是栈不为空，说明有相应的左括号没有右括号来匹配，所以return false，否则就return true return st.empty(); &#125;&#125;; 逆波兰式求值 逆波兰式是一个后缀表达式 123456789101112131415161718192021222324class Solution &#123;public: int evalRPN(vector&lt;string&gt;&amp; tokens) &#123; stack&lt;int&gt; st; for (int i = 0; i &lt; tokens.size(); i++) &#123; //如果碰到运算符，就取出栈中的两个元素进行运算然后再把结果压入栈里 if (tokens[i] == &quot;+&quot; || tokens[i] == &quot;-&quot; || tokens[i] == &quot;*&quot; || tokens[i] == &quot;/&quot;) &#123; int num1 = st.top(); st.pop(); int num2 = st.top(); st.pop(); if (tokens[i] == &quot;+&quot;) st.push(num2 + num1); if (tokens[i] == &quot;-&quot;) st.push(num2 - num1); if (tokens[i] == &quot;*&quot;) st.push(num2 * num1); if (tokens[i] == &quot;/&quot;) st.push(num2 / num1); &#125; else &#123;//碰到元素直接入栈 st.push(stoi(tokens[i])); &#125; &#125; int result = st.top(); st.pop(); // 把栈里最后一个元素弹出（其实不弹出也没事） return result; &#125;&#125;; 单调队列 给定一个数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。 返回滑动窗口中的最大值。 1234567891011121314151617181920212223242526272829303132333435363738394041class Solution &#123;private: class MyQueue &#123; //单调队列（从大到小） public: deque&lt;int&gt; que; // 使用deque来实现单调队列 // 每次弹出的时候，比较当前要弹出的数值是否等于队列出口元素的数值，如果相等则弹出。 // 同时pop之前判断队列当前是否为空。 void pop(int value) &#123; if (!que.empty() &amp;&amp; value == que.front()) &#123; que.pop_front(); &#125; &#125; // 如果push的数值大于入口元素的数值，那么就将队列后端的数值弹出，直到push的数值小于等于队列入口元素的数值为止。 // 这样就保持了队列里的数值是单调从大到小的了。 void push(int value) &#123; while (!que.empty() &amp;&amp; value &gt; que.back()) &#123; que.pop_back(); &#125; que.push_back(value); &#125; // 查询当前队列里的最大值 直接返回队列前端也就是front就可以了。 int front() &#123; return que.front(); &#125; &#125;;public: vector&lt;int&gt; maxSlidingWindow(vector&lt;int&gt;&amp; nums, int k) &#123; MyQueue que; vector&lt;int&gt; result; for (int i = 0; i &lt; k; i++) &#123; // 先将前k的元素放进队列 que.push(nums[i]);//push()时就确保队列是单调的了 &#125; result.push_back(que.front()); // result 记录前k的元素的最大值 for (int i = k; i &lt; nums.size(); i++) &#123; que.pop(nums[i - k]); // 滑动窗口移除最前面元素 que.push(nums[i]); // 滑动窗口前加入最后面的元素 result.push_back(que.front()); // 记录对应的最大值 &#125; return result; &#125;&#125;; 前 k 个高频元素 给定一个非空的整数数组，返回其中出现频率前 k 高的元素。 三步： 统计出现频率（用 map），一般统计频率的都用 map key存储元素，value 存储元素的出现次数 排序，使用 priority_queue 取出前 k 个，就要在使用优先队列排序的时候控制队列的大小为 k，如果大于 k，就弹出元素，最后把队列中的所有元素输出即可。 我的想法哈希表（和 map 一个道理） 123456vector&lt;int&gt; nums;//给的数组results[];//结果for(int i = 0; i &lt; nums.size(); i++)&#123; nums[i]++; //nums[i]就是 i 出现的次数&#125; 使用 map，priority_queue，堆（heap） 堆是完全二叉树，大根堆就是根节点的数值大于左右结点 优先队列，堆排序，快速找到一个集合中的最值 堆顶元素总是最值，但是另一个最值不确定在哪里 数组存储堆 一般都用数组来表示存储堆，i结点的父结点下标就为(i–1)/2。它的左右子结点下标分别为2 i + 1和2 i + 2。如第0个结点左右子结点下标分别为1和2。一个结点（i）的根节点就是 i/2（整除） 堆的操作 插入：新元素被加入到heap的末尾，然后更新树以恢复堆的次序。 删除：按定义，堆中每次都删除第0个数据。为了便于重建堆，实际的操作是将最后一个数据的值赋给根结点，然后再从根结点开始进行一次从上向下的调整。 堆排序 堆建好之后堆中第0个数据是堆中最大的数据。取出这个数据再执行下堆的删除操作。这样堆中第0个数据又是堆中最大的数据，重复上述步骤直至堆中只有一个数据时就直接取出这个数据。 ​ 树🌲框架 树的基本概念 定义 是一种递归的数据结构 一个结点的孩子数为该节点的度，结点的最大度数为树的度 度为 0 的结点为叶子结点 高度和深度 高度是针对整棵树来说的，是深度的最大值（根节点深度为 1） 深度就是从根结点向下走，高度从下往上走 有序树和无序树 有序树的结点的左右子树有顺序不能换 路径和长度 树中两个结点之间的路径是这两个结点之间经过的结点序列构成的，路径长度是路径上边的个数 路径是从父节点到子节点，有方向的。所以同一结点的两个孩子之间没有路径 性质 二叉树二叉树基本概念 是有序树，左右结点不能互换 二叉树与度为 2 的有序树的区别 二叉树可以是空树，有序树至少有三个结点 如果一个二叉树结点只有左子树，那么还是要区分左右，右子树为空树 特殊二叉树 满二叉树 完全二叉树 二叉排序树 左子树上所有结点的关键字都小于根节点的关键字 右子树上所有结点的关键字都大于根节点的关键字 平衡二叉树 任意结点的左子树和右子树的深度之差 &lt; = 1 二叉树的性质 n_0 = n_2 +1 第 k 层至多结点数 2^{k-1} 高度为 h 的二叉树至多节点数 2^h-1(h>=1) 二叉树的存储结构 顺序存储 链式存储 二叉树遍历 递归写法： 确定递归函数的参数和返回值 确定终止条件 确定单层递归的逻辑 先序 12345678910void PreOrder(BiTree T, vector&lt;T&gt;&amp; result)&#123; //result for recording the order if(T != NULL) &#123; visit(T); PreOrder(T-&gt;LeftChild); PreOrder(T-&gt;RightChild); &#125;&#125;//时间复杂度O(n)//空间复杂度O(n) 中序 12345678void PreOrder(BiTree T)&#123; if(T != NULL) &#123; PreOrder(T-&gt;LeftChild); visit(T); PreOrder(T-&gt;RightChild); &#125;&#125; 后序 12345678void PreOrder(BiTree T)&#123; if(T != NULL) &#123; PreOrder(T-&gt;LeftChild); PreOrder(T-&gt;RightChild); visit(T); &#125;&#125; 递归算法和非递归算法的转换（栈） 12345678910111213141516171819//中序遍历的非递归实现void InOrder(BiTree)&#123; InitStack(s); //初始化栈 BiTree p = T; //p 是遍历指针 while(p||!isEmpty(s)) &#123; if(p)//遍历左子树 &#123; Push(s,p); p=p-&gt;LeftChild; &#125; else //出栈，并转向出栈结点的右子树 &#123; Pop(s,p);visit(p);//栈顶元素出栈，访问出栈元素 p=p-&gt;RightChild; &#125; &#125;&#125; 层次遍历（队列） 123456789101112131415void LevelOrder(BiTree T)&#123; InitQueue(Q); BiTree p; EnQueue(Q,T); while(!IsEmpty(Q)) &#123; DeQueue(Q,p); visit(p); if(p-&gt;leftchild != NULL) EnQueue(Q,p-&gt;leftchild); if(p-&gt;leftchild != NULL) EnQueue(Q,p-&gt;rightchild) &#125;&#125; 翻转二叉树可以用递归方式，先序后序都可以用 12345678void inverse(BiTree T)&#123; if(T == NULL) return; swap(T-&gt;left,T-&gt;right); inverse(T-&gt;left); inverse(T-&gt;right);&#125; 判断二叉树是否左右镜像递归三部曲 确定递归参数和返回值 1bool compare(TreeNode* left, TreeNode* right) 确定终止条件 1234if (left == NULL &amp;&amp; right != NULL) return false;else if (left != NULL &amp;&amp; right == NULL) return false;else if (left == NULL &amp;&amp; right == NULL) return true;else if (left-&gt;val != right-&gt;val) return false; // 注意这里我没有使用else 确定单层递归逻辑 1234bool outside = compare(left-&gt;left, right-&gt;right); // 左子树：左、 右子树：右bool inside = compare(left-&gt;right, right-&gt;left); // 左子树：右、 右子树：左bool isSame = outside &amp;&amp; inside; // 左子树：中、 右子树：中（逻辑处理）return isSame; 二叉树最大深度 递归法 确定参数和返回值 1int getdepth(treenode *node) 确定终止条件 1if(node == NULL) return 0; 确定单层递归逻辑 12345678class solution &#123;public: int maxdepth(treenode* root) &#123; if (root == null) return 0; return 1 + max(maxdepth(root-&gt;left), maxdepth(root-&gt;right)); &#125;&#125;; 层序遍历 1234567891011121314151617181920class solution &#123;public: int maxdepth(treenode* root) &#123; if (root == NULL) return 0; int depth = 0; queue&lt;treenode*&gt; que; que.push(root); while(!que.empty()) &#123; int size = que.size(); depth++; // 记录深度 for (int i = 0; i &lt; size; i++) &#123; treenode* node = que.front(); que.pop(); if (node-&gt;left) que.push(node-&gt;left); if (node-&gt;right) que.push(node-&gt;right); &#125; &#125; return depth; &#125;&#125;; 线索二叉树 遍历二叉树就是逸一定的规则将二叉树中的结点排成一个线性序列，该序列中每个节点（除了开始和结束）都有一个直接前驱和直接后继 引入线索二叉树是为了加快查找结点的前驱和后继的速度 结构12345typedef struct ThreadNode&#123; ElemType data; struct ThreadNode *lchild, *rchild; int ltag,rtag;//判断左右子树指针指向左右子树还是前后驱结点&#125;TreadNode; 中序线索二叉树的构造 将二叉链表的空指针改为指向前驱后驱的线索，而前后驱结点的消息只有在遍历的时候能得到，所以线索化的实质是遍历一次二叉树 123456789101112131415161718192021222324252627282930void CreateInTread(TreadNode T)&#123; TreadTree pre = NULL; if(T!=NULL)//非空二叉树，线索化 &#123; Intread(T,pre);//线索化 pre-&gt;rchild = NULL;//处理遍历最后一个结点 pre-&gt;rtag = 1; &#125;&#125;void Intread(TreadTree &amp;p,ThreadTree &amp;pre)&#123; if(p!=NULL) &#123; Intread(p-&gt;lchild,pre);//线索化左子树 if(p-&gt;lchild == NULL)//左子树为空，建立前驱线索 &#123; p-&gt;lchild = pre; ltag = 1; &#125; if(pre!=NULL &amp;&amp; pre-&gt;rchild == NULL)//建立前驱结点的后继线索 &#123; pre-&gt;rchild = p; pre-&gt;rtag = 1; &#125; pre = p; Intread(p-&gt;rchild,pre);//线索化右子树 &#125;//end of if(p!=NULL)&#125; 回溯法基本题型： 关于回溯的一些事情 因为回溯的本质是穷举，穷举所有可能，然后选出我们想要的答案，如果想让回溯法高效一些，可以加一些剪枝的操作，但也改不了回溯法就是穷举的本质。 所有回溯法的问题都可以抽象为树形结构！因为回溯法解决的都是在集合中递归查找子集，集合的大小就构成了树的宽度，递归的深度，都构成的树的深度。 递归就要有终止条件，所以必然是一棵高度有限的树（N叉树）。 回溯框架 1234567891011void backtracking(参数) &#123; if (终止条件) &#123; 存放结果; return; &#125; for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) &#123; 处理节点; backtracking(路径，选择列表); // 递归 回溯，撤销处理结果 &#125;&#125; N皇后问题123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051class Solution &#123;private:vector&lt;vector&lt;string&gt;&gt; result;//存放结果棋盘们// n 为输入的棋盘大小// row 是当前递归到棋盘的第几行了// 回溯函数void backtracking(int n, int row, vector&lt;string&gt;&amp; chessboard) &#123; if (row == n) &#123; result.push_back(chessboard); return; &#125; for (int col = 0; col &lt; n; col++) &#123;//判断 row 这一行那个位置可以放 if (isValid(row, col, chessboard, n)) &#123; // 验证合法就可以放 chessboard[row][col] = &#x27;Q&#x27;; // 放置皇后 backtracking(n, row + 1, chessboard);//寻找下一行可以放的位置 chessboard[row][col] = &#x27;.&#x27;; // 回溯，撤销皇后 &#125; &#125;&#125;//判断(row,col)这个位置可不可以放bool isValid(int row, int col, vector&lt;string&gt;&amp; chessboard, int n) &#123; int count = 0; // 检查列(i,col) for (int i = 0; i &lt; row; i++) &#123; // 这是一个剪枝 if (chessboard[i][col] == &#x27;Q&#x27;) &#123; return false; &#125; &#125; // 检查 45度角是否有皇后 for (int i = row - 1, j = col - 1; i &gt;=0 &amp;&amp; j &gt;= 0; i--, j--) &#123; if (chessboard[i][j] == &#x27;Q&#x27;) &#123; return false; &#125; &#125; // 检查 135度角是否有皇后 for(int i = row - 1, j = col + 1; i &gt;= 0 &amp;&amp; j &lt; n; i--, j++) &#123; if (chessboard[i][j] == &#x27;Q&#x27;) &#123; return false; &#125; &#125; return true;&#125;public: vector&lt;vector&lt;string&gt;&gt; solveNQueens(int n) &#123; result.clear(); std::vector&lt;std::string&gt; chessboard(n, std::string(n, &#x27;.&#x27;)); backtracking(n, 0, chessboard); return result; &#125;&#125;; 组合问题组合问题 1给定两个整数 n 和 k，返回 1 … n 中所有可能的 k 个数的组合。每个元素只能用一次 1234567891011121314151617181920212223class Solution &#123;private: vector&lt;vector&lt;int&gt;&gt; result;//存放结果 vector&lt;int&gt; path;//保存每次选取结果 void backtracking(int n, int k, int startIndex) &#123; if (path.size() == k) &#123; //已经选取 k 个数了，该次递归结束 result.push_back(path);//存入结果集 return; &#125; for (int i = startIndex; i &lt;= n - (k - path.size()) + 1; i++) &#123; // 优化的地方 //就是说剩下的元素已经小于 K 了，那么无论怎么组合都选取不到 k 个，可以提前结束 //n - (k - path.size()) + 1 就是最后满足条件的坐标 path.push_back(i); // 处理节点 backtracking(n, k, i + 1); path.pop_back(); // 回溯，撤销处理的节点 &#125; &#125;public: vector&lt;vector&lt;int&gt;&gt; combine(int n, int k) &#123; backtracking(n, k, 1); return result; &#125;&#125;; 组合总和 1 给你一个 无重复元素 的整数数组 candidates 和一个目标整数 target ，找出 candidates 中可以使数字和为目标数 target 的 所有 不同组合 ，并以列表形式返回。你可以按 任意顺序 返回这些组合。 candidates 中的 同一个 数字可以 无限制重复被选取 。如果至少一个数字的被选数量不同，则两种组合是不同的。 对于给定的输入，保证和为 target 的不同组合数少于 150 个。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/combination-sum著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 123456789101112131415161718192021222324252627282930313233343536373839404142class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; combinationSum(vector&lt;int&gt;&amp; candidates, int target) &#123; backtracking(target,0,candidates,0); return result; &#125;private: vector&lt;vector&lt;int&gt;&gt; result; vector&lt;int&gt; path; void backtracking(int targetsum,int sum,const vector&lt;int&gt; candidates,int startindex)//如何解决重复的结果：可重复选取当前的元素 &#123; if(sum&gt;targetsum)//另外一种结束出口 &#123; return; &#125; if(sum == targetsum)//找到组合 &#123; result.push_back(path); return; &#125; for(int i = startindex;i&lt;candidates.size();i++) &#123; path.push_back(candidates[i]); sum+=candidates[i]; backtracking(targetsum,sum,candidates,i); sum-=candidates[i]; path.pop_back(); &#125; &#125;&#125;;/* for(int i = startindex;i&lt;candidates.size();i++) //注意这里使用了 startindex 而不是从 0 开始，因为如果从 0 开始当前元素前面的元素也会纳入计算，就会使得结果重复， &#123; path.push_back(candidates[i]); sum+=candidates[i]; backtracking(targetsum,sum,candidates,i);//i不用+1，当前元素也可以选取 sum-=candidates[i]; path.pop_back(); &#125;*/ 组合总和 2 给定一个数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。 candidates 中的每个数字在每个组合中只能使用一次。canadidates 的元素可以重复 说明： 所有数字（包括目标数）都是正整数。 解集不能包含重复的组合。 示例 1: 输入: candidates = [10,1,2,7,6,1,5], target = 8, 所求解集为: [ [1, 7], [1, 2, 5], [2, 6], [1, 1, 6] ] 示例 2: 输入: candidates = [2,5,2,1,2], target = 5, 所求解集为: [ [1,2,2], [5] ] 为实现去重，要先对数组排序，然后设置 used 数组记录同一层的相同元素是否被使用过 组合问题总结： 给你一个无重复的 candidate 数组，里面的数字不可以重复使用，使其和等于target，那么下一层的 startindex 就是当前层的 stratindex 的下一个 给你一个无重复的 candidate 数组，里面的数字可以重复使用，使其和等于target，那么下一层的startindex和当前的一样。 给你一个重复的 candidate 数组，那么同一树层不能用相同的元素，同一树枝可以用相同的元素 电话号码的字母组合 给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。答案可以按 任意顺序 返回。 给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 12345678910111213141516171819202122232425262728293031323334353637383940414243class Solution &#123;public: vector&lt;string&gt; letterCombinations(string digits) &#123; result.clear(); path.clear(); if(digits.size() == 0) return result; backtracking(digits,0); return result; &#125;private: vector&lt;string&gt; result;//存放结果集 string path;//存放每次的结果 const string lettermap[10]= &#123;//建立数字字母映射关系 &quot;&quot;,//0 &quot;&quot;,//1 &quot;abc&quot;,//2 &quot;def&quot;,//3 &quot;ghi&quot;,//4 &quot;jkl&quot;,//5 &quot;mno&quot;,//6 &quot;pqrs&quot;,//7 &quot;tuv&quot;,//8 &quot;wxyz&quot;,//9 &#125;; void backtracking(const string &amp;digits, int index) &#123; if(path.size() == digits.size()) &#123; result.push_back(path); return ; &#125; int digit = digits[index] - &#x27;0&#x27;;//获得 index 指向的 digit 字符串中的数字 string letters = lettermap[digit];//获取该数字对应的字符集 for(int i=0;i&lt;letters.size();i++)//对获取到的字符集进行遍历 &#123; path.push_back(letters[i]); backtracking(digits,index+1); path.pop_back(); &#125; &#125;&#125;; 分割问题分割回文串 当下一层的开始元素和当前层不一样的时候，就需要使用 startindex 子集问题如果把 子集问题、组合问题、分割问题都抽象为一棵树的话，那么组合问题和分割问题都是收集树的叶子节点，而子集问题是找树的所有节点！ 子集1 给定一组不含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。 说明：解集不能包含重复的子集。 123456789101112131415161718192021222324252627282930class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; subsets(vector&lt;int&gt;&amp; nums) &#123; result.clear(); path.clear(); back(0,nums); return result; &#125;private: vector&lt;int&gt; path; vector&lt;vector&lt;int&gt;&gt; result; void back(int startindex,vector&lt;int&gt;&amp; nums) &#123; result.push_back(path);//和组合排列问题的差别主要体现在这里 //每次向下递归的时候都要收集结果 if(startindex&gt;=nums.size()) &#123; return; &#125; for(int i = startindex;i&lt;nums.size();i++) &#123; path.push_back(nums[i]); back(i + 1,nums); path.pop_back(); &#125; &#125;&#125;; 子集 2 给你一个整数数组 nums ，其中可能包含重复元素，请你返回该数组所有可能的子集（幂集）。 解集 不能 包含重复的子集。返回的解集中，子集可以按 任意顺序 排列。 12345678910111213141516171819202122232425262728293031323334class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; subsetsWithDup(vector&lt;int&gt;&amp; nums) &#123; sort(nums.begin(),nums.end()); vector&lt;bool&gt; used(nums.size(), false); backtracking(nums, 0, used); return result; &#125;private: vector&lt;int&gt; path; vector&lt;vector&lt;int&gt;&gt; result; void backtracking(vector&lt;int&gt;&amp; nums,int startindex,vector&lt;bool&gt;&amp; used) &#123; result.push_back(path); for (int i = startindex; i &lt; nums.size(); i++) &#123; // used[i - 1] == true，说明同一树枝candidates[i - 1]使用过 // used[i - 1] == false，说明同一树层candidates[i - 1]使用过 // 而我们要对同一树层使用过的元素进行跳过 if(i&gt;0 &amp;&amp; nums[i] == nums[i-1] &amp;&amp; used[i-1] == false) &#123; continue; &#125; path.push_back(nums[i]); used[i] = true; backtracking(nums, i + 1, used); used[i] = false; path.pop_back(); &#125; &#125;&#125;; 贪心算法基本题型 关于贪心的一些事情 贪心的本质是选择每一阶段的局部最优，从而达到全局最优。 验证问题是不是可以用贪心，可以举几个例子看结果是不是最优的 动态规划基本题型 关于动态规划的一些事情 如果某一问题有很多重叠子问题，使用动态规划是最有效的。 动态规划中每一个状态一定是由上一个状态推导出来的，这一点就区分于贪心，贪心没有状态推导（和上一个状态没有关系），而是从局部直接选最优的， 所以贪心解决不了动态规划的问题。 动态规划框架五部曲： 确定 dp数组及其下标含义 确定递推公式 初始化 dp 数组 确定遍历顺序 举例推导 dp 数组","categories":[{"name":"COURS","slug":"COURS","permalink":"http://littlewuuu.com/categories/COURS/"}],"tags":[{"name":"有点难学的","slug":"有点难学的","permalink":"http://littlewuuu.com/tags/%E6%9C%89%E7%82%B9%E9%9A%BE%E5%AD%A6%E7%9A%84/"}]},{"title":"6 Minute English and ECN","slug":"ENGLISH/SIX MINUTES","date":"2022-02-05T23:00:00.000Z","updated":"2022-04-11T08:51:43.874Z","comments":true,"path":"2022/02/06/ENGLISH/SIX MINUTES/","link":"","permalink":"http://littlewuuu.com/2022/02/06/ENGLISH/SIX%20MINUTES/","excerpt":"","text":"6 Minute EnglishTOPIC1: ChinDef.The small bit of bone under the mouth useful words: chin up: it means stay positive and optimistic far-fetched: means something is difficult to believe projection: means sth sticks out from the main surface plausible: means sth is acceptable or believable chinwag: to talk a lot or to chat in a relaxed way with friends, a chinwag tends to be a conversation about things that aren’t very important prominent: 显而易见 chinless wonder: 低能儿 a person of subnormal Intelligence like imbecile what I have learnt:Humans are the only animals to have developed a chin, that in a way it sort of helps define what it means to be human. how did it developes, here are two ways to put it it has a lot to do with when humans started to cook their food, so the food they ate became much softer, therefore, our ancestors didn’t need powerful jaws anymore, which made the jaw drop and produced that odd piece of bone we know as chin but some time later the chin became associated with sexual attraction in men, it seems to be plausible that chins emerged as some kind of feature and later were selected to be sex ornaments, males with prominent jaws were supposed to be attractive to women. And men with small chins were thought to be unattractive or weak people. They were even called chinless wonders sometimes TOPIC2: Inventing languagesUseful words patron saintsomeone who is believed to give special help and protection to a particular activity conlang（俚语）constructed language; artificially invented language, such as Esperanto and Klingon get stuck on (something) be unable to continue or complete what you’re doing because it’s too difficult what I have learnt:Two examples of smalls changes: “my bad” instead of “my fault” adding ‘not’ at the end of a sentence to show I really mean the opposite of what I said. reason for the changes: because, unlike say, Latin, which no-one speaks day-to-day, English is a living language – a language people speak and use in their ordinary lives. A famous constructed language, Esperanto：Esperanto is based on Latin. Aims to make it easier for people who spoke different languages to communicate with each other. ENG S6(ECN)Séance 2 make allowance for = take into consideration impostors /ɪm’pɑstɚ/ 冒牌货 stoop 弯腰；屈从 It pains me to stoop down. pitch-and-toss 掷硬币游戏 sinew 肌肉；支持 foe = enemy “go the extra mile” means to make a special effort at something. please find attached my CV A sample of CV My CV Séance 3Cover LetterZilong WU32 Route De la JonelièreNantes zwu43229@gmail.com Dear Sir/Madam, I am a first year engineering student at Centrale Nantes, looking for a four-month internship, and I would like to apply for a software developer position with Capgemini, as advertised on jobteaser.com. Software development appeals to me because of its ability to go from market research requirements to developing models, to modifying and validating them, and finally to develop a product for the general public. Especially after the epidemic, I realised how much a good software can help society. While attending Southwest Jiaotong University and Centrale Nantes, I learned about computing and software development and ran several successful projects through the open source platform GitHub, such as a lightweight web server in C++ under Linux, which gave me some familiarity with software development and an understanding of the web development environment. In my free time, I like to draw to get a closer look at nature. If it is related to my profession, I write a blog and have my own website to record my growth. I enclose a copy of my CV and hope very much to be invited for interview. Yours sincerely, Zilong WU My cover letter Séance 5 current job: back-end server development position looking for: full stack developer, GOOGLE Why we should hire you? First of all I have a lot of experience in server development and maintenance and I was able to get up to speed very quickly with a new server. I quickly adapted to the company and team culture. Secondly, because of my love for design, I learned about design in my free time and built my own website. I usually pay attention to the user experience of products when I use them, so I have accumulated some points that others may not notice. what do you consider to be the skills necessary for this position? Quickly getting up to speed with the toolset used by the company means being able to integrate quickly into work. Resilience to stress, as the product delivery phase can be more stressful than usual ability to work in a team, as I can’t do the product development alone, so communicating with team members is an important ability that determines the role you play in the group. Why did you leave your last job?（Full Stack Engineer, User Interface） -I am currently in charge of the back-end server development, which means I am only involved in part of the product development, but I want to be involved in the whole process of product development, to be a full stack developer. Because I like design and I have my own ideas about how a product’s UI should look, and when I use some of the products I also find some of their design shortcomings, so I want to go through that part myself and make a product that is a better experience. shadowed an IT technician Third-year student 工程师一年级算是第三年 vacancy：空额 Séance 6 摩洛哥 🇲🇦 concise go nuts 发疯 coconut culture V.S. peach culture my own “orange culture” Jobs Séance 7 Séance 8","categories":[{"name":"COURS","slug":"COURS","permalink":"http://littlewuuu.com/categories/COURS/"}],"tags":[{"name":"ENG","slug":"ENG","permalink":"http://littlewuuu.com/tags/ENG/"}]},{"title":"Unbelievable!","slug":"生活/一些惊人的事","date":"2022-01-31T23:00:00.000Z","updated":"2022-02-07T15:23:18.474Z","comments":true,"path":"2022/02/01/生活/一些惊人的事/","link":"","permalink":"http://littlewuuu.com/2022/02/01/%E7%94%9F%E6%B4%BB/%E4%B8%80%E4%BA%9B%E6%83%8A%E4%BA%BA%E7%9A%84%E4%BA%8B/","excerpt":"","text":"2022-2-1 我的电饭锅被偷了！还顺走冰箱里的鸡蛋和辣椒，还好米没拿走，应该是太重了，素质没掉了😠 2022-2-2 讨论滑雪假出行，沪（lu二声）漂 from NI，这个女子总是能让我们惊掉下巴","categories":[{"name":"生活","slug":"生活","permalink":"http://littlewuuu.com/categories/%E7%94%9F%E6%B4%BB/"}],"tags":[]},{"title":"Vivre à Nantes","slug":"生活/在南特","date":"2022-01-27T23:00:00.000Z","updated":"2022-05-20T07:41:08.807Z","comments":true,"path":"2022/01/28/生活/在南特/","link":"","permalink":"http://littlewuuu.com/2022/01/28/%E7%94%9F%E6%B4%BB/%E5%9C%A8%E5%8D%97%E7%89%B9/","excerpt":"","text":"Vivre à Nantes 只要未来可期，每天都值得欣喜 有花才浪漫 菜市场也浪漫 --- 有点想回到那个地方了 --- --- 夏天 好好看的天空 --- La Fanfrale 好有生命力的 ---- 好满意我房间的位置，日落绝美，就是只能看一个夏天 大笨和姜姜，每次下课抱到他们都很快乐 小笨和甜甜 巧克力豆豆：没有耳朵的棕色小熊的总称，具有脑袋圆乎乎，小手胖乎乎的特点，眼睛像豆豆，超级可爱，大小笨是巧克力豆豆的典型代表。 还没有好好逛过 Nantes 春天应该有花 2022-03-12 春天太美好了 2022-03-12 --- 嗨！ 2022-03-12 2022-03-21 整棵春天 2022-04-11 2022-04-15 搬家啦 2022-04-17 --- 我太喜欢画画了 2022-05-19","categories":[{"name":"生活","slug":"生活","permalink":"http://littlewuuu.com/categories/%E7%94%9F%E6%B4%BB/"}],"tags":[{"name":"好好生活","slug":"好好生活","permalink":"http://littlewuuu.com/tags/%E5%A5%BD%E5%A5%BD%E7%94%9F%E6%B4%BB/"}]},{"title":"SSTEM","slug":"SSTEM/SSTEM","date":"2022-01-26T23:00:00.000Z","updated":"2022-02-03T11:12:05.514Z","comments":true,"path":"2022/01/27/SSTEM/SSTEM/","link":"","permalink":"http://littlewuuu.com/2022/01/27/SSTEM/SSTEM/","excerpt":"","text":"BPMN一些词la finalié, la mission, les objectifles parties prenantesLe client Hervé Durand a retiré( 删除 ) tous les “Saint-Emilion” de sa commande.Yvon Manac’h a décidé de faire valoir ses droits à la retraite（退休） 模型1. Modele entité association（有 1:n 的）是概念模型的一种，可以看成 ER 图 2. Modele logique (把 0:n 转化成箭头) 3. Modele Physique des Données (加上每个属性的类型，integer，varchar 什么的)也是关系模型&gt; DATE 只有日期TIMESTAMP 包括日期和时间 SQL基本格式 SELECT [ DISTINCT ] [ COUNT( ) / SUM( ) / AVG( ) / MAX( ) / MIN( )]FROM [ NARURAL JOIN ]WHERE [ AND/OR/NOT/BETWEEN AND/ ][ &lt;&gt; 不等于 ] [ IN(…) ][ LIKE/ILIKE %(remplace quel nombre de caractères),_ (remplace un caractères) ][ IS NOT NULL/IS NULL ][ UPPER nom LIKE UPPER(‘ass’) ][ IN SELECT (是 where 后面的在不在这个 select 里面)] GROUP BY [ ] ORDER BY [ 可以有多个 order by 的对象，ORDER BY 语句默认按照升序对记录进行排序。要按照降序对记录进行排序，可以使用 DESC 关键字。 ] UNION操作符用于合并两个或多个 SELECT 语句的结果集。UNION 内部的每个 SELECT 语句必须拥有相同数量的列。列也必须拥有相似的数据类型。同时，每个 SELECT 语句中的列的顺序必须相同。UNION 结果集中的列名总是等于 UNION 中第一个 SELECT 语句中的列名。 增删查改数据库操作 CREATE DATABASE nomDROP DATABASE nom 表操作CREATE TABLE（）INSERT INTO table_name [ ( 可以选择属性 ) ] VALUES ( 属性值 )UPDATE table_name SET WHEREDELETE FROM teble_name WHERE增删列 ALTER TABLE table_nameADD column_name datatype/DROP COLUMN column_name更改属性 SQL Server / MS Access：ALTER TABLE table_nameALTER COLUMN column_name datatypeMy SQL / Oracle：ALTER TABLE table_nameMODIFY COLUMN column_name datatype COMMIT ROLLBACK","categories":[{"name":"COURS","slug":"COURS","permalink":"http://littlewuuu.com/categories/COURS/"}],"tags":[{"name":"ECN","slug":"ECN","permalink":"http://littlewuuu.com/tags/ECN/"}]},{"title":"ENCLI CM notes","slug":"ENCLI/CM","date":"2022-01-21T23:00:00.000Z","updated":"2022-11-10T15:29:35.612Z","comments":true,"path":"2022/01/22/ENCLI/CM/","link":"","permalink":"http://littlewuuu.com/2022/01/22/ENCLI/CM/","excerpt":"","text":"CM4 1. Pourquoi réaliser une comptabilité carbone (碳计算)? 1.1 Contexte（背景） et chiffres clés（关键数字） mot Hausse prévisible(预计) des températures quota d’émission carbone 碳排放配额 la deuxième moitié du 21ème siècle. 下半世纪 l’inventaire national 国家清单 Temps de séjours(停留时间) des GES dans l’atmosphère éternel 永久的 1.2 Neutralité carbone（碳中和） Def: Séquestrer（绑架，拘禁） autant de carbone que nous en émettons de manière à stabiliser(稳定) son niveau de concentration（集中，浓度） dans l’atmosphère Puits de carbone : Tout système qui absorbe plus de carbone qu’il n’en émet Comment appliquer le concept de neutralité carbone ? deux leviers: • Réduire les émissions de GES • Séquestrer le CO2 dans des puits biologiques ou technologiques 1.3 Stratégie bas carbone（低碳策略） 2. La comptabilité carbone : C’est quoi ? 2.1 Référentiels(基准) et principes 3 facteurs du climat Énergie solaire, Effet de serre Circulations atmosphériques et océaniques Une unité de mesure commune, l’équivalent CO2 Le PRG (Pouvoir de réchauffement global) PRG représente l’effet combiné(综合影响) du temps de séjour du gaz dans l’atmosphère et son pouvoir（能力） relatif d’absorption du rayonnement（辐射）infrarouge（红外线）, cumulé sur une durée de 100 ans. bilans GES Def: Un Bilan GES est une évaluation de la quantité de gaz à effet de serre émise (ou captée) dans l’atmosphère sur une année par les activités d’une organisation ou d’un territoire(地区). Postes d’émissions Classer les émissions comptabilisées dans des catégories prédéterminées appelées « postes » Pourquoi calculer les émissions GES ? Objectif principal: Identifier les « postes » les plus émetteurs afin de déterminer les leviers d’actions pour diminuer les émissions de gaz à effet de serre. 2.2 Méthodes 3. Stratégie bas carbone :Vers une trajectoire 1,5°C Cas d’une organisation 3.1 Evaluation des émissions GES 3.2 Emissions évitées 3.3 Développement d’une stratégie bas carbone 3.4 Mise en œuvre et suivi du plan d’action 3.5 Evaluation de la stratégie 4. Comment s’aligner sur une trajectoire compatible avec les 1,5°C ? 4.1 Equation de Kaya 4.2 Conclusion CM7 objectif zéro 1 une problème complexe 1.1 médicament avec effct secondaire Il y a quelques mois nous fêtions(fêter) le 6 ème anniversaire de l’accord de Paris. Si à certains égards(在某些方面) cet accord fut（etre 的虚拟式） un succès, force est de constater（观察到） que depuis très peu de progrès ont été accomplis et seule une pandémie mondiale est venue inverser la courbe des émissions de CO2. Pourquoi cela ? Pourquoi est-ce si dure（费劲的） de changer ? Pourquoi patinons nous dans cette course contre le réchauffement climatique ? correction: –les energie fossiles fournissent toujours environ 80% de l’approvisionnement mondiale d’energie primaire –sans precedent croissance economique synonyme de progres humains 1.2 inertie(惯性) –l’inertie de nos systemes –nous avons appris à vivre avec les énergie fossiles. –les remplacer necessitera de très lourd, couteux et profonds changement dans nos infrastructure et notre économie 1.3 dilemme du prisonnier(囚徒困境) tout le mond veut sauver la planète mai personne ne veut pas descendre les poubelles c’est quoi? Un procureur détient deux complices d’un braquage dans des cellules séparées. Il n’a pas suffisamment de preuves pour les inculper et leur propose un marché（交易） : • Si l’un deux accepte de témoigner contre l’autre il sera libéré et le complice ira en prison pour 10 ans • Si chacun balance, c’est 6 ans pour les deux • Si ils restent loyaux, le procureur ne pourra que les condamner pour un chef d’accusation mineur (6 mois de prison chacun). une variante: le probleme du passager clandestin(freerider) Dans un train, le passager clandestin, celui qui ne paie pas son billet, profite d’un service auquel il ne contribue pas. Pour le RC c’est pareil. Les pays qui ne feront pas d’effort de réduction des émissions de CO2 bénéficient de l’effort des autres pays. On a toujours intérêt, égoïstement, à être le dernier à passer à l’action. Et à l’inverse, un pays qui déciderait seul de faire des efforts ne récupérait qu’une part marginale des bénéfices. baisse des rendements（产量）agricoles = hausse des prix montée du niveau de la mer = construction de digue augmentation du nombre de canicules(酷暑) = climatisation Beaucoup de dépenses contre la lutte = peu de dommage peu de dépenses = beaucoup de dommage Il y a donc un optimum entre coût de la lutte contre le RC et coût des impacts du RC Pour caricaturer mieux vaut-il vivre dans un monde à +2 °C pauvre ou un monde à +3 °C riche avec clim Jusqu’à récemment le consensus semblait être assez haut (+3 °C) Avec l’amélioration de la science climatique et la baisse du coût des ENR, l’optimum semble se déplacer vers le bas 1.4 pas de coupable ideal complique != complexe Jouer au golf c’est compliqué (le jonglage（杂技） est aussi un bon exemple). Acquérir le bon geste(姿势) peut prendre des années. Mais les règles et la stratégie sont relativement simples. Les échecs(国际象棋) sont tout le contraire. Déplacer un pièce est simple mais les règles sont complexes et les stratégies infinis. Le jeu est complexe. C’est la multiplicité des possibilités, des interactions, des combinaisons, des rétroactions（反馈） qui rend un problème complexe plus que compliqué. Les enjeux énergétiques, environnementaux et climatiques sont complexes, les problèmes sont mal posés, difficile à simuler, il a des multiples solutions et aucune n’est parfaite. Il est même très difficile de dire qu’une solution est meilleure qu’une autre, ceci relevant souvent des préférences personnelles comme la politique (exemple : nucléaire vs renouvelables) 2 trajectoire bas carbone（低碳） 4 commandements de la neutralité carbone Réduire ne suffit pas. Dans certains secteurs comme les transports ou le bâtiment il faudra quasiment intégralement stopper la combustion d’énergies fossiles ! D’autres secteurs au contraire seront très difficile à décarboner et donc … L’immense majorité des scénarios de transition énergétique s’appuient plus ou moins sur des émissions négatives Il est possible de réduire très rapidement nos émissions ou les réduire moins vite mais il faudra alors compenser avec plus d’émissions négatives Les émissions négatives sont faites par la main de l’homme. Ne pas confondre avec les puits naturels forcés qui ne comptent pas dans la neutralité carbone et cesseront d’être forcé et donc d’absorber une partie de nos émissions au fur et à mesure que la concentration de CO2 baissera Équation de Kaya CO2 = P×S×E×C （Les termes ne sont pas indépendants） 1. Population Baisse du taux de croissance du à la (由于): transition démographique（人口转型） 2. S Le PIB c’est la somme des revenus 3. E –Moins d’énergie pour le même service –Plus on progresse plus il est difficile de progresser (low hanging fruits) –E = Energ/PIB –Le PIB mesure la valeur des choses ! Pas l’énergie –E x 0,4 à 0,7 4. PSEE Réduire ne suffit pas! Il faut arriver à ~ 0 5. C –contenu(含量) CO2 de l’énergie. Seul terme qui pourrait s’annuler. La combinaison des trois premiers facteurs pourrait, par miracle(奇迹), être inférieure à 1 (être inférieur à…比……低)， mais aucun des termes ne pourra tomber à zéro. En effet, comme Kaya est une multiplication, il suffit qu’un seul des termes s’annule pour que tout s’annule. découplage：chaque nouvelle unité de richesse produite, l’humanité consomme moins d’énergie. 3. Les 8 piliers(支柱) de la transition(转型) global sources of GES 右边三个通常是被注意到的，左边除了 industry fuel use，通常被忽略 –Il n’y a aucun coupable idéal, aucune cause majeure. Viser la suppression plutôt que la réduction（Réduire ne suffit pas） –Baisser la consommation des moteurs(发动机) à combustion n’est que retarder l’échéance（期限） –Adapter les moteurs à combustion pour qu’ils brulent des carburants propres(清洁材料) est une solution à 100 % Critères pour évaluer si une solution est bonne : ▪ Prix ▪ Échelle ▪ Nombre de personnes impliquées ▪ Mode de vie ▪ Solution 10 ou 100 % 8 piliers (Il n’est pas nécessaire de procéder(进行) de manière séquentielle.) Maitrise（控制）des consommation Sobriété + efficacité énergétique ▪ Sobriété : potentiel faible ▪ Efficacité énergétique : fort potentiel (électrification) Les deux sont essentiels Bonne efficacité économique Réduit investissement énergie décarbonée, émissions négatives Électricité propre(清洁能源) –La génération d’électricité est aussi le poste le plus facile à décarboner : c’est donc notre premier pilier –Renouvelables –hydroélectrique ▪ Bas carbone ▪ Pas cher à exploiter ▪ Sûr ▪ Renouvelable ▪ Stockage ▪ Pilotable ▪ Centralisée mais ▪ Couteux à construire / matériaux ▪ Biodiversité ▪ Espace ▪ Méthane ? –Solaire ▪ Bas carbone ▪ Pas cher à exploiter ▪ Sûr ▪ Renouvelable ▪ Facile à déployer mais ▪ Non pilotable (不可控) / Intermittent（间断的） ▪ Matériaux ▪ Espace ▪ Décentralisée –Éolien –Biomasse –Nucléaire Brown coal = lignite（褐煤） : charbon de mauvais qualité Equilibre du réseau Def: L’électricité ne se stocke pas，Si bien que pour ne pas faire exploser le réseau, « les électrons produits doivent être consommés aussi tôt ». “La production d’électricité doit toujours être égale à la consommation sous peine de coupures voir de black out. Cette tâche cruciale de suivie de charge est assurée en France par RTE, le gestionnaire du réseau électrique. A l’aide des prévisions météo et de profils de consommation étonnamment régulier, RTE est capable de prédire quelle sera la consommation électrique du lendemain.” Électrification（电气化） –les voitures élec sont meilleures pour l’environnement que les voitures thermiques (y compris hybride) Mais l’électrification c’est bien plus que la voiture. Les équivalents électriques（电动同类产品） sont souvent plus chers à l’achat et moins chers à l’usage. Ils ont besoin d’être subventionné（补贴）. Les subventions et les gens qui acceptent de payer plus cher donnent une indication（指示）au marché qui se met alors à en produire plus. En produisant plus on devient meilleur à la production et les coûts de fabrication baissent, entrainant（带动）une baisse du coût d’achat et donc une hausse de la demande, etc. Cercle vertueux. Mais les équivalents électriques seront rarement intéressant au point de jeter une machine thermique encore fonctionnelle. Carburant（燃料） de synthèse（合成） Hydrogène 氢气-&gt;Ammoniac 氨水 Solutions pour émissions non liées à de la combustion 1/3 des émissions sont liées à des processus n’impliquant pas de production d’énergie Production de ciment Deux sources de CO2 Énergie fossile pour chauffer le four La décarbonatation du calcaire pendant la phase de pré-calcination dans le four : CaCO 3 → CaO + CO2 Production d’acier Deux sources de CO2 : Énergie fossile pour chauffer le four CO2 du à l’utilisation de charbon pour faire l’acier AFOLU : Agriculture, Forestry, and Other Land Use Capturer et stocker CCS En anglais : carbone capture and storage, adapté pour le stockage de sources ponctuelles En français : Séquestration géologique de CO2 Carbone Dioxyde Removal (CDR) les techniques visant à retirer le CO2 atmosphérique P190看到 7. Adaptation 8. Géo-ingéniérie TD 重要公式： 1tep = 11630 kWh 1Wh = 1W * 3600s = 3600 J (w = J/s) 1 BTU = 1055 J 1 Calorie = 4.18 J 1 kCal = 4184 J 电池功率（Wh）=电池电压（V）x电池容量（Ah） W = V * A = J/s energir(J) -&gt; puissance moyenne(W = J/s) -&gt; puissance moyenne surfacique(W/m2) puissance moyenne (W) = puissance installe * facteur de charge puissance moyenne surfacique(W/m2)= puissance moyenne/surface (W/m2) production annuelle(TWh) puissance moyenne(MW) = production anuelle / (365*24) puissance moyenne surfacique(W) = puissance moyenne / surface","categories":[{"name":"COURS","slug":"COURS","permalink":"http://littlewuuu.com/categories/COURS/"}],"tags":[{"name":"ECN","slug":"ECN","permalink":"http://littlewuuu.com/tags/ECN/"}]},{"title":"去过的一些地方","slug":"SomePlaces/去过的一些地方","date":"2022-01-01T23:00:00.000Z","updated":"2022-11-10T16:10:13.157Z","comments":true,"path":"2022/01/02/SomePlaces/去过的一些地方/","link":"","permalink":"http://littlewuuu.com/2022/01/02/SomePlaces/%E5%8E%BB%E8%BF%87%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9C%B0%E6%96%B9/","excerpt":"","text":"Vichy 很快乐的一个月，应该会再去一次吧 Feu d'artifice Spectacle de umière 第一次被这个小镇浪漫到 Lac d'Allier 很喜欢夏天的河边 Cavilam 突然想起高中的时候，在这里学会了 tranquillement 很喜欢这样的小镇 很自由的感觉 超好的房东， 看我不敢讲法语还找个学长来陪我聊天😭，超好的瑞士小哥 还有马来西亚的小伙伴人都好好，（忽略你们说我讲国语有口音） Lyon Vieux Lyon 老城还是有魅力的 有够幸运的我们仨 在一个公园看到的， Paris 还是浪漫的 Malta 姜姜也开心，住上大房子，坐上大邮轮 还是喜欢海 Roma 永远喜欢日落 不是很喜欢罗马， 手机是在那里摔的，衣服是邮局门口被鸟屎淋的，但是还是人间值得了 Milan 大教堂和大圣诞树 在米兰过了小半个圣诞节 还有在邮局买邮票，被意大利语一通输出，这辈子不进意大利邮局了 La Baule 一直很喜欢海边 Strasbourg 2022 - 02 - 12 Nantes->Paris->Strasbourg 第一次自驾 自驾的惊喜吧 突然有了回家的感觉 小小的好可爱 全是自由 Marseille 13-05-2022 Marseille(calanque) 30-06-2022 Nice 04-07-2022 Monaco 06-07-2022 Paris 14-07-2022 ColdplayParis 16-07-2022 Swiss 31-10-2022","categories":[{"name":"生活","slug":"生活","permalink":"http://littlewuuu.com/categories/%E7%94%9F%E6%B4%BB/"}],"tags":[{"name":"到处玩","slug":"到处玩","permalink":"http://littlewuuu.com/tags/%E5%88%B0%E5%A4%84%E7%8E%A9/"}]},{"title":"不知名大厨的美食","slug":"整活/奇奇怪怪的菜","date":"2021-12-30T23:00:00.000Z","updated":"2022-02-04T17:25:35.708Z","comments":true,"path":"2021/12/31/整活/奇奇怪怪的菜/","link":"","permalink":"http://littlewuuu.com/2021/12/31/%E6%95%B4%E6%B4%BB/%E5%A5%87%E5%A5%87%E6%80%AA%E6%80%AA%E7%9A%84%E8%8F%9C/","excerpt":"","text":"暂时称作蝴蝶碳 Via: Wenli ZHANG 鸡腿碳 Via: Li NI 鸡腿碳 Via: Li NI 绿色心情 Via: Zilong WU","categories":[{"name":"做饭区","slug":"做饭区","permalink":"http://littlewuuu.com/categories/%E5%81%9A%E9%A5%AD%E5%8C%BA/"}],"tags":[{"name":"一些奇奇怪怪的吃的","slug":"一些奇奇怪怪的吃的","permalink":"http://littlewuuu.com/tags/%E4%B8%80%E4%BA%9B%E5%A5%87%E5%A5%87%E6%80%AA%E6%80%AA%E7%9A%84%E5%90%83%E7%9A%84/"}]},{"title":"计算机图形学","slug":"计算机图形学","date":"2021-12-29T23:00:00.000Z","updated":"2022-02-20T16:00:08.227Z","comments":true,"path":"2021/12/30/计算机图形学/","link":"","permalink":"http://littlewuuu.com/2021/12/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/","excerpt":"","text":"还没开始学 :(开始学了，学了视角变换，投影，透视，光栅化，shading。MVP","categories":[{"name":"COURS","slug":"COURS","permalink":"http://littlewuuu.com/categories/COURS/"}],"tags":[{"name":"有点难学的","slug":"有点难学的","permalink":"http://littlewuuu.com/tags/%E6%9C%89%E7%82%B9%E9%9A%BE%E5%AD%A6%E7%9A%84/"}]},{"title":"markdown 没学明白指南","slug":"markdown基本语法","date":"2021-12-29T23:00:00.000Z","updated":"2022-04-09T07:28:55.034Z","comments":true,"path":"2021/12/30/markdown基本语法/","link":"","permalink":"http://littlewuuu.com/2021/12/30/markdown%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/","excerpt":"","text":"一级标题二级三级 斜体加粗 删除线 引用1 引用2 引用3 ​ 分割线 加粗了也可以使用 command+b 来加粗 斜体也可以使用 command+i 来斜体 1.第一个 2.第二个 3.第三个 插入图片12![图片名称](图片地址)*图片标题* 输入 LaTeX 公式enter latex between these two 美元符号 enter latex between these twocommand + m 连续按两下，出现四个$command + m 出现两个$在一段句子中插入公式$ sin (x) $ 表格 姓名 学号 wuzilong 2019110473 计算机一班 插入链接复制链接，然后选中想要添加链接的文字，command+v，就可以自动添加了，这是一个链接 code12int main(void)美式键盘下打出这三个小撇 超链接微博Markdown本身语法不支持链接在新页面中打开，貌似简书做了处理，是可以的。别的平台可能就不行了，如果想要在新页面中打开的话可以用html语言的a标签代替。 超链接名 示例简书 列表无序列表 “-”可以表示列表 “+”也可以 “*”也可以有序列表 第一个 第二个,可以用 tab 键来实现不同级别 第三个序号和后面的内容要有空格 流程图1234567st=&gt;start: 开始op=&gt;operation: 选择cond=&gt;condition: Yes or No?e=&gt;end: endst-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;op 图片并排123&lt;center class=&quot;half&quot;&gt;&lt;img src=&quot;https://...&quot; width=40%/&gt; &lt;img src=&quot;https://...&quot; width=40%/&gt; &lt;/center&gt; 标题居中加粗12&lt;div align=&#x27;center&#x27; &gt;&lt;font size=&#x27;5&#x27;&gt; &lt;strong&gt;&quot;...&quot;&lt;/strong&gt;&lt;/font&gt;&lt;/div&gt;&lt;br/&gt; 换行符1&lt;br/&gt; 空格12&amp;nbsp LaTeX 希腊字母 \\leq 小于等于 \\geq 大于等于 \\forall 任意 \\in 存在 \\frac{}{} 分式 \\triangleup \\triangledown \\sum \\lambda \\rho \\bar{} : $\\bar{a}$","categories":[{"name":"SKILLS","slug":"SKILLS","permalink":"http://littlewuuu.com/categories/SKILLS/"}],"tags":[{"name":"学了又忘的杂七杂八","slug":"学了又忘的杂七杂八","permalink":"http://littlewuuu.com/tags/%E5%AD%A6%E4%BA%86%E5%8F%88%E5%BF%98%E7%9A%84%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/"}]},{"title":"conditionnel","slug":"Francaise/conditionnel","date":"2021-12-29T23:00:00.000Z","updated":"2021-12-31T19:14:47.046Z","comments":true,"path":"2021/12/30/Francaise/conditionnel/","link":"","permalink":"http://littlewuuu.com/2021/12/30/Francaise/conditionnel/","excerpt":"","text":"conditionnel présent组成简单将来词干+未完成过去词尾 avoir 单数 复数 第一人称 j’aurais nous aurions 第二人称 tu aurais vous auriez 第三人称 il aurait ils auraient être 单数 复数 第一人称 je serais nous serions 第二人称 tu serais vous seriez 第三人称 il serait ils seraient 用法 表示委婉请求建议 Tu devrais faire plus d’attention au temps．(委婉建议) Il y aurait plus de possibilités de réussir．(表推测，不能肯定) Je voudrais aller en France dans un an．(表示愿望) Marie viendrait chercher ses enfants demain. 玛丽也许明天会来接她的孩子。 表示与实际情况相反 Si elle était riche，elle voudrait acheter un chateau．(她如果富有的话，她想买一个城堡。） 表示将来可能发生的情况 S’il pleuvait demain，ma copine et moi resteraient à la maison 如果动作实现的可能性极大，主句也可以用直陈式简单将来时，从句用直陈式现在时。试比较： S’il fait beau demain, on ira au bord de la mer. （如果明天天气好，我们就去海边。）根据现在的迹象表明明天的天气很可能会很好，我们去海边的可能性很大。 S’il faisait beau demain, on irait au bord de la mer.（如果明天天气好，我们就去海边。）但是根据现在的迹象表明很有可能明天天气不好，我们去海边的可能性很小。","categories":[{"name":"le français","slug":"le-francais","permalink":"http://littlewuuu.com/categories/le-francais/"}],"tags":[{"name":"le français","slug":"le-francais","permalink":"http://littlewuuu.com/tags/le-francais/"}]},{"title":"好吃的","slug":"好吃的/真好吃","date":"2021-12-29T23:00:00.000Z","updated":"2022-03-19T14:46:14.246Z","comments":true,"path":"2021/12/30/好吃的/真好吃/","link":"","permalink":"http://littlewuuu.com/2021/12/30/%E5%A5%BD%E5%90%83%E7%9A%84/%E7%9C%9F%E5%A5%BD%E5%90%83/","excerpt":"","text":"糊弄一下 龙虾意面 ( ROMA ) 土豆炖排骨 ( REZ B ) &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp 土豆炖虾 ( REZ B ) 沙拉 ( Vichy )&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp 土豆牛腩 ( REZ B ) 豚骨汤 ( REZ B ) &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp 卤鸡腿 ( REZ B ) &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp Via: Li NI 干锅鸡 ( REZ B ) &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp 卤鸡腿 ( REZ B ) Via: Li NI &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp 猪肘子( REZ B ) and 科尔马的猪肘子（Le Fer Rouge）","categories":[{"name":"做饭区","slug":"做饭区","permalink":"http://littlewuuu.com/categories/%E5%81%9A%E9%A5%AD%E5%8C%BA/"}],"tags":[{"name":"一些正正经经的吃的","slug":"一些正正经经的吃的","permalink":"http://littlewuuu.com/tags/%E4%B8%80%E4%BA%9B%E6%AD%A3%E6%AD%A3%E7%BB%8F%E7%BB%8F%E7%9A%84%E5%90%83%E7%9A%84/"}]},{"title":"教会自己用 git","slug":"Git/git_usage1","date":"2021-12-02T23:00:00.000Z","updated":"2022-11-10T15:52:22.633Z","comments":true,"path":"2021/12/03/Git/git_usage1/","link":"","permalink":"http://littlewuuu.com/2021/12/03/Git/git_usage1/","excerpt":"","text":"#实现本地文件和 Github 仓库同步 ##Macbook Air M1 ssh 等配置 在 GitHub 上创建仓库 准备好本地的文件存放位置 切换终端目录到本地文件夹 初始化本地文件夹 1git init 连接到 GitHub 仓库 1git remote add origin 仓库网址（注意是 ssh 不是 url） 切换 1git branch -M main 把想要上传的文件拖放到本地文件夹 上传 将文件送到缓区 部分文件 1git add . //把本地文件夹的所有内容送到缓存区 所有文件 1git add filename //把指定的文件送到缓存区 commit 必须要有这一步，如果是全部文件到缓存区，则所有的文件都是这个注释，如果是指定文件到缓存区，则对指定文件注释 1Git commit -m “注释” 上传 1git push -u origin main 取消链接 1git remote remove origin","categories":[{"name":"SKILLS","slug":"SKILLS","permalink":"http://littlewuuu.com/categories/SKILLS/"}],"tags":[{"name":"学了又忘的杂七杂八","slug":"学了又忘的杂七杂八","permalink":"http://littlewuuu.com/tags/%E5%AD%A6%E4%BA%86%E5%8F%88%E5%BF%98%E7%9A%84%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/"}]},{"title":"Quelques connaissances（Quelques exemples spécifiques）","slug":"Francaise/法语笔记","date":"2021-02-02T23:00:00.000Z","updated":"2022-08-15T18:00:07.345Z","comments":true,"path":"2021/02/03/Francaise/法语笔记/","link":"","permalink":"http://littlewuuu.com/2021/02/03/Francaise/%E6%B3%95%E8%AF%AD%E7%AC%94%E8%AE%B0/","excerpt":"","text":"2021 12 30 test1 vieux le jour de l’ouverture, il y a des bougies allumées sur des table #过去分词当形容词 passer le temps à faire qch un sur cinq #五分之一 changer A contre B voulez-vous me dire ce que vous ferezde ce dictionnaire #ce que 当宾语 le temps qu’il a perdu ne se retrouve jamais une saison faire attention à aucun #指人 se mettre à plusieurs #几个人一起干 n’importe où #无论什么地方 quelqu’un de compétent #形容词修饰指示代词要加 de une personne compétente dans chacune des fermes #chacun,e 是指示代词 chaque fois #chaque 是形容词 2021 12 29adverbes Je veux bien faire une randonnée à vélo mais il faudra rouler lentement pour que nous puissions profiter du paysage. mal mauvais rapide vite léopard 非洲豹 Je suis d’accord avec toi. En revanche, je ne suis pas d’accord avec Paul. Nous avons marché toute la matinée puis nous nous sommes arrêtés pour pique-niquer. Mes voisins m’ont certes recommandé de rester chez moi aux heures chaudes, je dois pourtant sortir pour aller à la bibliothèque. préposition près de - loin de après - avant avant 时间 - devant 地点 D’après la météo, il fera beau la semaine prochaine.（根据天气预报） test 2 compter sur qn 信任某人 compter avec qn 重视考虑 pour + 一段时间 à + 时间点 dans dix minutes #十分钟后 même s’ 哪怕 quoique 尽管 Avant de signer, lisez bien ce qui est écrit sue le contrat.#ce qui 作 est écrit 的主语，判断的标准是看是不是后面接的句子的主语，而不是看整个句子的主语 songer à 想什么，思念什么 en apprenant que（知道） l’équipe de France avait gagné, il a sauté de joie.#de 表示原因 trop pour 太 以至于 etre responsable de 对 有责任 pourtant je le leur （先直接后间接）ai déjà expliqué dix fois #j’ai deja explique cettes questions à les étudiants il fait un temps bizzare #有形容词修饰 temps，用不定冠词 la famille a passé d’excellentes vacances au bord de la mer vacance 空缺 vacances 假期 vacances 有 excellentes 修饰，用不定冠词 des 当不定冠词直接在形容词之前，将 des 改成 de bijou - bijoux beau - beaux l’histoire a de quoi vous étonner avoir de quoi faire 有足够的的东西来 les chiens dont il a le plus peuril a le plus peur des les chiens rends-le-moi demain matin sans faute 肯定命令句中 le moi y en toute jeune fille a rêvé du prince tout/toute + 单数 : 任何 test 3 comme tel 像这样 telle chose 这样的事情 ses parents lui font pratiquer régulièrement du sport#faire faire qch à qn 让某人做某事 tout heureuses aucun 的用法 ne/sans aucun 没有一个的 任何 名词 + quelconque — n’importe quel + 名词 beaucoup 的同等比较级 autant que se faire sentir 使自己感到 se sentir 自己感到 faute de quoi etre fier de 自豪 quelque chose de drôle#泛指代词和形容词之间用 de 链接 etre + 序数词 + à + inf 第几个做 test 4 punir pour mentir voir qn faire(inf.) qqch si le temp est bon, on mengera sur la terrasse bien - mieux | bon meilleur souhaiter qqch à qn c’est que/qui强调句式 re rendre au rendez-vous 赴约 la fille à qui je me suis adressé est très belle veux-tu un café non, je n’en prends pas veux-tu le café non, je ne le prends pas il parraît que 直陈式（表事实）/虚拟式（表推测） 看似。。。 désigner qn comme 挑选某人为。。 il interroge Valerie sur son intentionsinterroger qn sur qqch 向某人询问某事 personne 接形容词要加 de souhaiter faire qqch test5 Le Général de Gaulle 戴高乐 penser à qnqn不用间接宾语，直接用重读人称 appartenir à qn属于某人 sévère — indulgents grippe 感冒 faire à qcn习惯于某事 mordre 咬 se souvenir de qch me le lui y en 除肯定命令式中 le moi y en肯定命令式中 代词顺序 on lui avait déjà expliqué qu’il ne pourrait revenir au collège qu’avec des cheveux courtspourrait条件式现在时表示过去将来 comme si + imparfait c’est le meilleur chanteur que je connaisse最高级表示主观，用connaisse虚拟式 test 6 autoroute 在过去时态里表示一个将来的时间，用 “时间 + après” savant 有学识的 devoir à qn 多亏某人 les uns … les autres 一些人 另一些人 c’est une maladie qui est facile à guérir(治愈) s’évanouir 晕倒 en partant de bonne heure, ils ont réussi à éviter les embouteillagesen可以引导表示原因 qu‘est-ce que vous choisissez comme dessert comme 作为而不用 pour 为了 anfin de tous les étudiants puissent lire cet article, j’ai fait des photocopiesanfin de 为了 ce chauffeur a dit que l’autocar partirait quand tout le momde serait arrivé条件式现在时（partirait）表示过去将来，条件式过去时（serait arrivé）表示过去先将来时即先发生 six mètres sur quatre表示 6×4 平方米 profiter de 利用 demander à qn de faire qch aider qn à faire qcn il n’y a personne de compétent dans cette société此时 personne 后面有de，可以用 personne，表示没有人 envoyer qn faire qcn 派遣某人做某事 test 7 en cas 如果 au-delà de 超过 durée hebdomadaire 每周持续时间 s’attendre à 预计 passer son temps à dater de 追溯到 des + adj + n 时，des -&gt; de prendre des risques 冒风险 s’identifier à 与…同化 se féliciter de 感到庆幸 lutte contre 与 斗争 lutte pour 为 斗争 à l’époque 在那个时候，表示过去 espèrer faire malgré que 尽管+虚拟式 a la suite 由于，在 后面 si bien que 以至于 dès que 一 就 féliciter qn de faire qch penser + inf se tromper 搞错 croire à 相信 test8 dans quelques instants 过一会（将来） TFI matin 和 matinée nous avons rendez-vous dans la matinée la matinée 强调整个时间段， le matin 就不用 dans 了 表示过去习惯：未完成过去式 表示现在习惯：直陈式现在时 depuis que 时间间隔较长，自从 dès que 时间间隔较短，一…就… duquel, de laquelle, desquels, desquelles 都与 de 有关 auquel, à laquelle, auxquels, auxquelles à moins que 除非 Il restera là à moins que vous ne l’invitiez（注意后面用 ne） alors que 然而；却 和 while 一样 Il est gros alors que son frère est maigre. pourvu que 主从复合句表示只要；独立句表示但愿 Nous irons faire du ski pourvu qu’il y ait de la neige（ait 是 avoir 的虚拟式现在时） Pourvu qu’il fasse beau demain ! （fasse 虚拟式现在时） Maison最常用，指一个很确实的建筑，和famille相关。 Demeure的概念会更宽泛，就是居住、住所，但是它的用法会偏向文学性，或者说更soutenu一些 Domicile法律性用词会更多，比如你的户籍所在地啊，投票时的登记地址，公司的官方所在地。 Résidence也是居所，但是它可以是有好几个的，而且有时会有豪华住宅的意味。 le jour où j’ai perdu ma montre, j’étais à Malta. La directrice m’a envoyé chercher des documents s’il fait beau, j’irai à pied au bureau il n’a parlé à personne durant tout le week-end //为什么不能用 aucun？ les contes sont de belles histoires qui se passent dans des endroits magnifique //为啥？ au cas où = si + conditionnel préparation TFI vocabulaire à étudier diriger Mettre au point Ant-infectieux 法语课堂实录 six/dix 后面加名词，x 一般不发音 特殊形容词 beau bel belle Nouveau nouvel nouvelle Vieux vieil vieille fou fol folle Mou mol molle 软弱的、温和 quoique = bien que quoi que je fasse, il est avec moi SubjonctifIndicatif1. Verbes + indicatif je constate que / je remarque que j’observe que je crois que / je pense que / je trouve que je suppose que / je’imagine que Je déclare que / je dis que j’affirme que J’espère que 2. Construction impersonnelles 无人称的 il est claire que il est certain que Après que Subjonctif1. verbes + subjonctif je souhaite que / je désire que / j’aimerais que J’ai peur que / je crains que / je redoute que je regrette que / je suis désolé que je veux que / j’ordonne que / j’exige（要求） que / je supplie（请求） que 2. Verbes a la forme negative je ne crois pas que je ne pense pas que Je ne trouve que 3. Construction impersonnelles il faut que il vaut mieux que il est important que il est dommage que","categories":[{"name":"le français","slug":"le-francais","permalink":"http://littlewuuu.com/categories/le-francais/"}],"tags":[{"name":"le français","slug":"le-francais","permalink":"http://littlewuuu.com/tags/le-francais/"}]}],"categories":[{"name":"le français","slug":"le-francais","permalink":"http://littlewuuu.com/categories/le-francais/"},{"name":"SKILLS","slug":"SKILLS","permalink":"http://littlewuuu.com/categories/SKILLS/"},{"name":"COURS","slug":"COURS","permalink":"http://littlewuuu.com/categories/COURS/"},{"name":"生活","slug":"生活","permalink":"http://littlewuuu.com/categories/%E7%94%9F%E6%B4%BB/"},{"name":"做饭区","slug":"做饭区","permalink":"http://littlewuuu.com/categories/%E5%81%9A%E9%A5%AD%E5%8C%BA/"}],"tags":[{"name":"le français","slug":"le-francais","permalink":"http://littlewuuu.com/tags/le-francais/"},{"name":"ECN","slug":"ECN","permalink":"http://littlewuuu.com/tags/ECN/"},{"name":"学了又忘的杂七杂八","slug":"学了又忘的杂七杂八","permalink":"http://littlewuuu.com/tags/%E5%AD%A6%E4%BA%86%E5%8F%88%E5%BF%98%E7%9A%84%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/"},{"name":"有点难学的","slug":"有点难学的","permalink":"http://littlewuuu.com/tags/%E6%9C%89%E7%82%B9%E9%9A%BE%E5%AD%A6%E7%9A%84/"},{"name":"ENG","slug":"ENG","permalink":"http://littlewuuu.com/tags/ENG/"},{"name":"好好生活","slug":"好好生活","permalink":"http://littlewuuu.com/tags/%E5%A5%BD%E5%A5%BD%E7%94%9F%E6%B4%BB/"},{"name":"到处玩","slug":"到处玩","permalink":"http://littlewuuu.com/tags/%E5%88%B0%E5%A4%84%E7%8E%A9/"},{"name":"一些奇奇怪怪的吃的","slug":"一些奇奇怪怪的吃的","permalink":"http://littlewuuu.com/tags/%E4%B8%80%E4%BA%9B%E5%A5%87%E5%A5%87%E6%80%AA%E6%80%AA%E7%9A%84%E5%90%83%E7%9A%84/"},{"name":"一些正正经经的吃的","slug":"一些正正经经的吃的","permalink":"http://littlewuuu.com/tags/%E4%B8%80%E4%BA%9B%E6%AD%A3%E6%AD%A3%E7%BB%8F%E7%BB%8F%E7%9A%84%E5%90%83%E7%9A%84/"}]}