{"meta":{"title":"hexo","subtitle":"","description":"","author":"Zilong WU","url":"http://littlewuuu.com","root":"/"},"pages":[{"title":"404 Not Found","date":"2022-12-01T16:16:40.700Z","updated":"2022-12-01T16:16:37.386Z","comments":false,"path":"/404.html","permalink":"http://littlewuuu.com/404.html","excerpt":"","text":""},{"title":"Repositories","date":"2022-02-20T19:44:10.874Z","updated":"2021-12-30T19:05:33.332Z","comments":false,"path":"repository/index.html","permalink":"http://littlewuuu.com/repository/index.html","excerpt":"","text":""},{"title":"关于我","date":"2022-02-20T19:43:53.380Z","updated":"2021-12-30T19:49:30.276Z","comments":false,"path":"about/index.html","permalink":"http://littlewuuu.com/about/index.html","excerpt":"","text":"个人详细介绍：个人不想详细介绍"},{"title":"友情链接","date":"2022-02-20T19:43:53.413Z","updated":"2021-12-30T15:37:54.580Z","comments":true,"path":"links/index.html","permalink":"http://littlewuuu.com/links/index.html","excerpt":"","text":""},{"title":"标签","date":"2022-02-20T19:43:53.405Z","updated":"2021-12-30T15:37:54.580Z","comments":false,"path":"tags/index.html","permalink":"http://littlewuuu.com/tags/index.html","excerpt":"","text":""},{"title":"分类","date":"2022-02-20T19:43:53.462Z","updated":"2021-12-30T15:37:54.580Z","comments":false,"path":"categories/index.html","permalink":"http://littlewuuu.com/categories/index.html","excerpt":"","text":""},{"title":"没怎么读过书 😄","date":"2022-02-20T19:43:53.393Z","updated":"2021-12-30T19:46:11.373Z","comments":false,"path":"books/index.html","permalink":"http://littlewuuu.com/books/index.html","excerpt":"","text":""}],"posts":[{"title":"Memoriser","slug":"Francaise/à memoriser","date":"2022-11-11T23:00:00.000Z","updated":"2022-11-15T16:22:57.690Z","comments":true,"path":"2022/11/12/Francaise/à memoriser/","link":"","permalink":"http://littlewuuu.com/2022/11/12/Francaise/a%CC%80%20memoriser/","excerpt":"","text":"les connecteurs logiques 用途 例子 ajouter une idée L’ADDITION Ensuite, de plus, en outre… De même que / sans compter que /ainsi que /non seulement… mais encore + indicatifQuant à + nom illustrer une idée, apporter un exemple L’ILLUSTRATION Par exemple /ainsi /en effetNotamment /en d’autres termes /c’est-à-dire /autrement dit réfuter l’argument opposé L’OPPOSITION Cependant /pourtant /en revanche /au contraire/ maistandis que, alors que + indicatifAu lieu de + infinitif ou nomContrairement à + nomContrairement à ce que + indicatif apporter des nuances, des paradoxes. LA CONCESSION Toutefois /néanmoins/pourtant/ cependantBien que / quoique /encore que + subjonctif Même si + indicatif (opposition et condition ou condition et hypothèse)C’est un bon réalisateur même s’il n’a pas reçu la Palme d’or.Il ne nous aurait rien dit même s’il l’avait su.Malgré / en dépit de + nom apporter des preuves, des justifications LA CAUSE Parce que / car / en effetPuisque / étant donné que /comme /sous prétexte que / du fait queGrâce à (ce que) + cause positiveÀ cause de (ce que) + cause négativeen raison de (ce que) + cause positive ou neutre montrer les résultats, les conséquences LA CONSÉQUENCE De sorte que / si bien que /de façon que / au point que /tellement… que, si…que… + indicatifFinalement /ainsi /voilà pourquoi /c’est pourquoi /par conséquent / c’est pour cela queAlors / donc / ainsi exprimer un but LE BUT Pour que /de peur que /de crainte que /afin que + subjonctifPour / dans le but de / afin de /en vue de + infinitif exprimer une condition LA CONDITION SiAu cas où + conditionnelÀ condition que + subjonctifEn admettant que / supposons que + subjonctifPourvu que + subjonctif (Exprime l’idée d’espoir) Les prépositions L’avion pour Londres va decoller. j’arrive en 10 minutes 表示十分钟内到 J’arrive à la salle pour 10 minutes 表示到教室后，呆在教室 10 分钟，然后离开 Je voyage en avion. les colis sont distribués par avion. Votre train part dans 3 minutes J’ai étudié pendant 4 ans （过去式） J’étudie depuis 4 ans （现在时）","categories":[{"name":"le français","slug":"le-francais","permalink":"http://littlewuuu.com/categories/le-francais/"}],"tags":[{"name":"le français","slug":"le-francais","permalink":"http://littlewuuu.com/tags/le-francais/"}]},{"title":"SQL渐进","slug":"BDONN/SQL渐进","date":"2022-10-29T22:00:00.000Z","updated":"2022-12-01T15:37:47.940Z","comments":true,"path":"2022/10/30/BDONN/SQL渐进/","link":"","permalink":"http://littlewuuu.com/2022/10/30/BDONN/SQL%E6%B8%90%E8%BF%9B/","excerpt":"","text":"索引 索引是一种数据结构（通常使用B-Tree），存储表的某一列的值。当查找的列有索引的时候，数据库会决定是否通过索引来查找。 索引存储了指向表中某一行的指针 数据库索引到底是什么，是怎样工作的？ 数据库索引的实现原理 SQL 执行顺序 12345678# 书写顺序select (distinct)from (join on)wheregroup byhaving order bylimit SQL语句的执行顺序是: from -&gt; join -&gt; on -&gt; where -&gt; group by-&gt;select 后面的聚合函数count,sum -&gt; having -&gt; distinct -&gt; order by -&gt; limit 50 题笔记 local/50questions § row_number, dense_rank, rank 是窗口函数 窗口函数","categories":[{"name":"SQL","slug":"SQL","permalink":"http://littlewuuu.com/categories/SQL/"}],"tags":[{"name":"SQL","slug":"SQL","permalink":"http://littlewuuu.com/tags/SQL/"}]},{"title":"遇到的专业词汇","slug":"遇到的专业词汇","date":"2022-10-02T22:00:00.000Z","updated":"2022-12-01T15:39:57.798Z","comments":true,"path":"2022/10/03/遇到的专业词汇/","link":"","permalink":"http://littlewuuu.com/2022/10/03/%E9%81%87%E5%88%B0%E7%9A%84%E4%B8%93%E4%B8%9A%E8%AF%8D%E6%B1%87/","excerpt":"","text":"I noticed starting with version 8 that the Java installer now prepends to （先于）the Windows PATH variable C:\\ProgramData\\Oracle\\Java\\javapath. If I suffixed[/'sʌfɪks/]（后缀到） it to the end of the Windows PATH variable then Java 8 was always being picked up (Windows searches the directories left-to-right in the PATH variable).","categories":[{"name":"SKILLS","slug":"SKILLS","permalink":"http://littlewuuu.com/categories/SKILLS/"}],"tags":[]},{"title":"GELOG","slug":"GELOG/GELOG_notes","date":"2022-10-02T22:00:00.000Z","updated":"2022-11-10T14:58:32.424Z","comments":true,"path":"2022/10/03/GELOG/GELOG_notes/","link":"","permalink":"http://littlewuuu.com/2022/10/03/GELOG/GELOG_notes/","excerpt":"","text":"I. Diagramme de cas d’utilisation 包含关系 &lt;&lt;inclut&gt;&gt; 包含关系描述的是一个用例需要某种功能，而该功能被另外一个用例定义，那么在用例的执行过程中，就可以调用已经定义好的用例。 扩展关系 一个用例（可选）扩展另一个用例（基本例）的功能，将一些常规的动作放在一个基本用例中，将可选的或只在特定条件下才执行的动作放在它的扩展用例中。 泛化关系（继承） 泛化关系指的是一般(父用例)与特殊(子用例)的关系。当多个用例共同拥有一种类似的结构和行为时，可以将它们的共性抽象为父用例，其他的用例作为泛化关系中的子用例。 可以用于 actor 和 case 依赖关系 30-09-2022 Agile 灵活的 Projet type(non agile) Expression de besoins (Buget) Cahier des charges (Equipe Projet Planning V0) Specification generales (Planning Chiffrage) Specification détaillées Implém. Valitation (correction) II. Diagrammes de classes et d’objets Class 写在哪一边就表示哪一边有几个实例 1 : un et un seul 0…1 : zéro ou un M…N : de M à N ** ou 0…* *: de zéro à plusieurs 1…* : de un à plusieurs privé (-) , protégé (#), public (+) 关联关系用线表示就好了，比如司机和车（开车） Objet III. Diagrame de sequence https://blog.csdn.net/fly_zxy/article/details/80911942 所有的执行者都用方框表示。 之间的消息通讯用实线箭头表示 组合片段 DIAGRAMMES DE COMMUNICATION（Collaboration） IV. Diagrammes d’états-transitions V. Diagrammes d’activité https://www.cnblogs.com/wolf-sun/p/3432135.html 2022-10-14 Cours d’initiation au DevOps","categories":[{"name":"COURS","slug":"COURS","permalink":"http://littlewuuu.com/categories/COURS/"}],"tags":[{"name":"ECN","slug":"ECN","permalink":"http://littlewuuu.com/tags/ECN/"}]},{"title":"环境变量修改","slug":"MacOS的PATH修改","date":"2022-09-21T22:00:00.000Z","updated":"2022-12-01T15:39:36.685Z","comments":true,"path":"2022/09/22/MacOS的PATH修改/","link":"","permalink":"http://littlewuuu.com/2022/09/22/MacOS%E7%9A%84PATH%E4%BF%AE%E6%94%B9/","excerpt":"","text":"MacOS PATH 环境变量相关的文件 按下述顺序加载： /etc/profile /etc/paths /etc/bashrc ~/.bash_profile 或 ~/.bashrc ~/.bash_login /etc/profile, /etc/paths, /etc/bashrc 是系统级别配置文件，系统启动就会加载。 后面几个是当前用户级的环境变量，按照从前往后的顺序读取，如果 ~/.bash_profile文件存在，则后面的几个文件就会被忽略不读，如果~/.bash_profile文件不存在，才会以此类推读取后面的文件。 ~/.bashrc没有上述规则，它是bash shell打开的时候载入的。 全局修改 用户级别修改 一般都是修改~/.bash_profile文件（Linux中是~/.bashrc，而Mac OS是~/.bash_profile） 检查是不是在环境变量里了 1echo $PATH 打开相应文件夹 1open ~/.bash_profile 如果遇到 permission denied，使用 1sudo chown username ~/.bash_profile 修改用户权限 添加后保存 12# 注释export &quot;PATH=路径:$PATH&quot; 输入使修改生效 1source ~/.bash_profile","categories":[{"name":"SKILLS","slug":"SKILLS","permalink":"http://littlewuuu.com/categories/SKILLS/"}],"tags":[{"name":"学了又忘的杂七杂八","slug":"学了又忘的杂七杂八","permalink":"http://littlewuuu.com/tags/%E5%AD%A6%E4%BA%86%E5%8F%88%E5%BF%98%E7%9A%84%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/"}]},{"title":"Maven&MyBatis","slug":"黑马/4-Maven&MyBatis","date":"2022-09-21T22:00:00.000Z","updated":"2022-12-01T15:33:04.439Z","comments":true,"path":"2022/09/22/黑马/4-Maven&MyBatis/","link":"","permalink":"http://littlewuuu.com/2022/09/22/%E9%BB%91%E9%A9%AC/4-Maven&MyBatis/","excerpt":"","text":"Maven&amp;MyBatis 目标 能够使用Maven进行项目的管理 能够完成Mybatis代理方式查询数据 能够理解Mybatis核心配置文件的配置 1，Maven Maven是专门用于管理和构建Java项目的工具，它的主要功能有： 提供了一套标准化的项目结构 提供了一套标准化的构建流程（编译，测试，打包，发布……） 提供了一套依赖管理机制 标准化的项目结构： 项目结构我们都知道，每一个开发工具（IDE）都有自己不同的项目结构，它们互相之间不通用。我再eclipse中创建的目录，无法在idea中进行使用，这就造成了很大的不方便，如下图:前两个是以后开发经常使用的开发工具 而Maven提供了一套标准化的项目结构，所有的IDE使用Maven构建的项目完全一样，所以IDE创建的Maven项目可以通用。如下图右边就是Maven构建的项目结构。 标准化的构建流程： 如上图所示我们开发了一套系统，代码需要进行编译、测试、打包、发布，这些操作如果需要反复进行就显得特别麻烦，而Maven提供了一套简单的命令来完成项目构建。 依赖管理： 依赖管理其实就是管理你项目所依赖的第三方资源（jar包、插件）。如之前我们项目中需要使用JDBC和Druid的话，就需要去网上下载对应的依赖包（当前之前是老师已经下载好提供给大家了），复制到项目中，还要将jar包加入工作环境这一系列的操作。如下图所示 而Maven使用标准的 坐标 配置来管理各种依赖，只需要简单的配置就可以完成依赖管理。 如上图右边所示就是mysql驱动包的坐标，在项目中只需要写这段配置，其他都不需要我们担心，Maven都帮我们进行操作了。 市面上有很多构建工具，而Maven依旧还是主流构建工具，如下图是常用构建工具的使用占比 1.1 Maven简介 Apache Maven 是一个项目管理和构建工具，它基于项目对象模型(POM)的概念，通过一小段描述信息来管理项目的构建、报告和文档。 官网 ：http://maven.apache.org/ 通过上面的描述大家只需要知道Maven是一个工具即可。Apache 是一个开源组织，将来我们会学习很多Apache提供的项目。 1.1.1 Maven模型 项目对象模型 (Project Object Model) 依赖管理模型(Dependency) 插件(Plugin) 如上图所示就是Maven的模型，而我们先看紫色框框起来的部分，他就是用来完成 标准化构建流程 。如我们需要编译，Maven提供了一个编译插件供我们使用，我们需要打包，Maven就提供了一个打包插件提供我们使用等。 上图中紫色框起来的部分，项目对象模型就是将我们自己抽象成一个对象模型，有自己专属的坐标，如下图所示是一个Maven项目： 依赖管理模型则是使用坐标来描述当前项目依赖哪儿些第三方jar包，如下图所示 上述Maven模型图中还有一部分是仓库。如何理解仓库呢？ 1.1.2 仓库 大家想想这样的场景，我们创建Maven项目，在项目中使用坐标来指定项目的依赖，那么依赖的jar包到底存储在什么地方呢？其实依赖jar包是存储在我们的本地仓库中。而项目运行时从本地仓库中拿需要的依赖jar包。 仓库分类： 本地仓库：自己计算机上的一个目录 中央仓库：由Maven团队维护的全球唯一的仓库 地址： https://repo1.maven.org/maven2/ 远程仓库(私服)：一般由公司团队搭建的私有仓库 今天我们只学习远程仓库的使用，并不会搭建。 当项目中使用坐标引入对应依赖jar包后，首先会查找本地仓库中是否有对应的jar包： 如果有，则在项目直接引用; 如果没有，则去中央仓库中下载对应的jar包到本地仓库。 如果还可以搭建远程仓库，将来jar包的查找顺序则变为： 本地仓库 --&gt; 远程仓库–&gt; 中央仓库 1.2 Maven安装配置 解压 apache-maven-3.6.1.rar 既安装完成 建议解压缩到没有中文、特殊字符的路径下。如课程中解压缩到 D:\\software 下。 解压缩后的目录结构如下： bin目录 ： 存放的是可执行命令。mvn 命令重点关注。 conf目录 ：存放Maven的配置文件。settings.xml 配置文件后期需要修改。 lib目录 ：存放Maven依赖的jar包。Maven也是使用java开发的，所以它也依赖其他的jar包。 配置环境变量 MAVEN_HOME 为安装路径的bin目录 此电脑 右键 --&gt; 高级系统设置 --&gt; 高级 --&gt; 环境变量 在系统变量处新建一个变量 MAVEN_HOME 在 Path 中进行配置 打开命令提示符进行验证，出现如图所示表示安装成功 配置本地仓库 修改 conf/settings.xml 中的 为一个指定目录作为本地仓库，用来存储jar包。 配置阿里云私服 中央仓库在国外，所以下载jar包速度可能比较慢，而阿里公司提供了一个远程仓库，里面基本也都有开源项目的jar包。 修改 conf/settings.xml 中的 标签，为其添加如下子标签： 123456&lt;mirror&gt; &lt;id&gt;alimaven&lt;/id&gt; &lt;name&gt;aliyun maven&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;/mirror&gt; 1.3 Maven基本使用 1.3.1 Maven 常用命令 compile ：编译 clean：清理 test：测试 package：打包 install：安装 命令演示： 在 资料\\代码\\maven-project 提供了一个使用Maven构建的项目，项目结构如下： 而我们使用上面命令需要在磁盘上进入到项目的 pom.xml 目录下，打开命令提示符 编译命令演示： 1compile ：编译 执行上述命令可以看到： 从阿里云下载编译需要的插件的jar包，在本地仓库也能看到下载好的插件 在项目下会生成一个 target 目录 同时在项目下会出现一个 target 目录，编译后的字节码文件就放在该目录下 清理命令演示： 1mvn clean 执行上述命令可以看到 从阿里云下载清理需要的插件jar包 删除项目下的 target 目录 打包命令演示： 1mvn package 执行上述命令可以看到： 从阿里云下载打包需要的插件jar包 在项目的 terget 目录下有一个jar包（将当前项目打成的jar包） 测试命令演示： 1mvn test 该命令会执行所有的测试代码。执行上述命令效果如下 安装命令演示： 1mvn install 该命令会将当前项目打成jar包，并安装到本地仓库。执行完上述命令后到本地仓库查看结果如下： 1.3.2 Maven 生命周期 Maven 构建项目生命周期描述的是一次构建过程经历经历了多少个事件 Maven 对项目构建的生命周期划分为3套： clean ：清理工作。 default ：核心工作，例如编译，测试，打包，安装等。 site ： 产生报告，发布站点等。这套声明周期一般不会使用。 同一套生命周期内，执行后边的命令，前面的所有命令会自动执行。例如默认（default）生命周期如下： 当我们执行 install（安装）命令时，它会先执行 compile命令，再执行 test 命令，再执行 package 命令，最后执行 install 命令。 当我们执行 package （打包）命令时，它会先执行 compile 命令，再执行 test 命令，最后执行 package 命令。 默认的生命周期也有对应的很多命令，其他的一般都不会使用，我们只关注常用的： 1.4 IDEA使用Maven 以后开发中我们肯定会在高级开发工具中使用Maven管理项目，而我们常用的高级开发工具是IDEA，所以接下来我们会讲解Maven在IDEA中的使用。 1.4.1 IDEA配置Maven环境 我们需要先在IDEA中配置Maven环境： 选择 IDEA中 File --&gt; Settings 搜索 maven 设置 IDEA 使用本地安装的 Maven，并修改配置文件路径 1.4.2 Maven 坐标详解 什么是坐标？ Maven 中的坐标是资源的唯一标识 使用坐标来定义项目或引入项目中需要的依赖 Maven 坐标主要组成 groupId：定义当前Maven项目隶属组织名称（通常是域名反写，例如：com.itheima） artifactId：定义当前Maven项目名称（通常是模块名称，例如 order-service、goods-service） version：定义当前项目版本号 如下图就是使用坐标表示一个项目： 注意： 上面所说的资源可以是插件、依赖、当前项目。 我们的项目如果被其他的项目依赖时，也是需要坐标来引入的。 1.4.3 IDEA 创建 Maven项目 创建模块，选择Maven，点击Next 填写模块名称，坐标信息，点击finish，创建完成 创建好的项目目录结构如下： 编写 HelloWorld，并运行 1.4.4 IDEA 导入 Maven项目 大家在学习时可能需要看老师的代码，当然也就需要将老师的代码导入到自己的IDEA中。我们可以通过以下步骤进行项目的导入： 选择右侧Maven面板，点击 + 号 选中对应项目的pom.xml文件，双击即可 如果没有Maven面板，选择 View --&gt; Appearance --&gt; Tool Window Bars 可以通过下图所示进行命令的操作： 配置 Maven-Helper 插件 选择 IDEA中 File --&gt; Settings 选择 Plugins 搜索 Maven，选择第一个 Maven Helper，点击Install安装，弹出面板中点击Accept 重启 IDEA 安装完该插件后可以通过 选中项目右键进行相关命令操作，如下图所示： 1.5 依赖管理 1.5.1 使用坐标引入jar包 使用坐标引入jar包的步骤： 在项目的 pom.xml 中编写 标签 在 标签中 使用 引入坐标 定义坐标的 groupId，artifactId，version 点击刷新按钮，使坐标生效 注意： 具体的坐标我们可以到如下网站进行搜索 https://mvnrepository.com/ 快捷方式导入jar包的坐标： 每次需要引入jar包，都去对应的网站进行搜索（搜索的是 pom.xml里面写的格式）是比较麻烦的，接下来给大家介绍一种快捷引入坐标的方式 在 pom.xml 中 按 alt + insert，选择 Dependency 在弹出的面板中搜索对应坐标，然后双击选中对应坐标 点击刷新按钮，使坐标生效 自动导入设置： 上面每次操作都需要点击刷新按钮，让引入的坐标生效。当然我们也可以通过设置让其自动完成 选择 IDEA中 File --&gt; Settings 在弹出的面板中找到 Build Tools 选择 Any changes，点击 ok 即可生效 1.5.2 依赖范围 通过设置坐标的依赖范围(scope)，可以设置 对应jar包的作用范围：编译环境、测试环境、运行环境。 如下图所示给 junit 依赖通过 scope 标签指定依赖的作用范围。 那么这个依赖就只能作用在测试环境，其他环境下不能使用。 那么 scope 都可以有哪些取值呢？ 依赖范围 编译classpath 测试classpath 运行classpath 例子 compile Y Y Y logback test - Y - Junit provided Y Y - servlet-api runtime - Y Y jdbc驱动 system Y Y - 存储在本地的jar包 compile ：作用于编译环境、测试环境、运行环境。 test ： 作用于测试环境。典型的就是Junit坐标，以后使用Junit时，都会将scope指定为该值 provided ：作用于编译环境、测试环境。我们后面会学习 servlet-api ，在使用它时，必须将 scope 设置为该值，不然运行时就会报错 runtime ： 作用于测试环境、运行环境。jdbc驱动一般将 scope 设置为该值，当然不设置也没有任何问题 注意： 如果引入坐标不指定 scope 标签时，默认就是 compile 值。以后大部分jar包都是使用默认值。 2，Mybatis 2.1 Mybatis概述 2.1.1 Mybatis概念 MyBatis 是一款优秀的持久层框架，用于简化 JDBC 开发 MyBatis 本是 Apache 的一个开源项目iBatis, 2010年这个项目由apache software foundation 迁移到了google code，并且改名为MyBatis 。2013年11月迁移到Github 官网：https://mybatis.org/mybatis-3/zh/index.html 持久层： 负责将数据到保存到数据库的那一层代码。 以后开发我们会将操作数据库的 Java 代码作为持久层。而 Mybatis 就是对 JDBC 代码进行了封装。 JavaEE三层架构：表现层、业务层、持久层 三层架构在后期会给大家进行讲解，今天先简单的了解下即可。 框架： 框架就是一个半成品软件，是一套可重用的、通用的、软件基础代码模型 在框架的基础之上构建软件编写更加高效、规范、通用、可扩展 了解了什么是Mybatis后，接下来说说以前 JDBC代码 的缺点以及Mybatis又是如何解决的。 2.1.2 JDBC 缺点 下面是 JDBC 代码，我们通过该代码分析都存在什么缺点： 这里讲的不好，可以参考尚硅谷讲的 JDBC，DAO 设计模式 硬编码 注册驱动、获取连接 上图标1的代码有很多字符串，而这些是连接数据库的四个基本信息，以后如果要将Mysql数据库换成其他的关系型数据库的话，这四个地方都需要修改，如果放在此处就意味着要修改我们的源代码。 SQL语句 上图标2的代码。如果表结构发生变化，SQL语句就要进行更改。这也不方便后期的维护。 操作繁琐 手动设置参数 手动封装结果集 上图标4的代码是对查询到的数据进行封装，而这部分代码是没有什么技术含量，而且特别耗费时间的。 2.1.3 Mybatis 优化 硬编码可以配置到配置文件: mybatis.propert 操作繁琐的地方mybatis都自动完成 如图所示 下图是持久层框架的使用占比。 2.2 Mybatis 快速入门 需求：查询 user 表中所有的数据 创建 user 数据库表，添加数据 12345678910111213141516create database mybatis;use mybatis;drop table if exists tb_user;create table tb_user( id int primary key auto_increment, username varchar(20), password varchar(20), gender char(1), addr varchar(30));INSERT INTO tb_user VALUES (1, &#x27;zhangsan&#x27;, &#x27;123&#x27;, &#x27;男&#x27;, &#x27;北京&#x27;);INSERT INTO tb_user VALUES (2, &#x27;李四&#x27;, &#x27;234&#x27;, &#x27;女&#x27;, &#x27;天津&#x27;);INSERT INTO tb_user VALUES (3, &#x27;王五&#x27;, &#x27;11&#x27;, &#x27;男&#x27;, &#x27;西安&#x27;); 创建模块，导入坐标 在创建好的模块中的 pom.xml 配置文件中添加依赖的坐标 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;dependencies&gt; &lt;!--mybatis 依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.5.5&lt;/version&gt; &lt;/dependency&gt; &lt;!--mysql 驱动--&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.46&lt;/version&gt; &lt;/dependency&gt; &lt;!--junit 单元测试--&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.13&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- 添加slf4j日志api --&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt; &lt;version&gt;1.7.20&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 添加logback-classic依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt; &lt;artifactId&gt;logback-classic&lt;/artifactId&gt; &lt;version&gt;1.2.3&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 添加logback-core依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt; &lt;artifactId&gt;logback-core&lt;/artifactId&gt; &lt;version&gt;1.2.3&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 注意：需要在项目的 resources 目录下创建logback的配置文件 编写 MyBatis 核心配置文件 – &gt; 替换连接信息 解决硬编码问题 在模块下的 resources 目录下创建mybatis的配置文件 mybatis-config.xml，内容如下： 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt; &lt;typeAliases&gt; &lt;package name=&quot;com.itheima.pojo&quot;/&gt; &lt;/typeAliases&gt; &lt;!-- environments：配置数据库连接环境信息。可以配置多个environment，通过【default】属性切换不同的environment --&gt; &lt;environments default=&quot;development&quot;&gt; &lt;environment id=&quot;development&quot;&gt; &lt;transactionManager type=&quot;JDBC&quot;/&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;!--数据库连接信息--&gt; &lt;property name=&quot;driver&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql:///mybatis?useSSL=false&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;1234&quot;/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;environment id=&quot;test&quot;&gt; &lt;transactionManager type=&quot;JDBC&quot;/&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;!--数据库连接信息--&gt; &lt;property name=&quot;driver&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql:///mybatis?useSSL=false&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;1234&quot;/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;mappers&gt; &lt;!--加载sql映射文件--&gt; &lt;mapper resource=&quot;UserMapper.xml&quot;/&gt; &lt;/mappers&gt;&lt;/configuration&gt; 编写 SQL 映射文件 --&gt; 统一管理sql语句，解决硬编码问题 在模块的 resources 目录下创建映射配置文件 UserMapper.xml，内容如下： 1234567&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;test&quot;&gt; &lt;select id=&quot;selectAll&quot; resultType=&quot;com.itheima.pojo.User&quot;&gt; select * from tb_user; &lt;/select&gt;&lt;/mapper&gt; 编码 在 com.itheima.pojo 包下创建 User类 123456789public class User &#123; private int id; private String username; private String password; private String gender; private String addr; //省略了 setter 和 getter toString()&#125; 在 com.itheima 包下编写 MybatisDemo 测试类 1234567891011121314151617public class MyBatisDemo &#123; public static void main(String[] args) throws IOException &#123; //1. 加载mybatis的核心配置文件，获取 SqlSessionFactory，只用写一次 String resource = &quot;mybatis-config.xml&quot;; InputStream inputStream = Resources.getResourceAsStream(resource); SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); //2. 获取SqlSession对象，用它来执行sql SqlSession sqlSession = sqlSessionFactory.openSession(); //3. 执行sql List&lt;User&gt; users = sqlSession.selectList(&quot;test.selectAll&quot;); //参数是一个字符串，该字符串必须是映射配置文件的namespace.id System.out.println(users); //4. 释放资源 sqlSession.close(); &#125;&#125; 解决SQL映射文件的警告提示： 在入门案例映射配置文件中存在报红的情况。问题如下： 产生的原因：Idea和数据库没有建立连接，不识别表信息。但是大家一定要记住，它并不影响程序的执行。 解决方式：在Idea中配置MySQL数据库连接。 IDEA中配置MySQL数据库连接 点击IDEA右边框的 Database ，在展开的界面点击 + 选择 Data Source ，再选择 MySQL 在弹出的界面进行基本信息的填写 点击完成后就能看到如下界面 而此界面就和 navicat 工具一样可以进行数据库的操作。也可以编写SQL语句 2.3 Mapper代理开发 2.3.1 Mapper代理开发概述 之前我们写的代码是基本使用方式，它也存在硬编码的问题，如下： 这里调用 selectList() 方法传递的参数是映射配置文件中的 namespace.id值。这样写也不便于后期的维护。如果使用 Mapper 代理方式（如下图）则不存在硬编码问题。 通过上面的描述可以看出 Mapper 代理方式的目的： 解决原生方式中的硬编码 简化后期执行SQL Mybatis 官网也是推荐使用 Mapper 代理的方式。下图是截止官网的图片 2.3.2 使用Mapper代理要求 使用Mapper代理方式，必须满足以下要求： 定义与SQL映射文件同名的Mapper接口，并且将Mapper接口和SQL映射文件放置在同一目录下(编译以后)。如下图： 注意：在 resources 下面只能建立 directory，不能使用 com.itmeima.mapper 这样，要使用 com/itmeima/mapper 设置 SQL 映射文件 (.xml) 的 namespace 属性为 Mapper 接口全限定名 在 Mapper 接口中定义方法，方法名就是SQL映射文件中sql语句的id，并保持参数类型和返回值类型一致 2.3.3 案例代码实现 在 com.itheima.mapper 包下创建 UserMapper接口，代码如下： 1234public interface UserMapper &#123; List&lt;User&gt; selectAll(); User selectById(int id);&#125; 在 resources 下创建 com/itheima/mapper 目录，并在该目录下创建 UserMapper.xml 映射配置文件 123456789&lt;!-- namespace:名称空间。必须是对应接口的全限定名--&gt;&lt;mapper namespace=&quot;com.itheima.mapper.UserMapper&quot;&gt; &lt;select id=&quot;selectAll&quot; resultType=&quot;com.itheima.pojo.User&quot;&gt; select * from tb_user; &lt;/select&gt;&lt;/mapper&gt; 在 com.itheima 包下创建 MybatisDemo2 测试类，代码如下： 123456789101112131415161718192021222324/** * Mybatis 代理开发 */public class MyBatisDemo2 &#123; public static void main(String[] args) throws IOException &#123; //1. 加载mybatis的核心配置文件，获取 SqlSessionFactory String resource = &quot;mybatis-config.xml&quot;; InputStream inputStream = Resources.getResourceAsStream(resource); SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); //2. 获取SqlSession对象，用它来执行sql SqlSession sqlSession = sqlSessionFactory.openSession(); //3. 执行sql //3.1 获取UserMapper接口的代理对象 UserMapper userMapper = sqlSession.getMapper(UserMapper.class); List&lt;User&gt; users = userMapper.selectAll(); System.out.println(users); //4. 释放资源 sqlSession.close(); &#125;&#125; 注意： 如果 Mapper 接口名称和 SQL 映射文件名称相同，并在同一目录下，则可以使用包扫描的方式简化 SQL 映射文件的加载。也就是将核心配置文件的加载映射配置文件的配置修改为 123456&lt;mappers&gt; &lt;!--加载sql映射文件--&gt; &lt;!-- &lt;mapper resource=&quot;com/itheima/mapper/UserMapper.xml&quot;/&gt;--&gt; &lt;!--Mapper代理方式，简化版--&gt; &lt;package name=&quot;com.itheima.mapper&quot;/&gt;&lt;/mappers&gt; 2.4 核心配置文件 核心配置文件中现有的配置之前已经给大家进行了解释，而核心配置文件中还可以配置很多内容。我们可以通过查询官网看可以配置的内容 接下来我们先对里面的一些配置进行讲解。 注意：配置需要遵守顺序 2.4.1 多环境配置 在核心配置文件的 environments 标签中其实是可以配置多个 environment ，使用 id 给每段环境起名，在 environments 中使用 default='环境id' 来指定使用哪儿段配置。我们一般就配置一个 environment 即可。 1234567891011121314151617181920212223&lt;environments default=&quot;development&quot;&gt; &lt;environment id=&quot;development&quot;&gt; &lt;transactionManager type=&quot;JDBC&quot;/&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;!--数据库连接信息--&gt; &lt;property name=&quot;driver&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql:///mybatis?useSSL=false&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;1234&quot;/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;environment id=&quot;test&quot;&gt; &lt;transactionManager type=&quot;JDBC&quot;/&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;!--数据库连接信息--&gt; &lt;property name=&quot;driver&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql:///mybatis?useSSL=false&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;1234&quot;/&gt; &lt;/dataSource&gt; &lt;/environment&gt;&lt;/environments&gt; 2.4.2 类型别名 在映射配置文件中的 resultType 属性需要配置数据封装的类型（类的全限定名）。而每次这样写是特别麻烦的，Mybatis 提供了 类型别名(typeAliases) 可以简化这部分的书写。 首先需要现在核心配置文件中配置类型别名，也就意味着给pojo包下所有的类起了别名（别名就是类名），不区分大小写。内容如下： 1234&lt;typeAliases&gt; &lt;!--name属性的值是实体类所在包--&gt; &lt;package name=&quot;com.itheima.pojo&quot;/&gt; &lt;/typeAliases&gt; 通过上述的配置，我们就可以简化映射配置文件中 resultType 属性值的编写 12345&lt;mapper namespace=&quot;com.itheima.mapper.UserMapper&quot;&gt; &lt;select id=&quot;selectAll&quot; resultType=&quot;user&quot;&gt; select * from tb_user; &lt;/select&gt;&lt;/mapper&gt; 来源：it 黑马 JavaWeb 教程","categories":[{"name":"Java","slug":"Java","permalink":"http://littlewuuu.com/categories/Java/"}],"tags":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://littlewuuu.com/tags/JavaWeb/"}]},{"title":"JBDC","slug":"JDBC/尚硅谷_宋红康_JDBC","date":"2022-08-29T22:00:00.000Z","updated":"2022-12-01T15:43:30.564Z","comments":true,"path":"2022/08/30/JDBC/尚硅谷_宋红康_JDBC/","link":"","permalink":"http://littlewuuu.com/2022/08/30/JDBC/%E5%B0%9A%E7%A1%85%E8%B0%B7_%E5%AE%8B%E7%BA%A2%E5%BA%B7_JDBC/","excerpt":"","text":"JDBC核心技术 0. 一些常识 数据库中用下划线，Java 中用驼峰命名，因为数据库不区分大小写。 Java 的类对应数据库中的表，java类里面基本数据类型建议使用包装类型（int-&gt; integer），因为 int 默认值是 0，在数据库中有含义的；integer 初始值为 null。 第1章：JDBC概述 1.1 数据的持久化 持久化(persistence)：把数据保存到可掉电式存储设备中以供之后使用。大多数情况下，特别是企业级应用，数据持久化意味着将内存中的数据保存到硬盘上加以”固化”，而持久化的实现过程大多通过各种关系数据库来完成。 持久化的主要应用是将内存中的数据存储在关系型数据库中，当然也可以存储在磁盘文件、XML数据文件中。 1.2 Java中的数据存储技术 在Java中，数据库存取技术可分为如下几类： JDBC直接访问数据库 JDO (Java Data Object )技术 第三方O/R工具，如Hibernate, Mybatis 等 JDBC是java访问数据库的基石，JDO、Hibernate、MyBatis等只是更好的封装了JDBC。 1.3 JDBC介绍 JDBC(Java Database Connectivity)是一个独立于特定数据库管理系统、通用的SQL数据库存取和操作的公共接口（一组API），定义了用来访问数据库的标准Java类库，（java.sql,javax.sql）使用这些类库可以以一种标准的方法、方便地访问数据库资源。 JDBC为访问不同的数据库提供了一种统一的途径，为开发者屏蔽了一些细节问题。 JDBC的目标是使Java程序员使用JDBC可以连接任何提供了JDBC驱动程序的数据库系统，这样就使得程序员无需对特定的数据库系统的特点有过多的了解，从而大大简化和加快了开发过程。 如果没有JDBC，那么Java程序访问数据库时是这样的： 有了JDBC，Java程序访问数据库时是这样的： 总结如下： 1.4 JDBC体系结构 JDBC接口（API）包括两个层次： 面向应用的API：Java API，抽象接口，供应用程序开发人员使用（连接数据库，执行SQL语句，获得结果）。 面向数据库的API：Java Driver API，供开发商开发数据库驱动程序用。 JDBC是sun公司提供一套用于数据库操作的接口，java程序员只需要面向这套接口编程即可。 不同的数据库厂商，需要针对这套接口，提供不同实现。不同的实现的集合，即为不同数据库的驱动。 ————面向接口编程 1.5 JDBC程序编写步骤 补充：ODBC(Open Database Connectivity，开放式数据库连接)，是微软在Windows平台下推出的。使用者在程序中只需要调用ODBC API，由 ODBC 驱动程序将调用转换成为对特定的数据库的调用请求。 第2章：获取数据库连接 2.1 要素一：Driver接口实现类 2.1.1 Driver接口介绍 java.sql.Driver 接口是所有 JDBC 驱动程序需要实现的接口。这个接口是提供给数据库厂商使用的，不同数据库厂商提供不同的实现。 在程序中不需要直接去访问实现了 Driver 接口的类，而是由驱动程序管理器类(java.sql.DriverManager)去调用这些Driver实现。 Oracle的驱动：oracle.jdbc.driver.OracleDriver mySql的驱动： com.mysql.jdbc.Driver 将上述jar包拷贝到Java工程的一个目录中，习惯上新建一个lib文件夹。 在驱动jar上右键–&gt;Build Path–&gt;Add to Build Path 注意：如果是Dynamic Web Project（动态的web项目）话，则是把驱动jar放到WebContent（有的开发工具叫WebRoot）目录中的WEB-INF目录中的lib目录下即可 2.1.2 加载与注册JDBC驱动 加载驱动：加载 JDBC 驱动需调用 Class 类的静态方法 forName()，向其传递要加载的 JDBC 驱动的类名 Class.forName(“com.mysql.jdbc.Driver”); 注册驱动：DriverManager 类是驱动程序管理器类，负责管理驱动程序 使用DriverManager.registerDriver(com.mysql.jdbc.Driver)来注册驱动 通常不用显式调用 DriverManager 类的 registerDriver() 方法来注册驱动程序类的实例，因为 Driver 接口的驱动程序类都包含了静态代码块，在这个静态代码块中，会调用 DriverManager.registerDriver() 方法来注册自身的一个实例。下图是MySQL的Driver实现类的源码： 2.2 要素二：URL JDBC URL 用于标识一个被注册的驱动程序，驱动程序管理器通过这个 URL 选择正确的驱动程序，从而建立到数据库的连接。 JDBC URL的标准由三部分组成，各部分间用冒号分隔。 jdbc:子协议:子名称 协议：JDBC URL中的协议总是jdbc 子协议：子协议用于标识一个数据库驱动程序 子名称：一种标识数据库的方法。子名称可以依不同的子协议而变化，用子名称的目的是为了定位数据库提供足够的信息。包含主机名(对应服务端的ip地址)，端口号，数据库名 举例： 几种常用数据库的 JDBC URL MySQL的连接URL编写方式： jdbc:mysql://主机名称:mysql服务端口号/数据库名称?参数=值&amp;参数=值 jdbc:mysql://localhost:3306/atguigu jdbc:mysql://localhost:3306/atguigu**?useUnicode=true&amp;characterEncoding=utf8**（如果JDBC程序与服务器端的字符集不一致，会导致乱码，那么可以通过参数指定服务器端的字符集） jdbc:mysql://localhost:3306/atguigu?user=root&amp;password=123456 Oracle 9i的连接URL编写方式： jdbc:oracle:thin:@主机名称:oracle服务端口号:数据库名称 jdbc:oracle:thin:@localhost:1521:atguigu SQLServer的连接URL编写方式： jdbc:sqlserver://主机名称:sqlserver服务端口号:DatabaseName=数据库名称 jdbc:sqlserver://localhost:1433:DatabaseName=atguigu 2.3 要素三：用户名和密码 user,password可以用“属性名=属性值”方式告诉数据库 可以调用 DriverManager 类的 getConnection() 方法建立到数据库的连接 2.4 数据库连接方式举例 2.4.1 连接方式一 12345678910111213141516171819202122@Test public void testConnection1() &#123; try &#123; //1.提供java.sql.Driver接口实现类的对象 Driver driver = null; driver = new com.mysql.jdbc.Driver(); //2.提供url，指明具体操作的数据 String url = &quot;jdbc:mysql://localhost:3306/test&quot;; //3.提供Properties的对象，指明用户名和密码 Properties info = new Properties(); info.setProperty(&quot;user&quot;, &quot;root&quot;); info.setProperty(&quot;password&quot;, &quot;abc123&quot;); //4.调用driver的connect()，获取连接 Connection conn = driver.connect(url, info); System.out.println(conn); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; 说明：上述代码中显式出现了第三方数据库的API 2.4.2 连接方式二 123456789101112131415161718192021222324@Test public void testConnection2() &#123; try &#123; //1.实例化Driver String className = &quot;com.mysql.jdbc.Driver&quot;; Class clazz = Class.forName(className); Driver driver = (Driver) clazz.newInstance(); //2.提供url，指明具体操作的数据 String url = &quot;jdbc:mysql://localhost:3306/test&quot;; //3.提供Properties的对象，指明用户名和密码 Properties info = new Properties(); info.setProperty(&quot;user&quot;, &quot;root&quot;); info.setProperty(&quot;password&quot;, &quot;abc123&quot;); //4.调用driver的connect()，获取连接 Connection conn = driver.connect(url, info); System.out.println(conn); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; 说明：相较于方式一，这里使用反射实例化Driver，不在代码中体现第三方数据库的API。体现了面向接口编程思想。 2.4.3 连接方式三 12345678910111213141516171819202122@Test public void testConnection3() &#123; try &#123; //1.数据库连接的4个基本要素： String url = &quot;jdbc:mysql://localhost:3306/test&quot;; String user = &quot;root&quot;; String password = &quot;abc123&quot;; String driverName = &quot;com.mysql.jdbc.Driver&quot;; //2.实例化Driver Class clazz = Class.forName(driverName); Driver driver = (Driver) clazz.newInstance(); //3.注册驱动 DriverManager.registerDriver(driver); //4.获取连接 Connection conn = DriverManager.getConnection(url, user, password); System.out.println(conn); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; 说明：使用DriverManager实现数据库的连接。体会获取连接必要的4个基本要素。 2.4.4 连接方式四 12345678910111213141516171819202122232425262728293031323334353637@Test public void testConnection4() &#123; try &#123; //1.数据库连接的4个基本要素： String url = &quot;jdbc:mysql://localhost:3306/test&quot;; String user = &quot;root&quot;; String password = &quot;abc123&quot;; String driverName = &quot;com.mysql.jdbc.Driver&quot;; //2.加载驱动 （①实例化Driver ②注册驱动） Class.forName(driverName); //Driver driver = (Driver) clazz.newInstance(); //3.注册驱动 //DriverManager.registerDriver(driver); /* 可以注释掉上述代码的原因，是因为在mysql的Driver类中声明有： static &#123; try &#123; DriverManager.registerDriver(new Driver()); &#125; catch (SQLException var1) &#123; throw new RuntimeException(&quot;Can&#x27;t register driver!&quot;); &#125; &#125; */ //3.获取连接 Connection conn = DriverManager.getConnection(url, user, password); System.out.println(conn); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; 说明：不必显式的注册驱动了。因为在DriverManager的源码中已经存在静态代码块，实现了驱动的注册。 2.4.5 连接方式五(最终版) 123456789101112131415161718192021@Test public void testConnection5() throws Exception &#123; //1.加载配置文件 InputStream is = ConnectionTest.class.getClassLoader().getResourceAsStream(&quot;jdbc.properties&quot;); Properties pros = new Properties(); pros.load(is); //2.读取配置信息 String user = pros.getProperty(&quot;user&quot;); String password = pros.getProperty(&quot;password&quot;); String url = pros.getProperty(&quot;url&quot;); String driverClass = pros.getProperty(&quot;driverClass&quot;); //3.加载驱动 Class.forName(driverClass); //4.获取连接 Connection conn = DriverManager.getConnection(url,user,password); System.out.println(conn); &#125; 其中，配置文件声明在工程的src目录下：【jdbc.properties】 1234user=rootpassword=abc123url=jdbc:mysql://localhost:3306/testdriverClass=com.mysql.jdbc.Driver 说明：使用配置文件的方式保存配置信息，在代码中加载配置文件 使用配置文件的好处： ①实现了代码和数据的分离，如果需要修改配置信息，直接在配置文件中修改，不需要深入代码 ②如果修改了配置信息，省去重新编译的过程。 第3章：使用PreparedStatement实现CRUD操作 3.1 操作和访问数据库 数据库连接被用于向数据库服务器发送命令和 SQL 语句，并接受数据库服务器返回的结果。其实一个数据库连接就是一个Socket连接。 在 java.sql 包中有 3 个接口分别定义了对数据库的调用的不同方式： Statement：用于执行静态 SQL 语句并返回它所生成结果的对象。 PrepatedStatement：SQL 语句被预编译并存储在此对象中，可以使用此对象多次高效地执行该语句。 CallableStatement：用于执行 SQL 存储过程 3.2 使用Statement操作数据表的弊端 通过调用 Connection 对象的 createStatement() 方法创建该对象。该对象用于执行静态的 SQL 语句，并且返回执行结果。 Statement 接口中定义了下列方法用于执行 SQL 语句： 12int excuteUpdate(String sql)：执行更新操作INSERT、UPDATE、DELETEResultSet executeQuery(String sql)：执行查询操作SELECT 但是使用Statement操作数据表存在弊端： 问题一：存在拼串操作，繁琐 问题二：存在SQL注入问题 SQL 注入是利用某些系统没有对用户输入的数据进行充分的检查，而在用户输入数据中注入非法的 SQL 语句段或命令(如：SELECT user, password FROM user_table WHERE user=‘a’ OR 1 = ’ AND password = ’ OR ‘1’ = ‘1’) ，从而利用系统的 SQL 引擎完成恶意行为的做法。 对于 Java 而言，要防范 SQL 注入，只要用 PreparedStatement(从Statement扩展而来) 取代 Statement 就可以了。 代码演示： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110public class StatementTest &#123; // 使用Statement的弊端：需要拼写sql语句，并且存在SQL注入的问题 @Test public void testLogin() &#123; Scanner scan = new Scanner(System.in); System.out.print(&quot;用户名：&quot;); String userName = scan.nextLine(); System.out.print(&quot;密 码：&quot;); String password = scan.nextLine(); // SELECT user,password FROM user_table WHERE USER = &#x27;1&#x27; or &#x27; AND PASSWORD = &#x27;=&#x27;1&#x27; or &#x27;1&#x27; = &#x27;1&#x27;; String sql = &quot;SELECT user,password FROM user_table WHERE USER = &#x27;&quot; + userName + &quot;&#x27; AND PASSWORD = &#x27;&quot; + password + &quot;&#x27;&quot;; User user = get(sql, User.class); if (user != null) &#123; System.out.println(&quot;登陆成功!&quot;); &#125; else &#123; System.out.println(&quot;用户名或密码错误！&quot;); &#125; &#125; // 使用Statement实现对数据表的查询操作 public &lt;T&gt; T get(String sql, Class&lt;T&gt; clazz) &#123; T t = null; Connection conn = null; Statement st = null; ResultSet rs = null; try &#123; // 1.加载配置文件 InputStream is = StatementTest.class.getClassLoader().getResourceAsStream(&quot;jdbc.properties&quot;); Properties pros = new Properties(); pros.load(is); // 2.读取配置信息 String user = pros.getProperty(&quot;user&quot;); String password = pros.getProperty(&quot;password&quot;); String url = pros.getProperty(&quot;url&quot;); String driverClass = pros.getProperty(&quot;driverClass&quot;); // 3.加载驱动 Class.forName(driverClass); // 4.获取连接 conn = DriverManager.getConnection(url, user, password); st = conn.createStatement(); rs = st.executeQuery(sql); // 获取结果集的元数据 ResultSetMetaData rsmd = rs.getMetaData(); // 获取结果集的列数 int columnCount = rsmd.getColumnCount(); if (rs.next()) &#123; t = clazz.newInstance(); for (int i = 0; i &lt; columnCount; i++) &#123; // //1. 获取列的名称 // String columnName = rsmd.getColumnName(i+1); // 1. 获取列的别名 String columnName = rsmd.getColumnLabel(i + 1); // 2. 根据列名获取对应数据表中的数据 Object columnVal = rs.getObject(columnName); // 3. 将数据表中得到的数据，封装进对象 Field field = clazz.getDeclaredField(columnName); field.setAccessible(true); field.set(t, columnVal); &#125; return t; &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; // 关闭资源 if (rs != null) &#123; try &#123; rs.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if (st != null) &#123; try &#123; st.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if (conn != null) &#123; try &#123; conn.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125; return null; &#125;&#125; 综上： 3.3 PreparedStatement的使用 3.3.1 PreparedStatement介绍 可以通过调用 Connection 对象的 preparedStatement(String sql) 方法获取 PreparedStatement 对象 PreparedStatement 接口是 Statement 的子接口，它表示一条预编译过的 SQL 语句 PreparedStatement 对象所代表的 SQL 语句中的参数用问号(?)来表示，调用 PreparedStatement 对象的 setXxx() 方法来设置这些参数. setXxx() 方法有两个参数，第一个参数是要设置的 SQL 语句中的参数的索引(从 1 开始)，第二个是设置的 SQL 语句中的参数的值 3.3.2 PreparedStatement vs Statement 代码的可读性和可维护性。 PreparedStatement 能最大可能提高性能： DBServer会对预编译语句提供性能优化。因为预编译语句有可能被重复调用，所以语句在被DBServer的编译器编译后的执行代码被缓存下来，那么下次调用时只要是相同的预编译语句就不需要编译，只要将参数直接传入编译过的语句执行代码中就会得到执行。 在statement语句中,即使是相同操作但因为数据内容不一样,所以整个语句本身不能匹配,没有缓存语句的意义.事实是没有数据库会对普通语句编译后的执行代码缓存。这样每执行一次都要对传入的语句编译一次。 (语法检查，语义检查，翻译成二进制命令，缓存) PreparedStatement 可以防止 SQL 注入:对特殊字符进行转义 3.3.3 Java与SQL对应数据类型转换表 Java类型 SQL类型 boolean BIT byte TINYINT short SMALLINT int INTEGER long BIGINT String CHAR,VARCHAR,LONGVARCHAR byte array BINARY , VAR BINARY java.sql.Date DATE java.sql.Time TIME java.sql.Timestamp TIMESTAMP 3.3.4 使用PreparedStatement实现增、删、改操作 1234567891011121314151617181920212223242526//通用的增、删、改操作（体现一：增、删、改 ； 体现二：针对于不同的表）public void update(String sql,Object ... args)&#123; Connection conn = null; PreparedStatement ps = null; try &#123; //1.获取数据库的连接 conn = JDBCUtils.getConnection(); //2.获取PreparedStatement的实例 (或：预编译sql语句) ps = conn.prepareStatement(sql); //3.填充占位符 for(int i = 0;i &lt; args.length;i++)&#123; ps.setObject(i + 1, args[i]); &#125; //4.执行sql语句 ps.execute(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;finally&#123; //5.关闭资源 JDBCUtils.closeResource(conn, ps); &#125;&#125; 3.3.5 使用PreparedStatement实现查询操作 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455// 通用的针对于不同表的查询:返回一个对象 (version 1.0)public &lt;T&gt; T getInstance(Class&lt;T&gt; clazz, String sql, Object... args) &#123; Connection conn = null; PreparedStatement ps = null; ResultSet rs = null; try &#123; // 1.获取数据库连接 conn = JDBCUtils.getConnection(); // 2.预编译sql语句，得到PreparedStatement对象 ps = conn.prepareStatement(sql); // 3.填充占位符 for (int i = 0; i &lt; args.length; i++) &#123; ps.setObject(i + 1, args[i]); &#125; // 4.执行executeQuery(),得到结果集：ResultSet rs = ps.executeQuery(); // 5.得到结果集的元数据：ResultSetMetaData ResultSetMetaData rsmd = rs.getMetaData(); // 6.1通过ResultSetMetaData得到columnCount,columnLabel；通过ResultSet得到列值 int columnCount = rsmd.getColumnCount(); if (rs.next()) &#123; T t = clazz.newInstance(); for (int i = 0; i &lt; columnCount; i++) &#123;// 遍历每一个列 // 获取列值 Object columnVal = rs.getObject(i + 1); // 获取列的别名:列的别名，使用类的属性名充当 String columnLabel = rsmd.getColumnLabel(i + 1); // 6.2使用反射，给对象的相应属性赋值 Field field = clazz.getDeclaredField(columnLabel); field.setAccessible(true); field.set(t, columnVal); &#125; return t; &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; // 7.关闭资源 JDBCUtils.closeResource(conn, ps, rs); &#125; return null;&#125; 说明：使用PreparedStatement实现的查询操作可以替换Statement实现的查询操作，解决Statement拼串和SQL注入问题。 3.4 ResultSet与ResultSetMetaData 3.4.1 ResultSet 查询需要调用PreparedStatement 的 executeQuery() 方法，查询结果是一个ResultSet 对象 ResultSet 对象以逻辑表格的形式封装了执行数据库操作的结果集，ResultSet 接口由数据库厂商提供实现 ResultSet 返回的实际上就是一张数据表。有一个指针指向数据表的第一条记录的前面。 ResultSet 对象维护了一个指向当前数据行的游标，初始的时候，游标在第一行之前，可以通过 ResultSet 对象的 next() 方法移动到下一行。调用 next()方法检测下一行是否有效。若有效，该方法返回 true，且指针下移。相当于Iterator对象的 hasNext() 和 next() 方法的结合体。 当指针指向一行时, 可以通过调用 getXxx(int index) 或 getXxx(int columnName) 获取每一列的值。 例如: getInt(1), getString(“name”) 注意：Java与数据库交互涉及到的相关Java API中的索引都从1开始。 ResultSet 接口的常用方法： boolean next() getString() … 3.4.2 ResultSetMetaData 可用于获取关于 ResultSet 对象中列的类型和属性信息的对象 ResultSetMetaData meta = rs.getMetaData(); getColumnName(int column)：获取指定列的名称 getColumnLabel(int column)：获取指定列的别名 getColumnCount()：返回当前 ResultSet 对象中的列数。 getColumnTypeName(int column)：检索指定列的数据库特定的类型名称。 getColumnDisplaySize(int column)：指示指定列的最大标准宽度，以字符为单位。 isNullable(int column)：指示指定列中的值是否可以为 null。 isAutoIncrement(int column)：指示是否自动为指定列进行编号，这样这些列仍然是只读的。 问题1：得到结果集后, 如何知道该结果集中有哪些列 ？ 列名是什么？ ​ 需要使用一个描述 ResultSet 的对象， 即 ResultSetMetaData 问题2：关于ResultSetMetaData 如何获取 ResultSetMetaData： 调用 ResultSet 的 getMetaData() 方法即可 获取 ResultSet 中有多少列：调用 ResultSetMetaData 的 getColumnCount() 方法 获取 ResultSet 每一列的列的别名是什么：调用 ResultSetMetaData 的getColumnLabel() 方法 3.5 资源的释放 释放ResultSet, Statement,Connection。 数据库连接（Connection）是非常稀有的资源，用完后必须马上释放，如果Connection不能及时正确的关闭将导致系统宕机。Connection的使用原则是尽量晚创建，尽量早的释放。 可以在finally中关闭，保证及时其他代码出现异常，资源也一定能被关闭。 3.6 JDBC API小结 两种思想 面向接口编程的思想 ORM思想(object relational mapping) 一个数据表对应一个java类 表中的一条记录对应java类的一个对象 表中的一个字段对应java类的一个属性 sql是需要结合列名和表的属性名来写。注意起别名。 两种技术 JDBC结果集的元数据：ResultSetMetaData 获取列数：getColumnCount() 获取列的别名：getColumnLabel() 通过反射，创建指定类的对象，获取指定的属性并赋值 章节练习 练习题1：从控制台向数据库的表customers中插入一条数据，表结构如下： 练习题2：创立数据库表 examstudent，表结构如下： 向数据表中添加如下数据： 代码实现1：插入一个新的student 信息 请输入考生的详细信息 Type: IDCard: ExamCard: StudentName: Location: Grade: 信息录入成功! 代码实现2：在 eclipse中建立 java 程序：输入身份证号或准考证号可以查询到学生的基本信息。结果如下： 代码实现3：完成学生信息的删除功能 第4章 操作BLOB类型字段 4.1 MySQL BLOB类型 MySQL中，BLOB是一个二进制大型对象，是一个可以存储大量数据的容器，它能容纳不同大小的数据。 插入BLOB类型的数据必须使用PreparedStatement，因为BLOB类型的数据无法使用字符串拼接写的。 MySQL的四种BLOB类型(除了在存储的最大信息量上不同外，他们是等同的) 实际使用中根据需要存入的数据大小定义不同的BLOB类型。 需要注意的是：如果存储的文件过大，数据库的性能会下降。 如果在指定了相关的Blob类型以后，还报错：xxx too large，那么在mysql的安装目录下，找my.ini文件加上如下的配置参数： max_allowed_packet=16M。同时注意：修改了my.ini文件之后，需要重新启动mysql服务。 4.2 向数据表中插入大数据类型 12345678910111213141516171819//获取连接Connection conn = JDBCUtils.getConnection(); String sql = &quot;insert into customers(name,email,birth,photo)values(?,?,?,?)&quot;;PreparedStatement ps = conn.prepareStatement(sql);// 填充占位符ps.setString(1, &quot;徐海强&quot;);ps.setString(2, &quot;xhq@126.com&quot;);ps.setDate(3, new Date(new java.util.Date().getTime()));// 操作Blob类型的变量FileInputStream fis = new FileInputStream(&quot;xhq.png&quot;);ps.setBlob(4, fis);//执行ps.execute(); fis.close();JDBCUtils.closeResource(conn, ps); 4.3 修改数据表中的Blob类型字段 1234567891011121314Connection conn = JDBCUtils.getConnection();String sql = &quot;update customers set photo = ? where id = ?&quot;;PreparedStatement ps = conn.prepareStatement(sql);// 填充占位符// 操作Blob类型的变量FileInputStream fis = new FileInputStream(&quot;coffee.png&quot;);ps.setBlob(1, fis);ps.setInt(2, 25);ps.execute();fis.close();JDBCUtils.closeResource(conn, ps); 4.4 从数据表中读取大数据类型 123456789101112131415161718192021222324252627282930313233String sql = &quot;SELECT id, name, email, birth, photo FROM customer WHERE id = ?&quot;;conn = getConnection();ps = conn.prepareStatement(sql);ps.setInt(1, 8);rs = ps.executeQuery();if(rs.next())&#123; Integer id = rs.getInt(1); String name = rs.getString(2); String email = rs.getString(3); Date birth = rs.getDate(4); Customer cust = new Customer(id, name, email, birth); System.out.println(cust); //读取Blob类型的字段 Blob photo = rs.getBlob(5); InputStream is = photo.getBinaryStream(); OutputStream os = new FileOutputStream(&quot;c.jpg&quot;); byte [] buffer = new byte[1024]; int len = 0; while((len = is.read(buffer)) != -1)&#123; os.write(buffer, 0, len); &#125; JDBCUtils.closeResource(conn, ps, rs); if(is != null)&#123; is.close(); &#125; if(os != null)&#123; os.close(); &#125; &#125; 第5章 批量插入 5.1 批量执行SQL语句 当需要成批插入或者更新记录时，可以采用Java的批量更新机制，这一机制允许多条语句一次性提交给数据库批量处理。通常情况下比单独提交处理更有效率 JDBC的批量处理语句包括下面三个方法： addBatch(String)：添加需要批量处理的SQL语句或是参数； executeBatch()：执行批量处理语句； clearBatch():清空缓存的数据 JDBC 连接 MySQL 的时候，要在 url后面直接加上==?rewriteBatchedStatements=true== 通常我们会遇到两种批量执行SQL语句的情况： 多条SQL语句的批量处理； 一个SQL语句的批量传参； 5.2 高效的批量插入 举例：向数据表中插入20000条数据 数据库中提供一个goods表。创建如下： 1234CREATE TABLE goods(id INT PRIMARY KEY AUTO_INCREMENT,NAME VARCHAR(20)); 5.2.1 实现层次一：使用Statement 123456Connection conn = JDBCUtils.getConnection();Statement st = conn.createStatement();for(int i = 1;i &lt;= 20000;i++)&#123; String sql = &quot;insert into goods(name) values(&#x27;name_&#x27; + &quot;+ i +&quot;)&quot;; st.executeUpdate(sql);&#125; 5.2.2 实现层次二：使用PreparedStatement 12345678910111213141516long start = System.currentTimeMillis(); Connection conn = JDBCUtils.getConnection(); String sql = &quot;insert into goods(name)values(?)&quot;;PreparedStatement ps = conn.prepareStatement(sql);for(int i = 1;i &lt;= 20000;i++)&#123; ps.setString(1, &quot;name_&quot; + i); ps.executeUpdate();&#125; long end = System.currentTimeMillis();System.out.println(&quot;花费的时间为：&quot; + (end - start));//82340 JDBCUtils.closeResource(conn, ps); 5.2.3 实现层次三（Batch） 12345678910111213141516171819202122232425262728293031323334/* * 修改1： 使用 addBatch() / executeBatch() / clearBatch() * 修改2：mysql服务器默认是关闭批处理的，我们需要通过一个参数，让mysql开启批处理的支持。 * ?rewriteBatchedStatements=true 写在配置文件的url后面 * 修改3：使用更新的mysql 驱动：mysql-connector-java-5.1.37-bin.jar * */@Testpublic void testInsert1() throws Exception&#123; long start = System.currentTimeMillis(); Connection conn = JDBCUtils.getConnection(); String sql = &quot;insert into goods(name)values(?)&quot;; PreparedStatement ps = conn.prepareStatement(sql); for(int i = 1;i &lt;= 1000000;i++)&#123; ps.setString(1, &quot;name_&quot; + i); //1.“攒”sql ps.addBatch(); if(i % 500 == 0)&#123; //2.执行 ps.executeBatch(); //3.清空 ps.clearBatch(); &#125; &#125; long end = System.currentTimeMillis(); System.out.println(&quot;花费的时间为：&quot; + (end - start));//20000条：625 //1000000条:14733 JDBCUtils.closeResource(conn, ps);&#125; 5.2.4 实现层次四 1234567891011121314151617181920212223242526272829303132333435363738/** 层次四：在层次三的基础上操作* 使用Connection 的 setAutoCommit(false) / commit()*/@Testpublic void testInsert2() throws Exception&#123; long start = System.currentTimeMillis(); Connection conn = JDBCUtils.getConnection(); //1.设置为不自动提交数据 conn.setAutoCommit(false); String sql = &quot;insert into goods(name)values(?)&quot;; PreparedStatement ps = conn.prepareStatement(sql); for(int i = 1;i &lt;= 1000000;i++)&#123; ps.setString(1, &quot;name_&quot; + i); //1.“攒”sql ps.addBatch(); if(i % 500 == 0)&#123; //2.执行 ps.executeBatch(); //3.清空 ps.clearBatch(); &#125; &#125; //2.提交数据 conn.commit(); long end = System.currentTimeMillis(); System.out.println(&quot;花费的时间为：&quot; + (end - start));//1000000条:4978 JDBCUtils.closeResource(conn, ps);&#125; 第6章： 数据库事务 6.1 数据库事务介绍 事务：一组逻辑操作单元,使数据从一种状态变换到另一种状态。 事务处理（事务操作）：保证所有事务都作为一个工作单元来执行，即使出现了故障，都不能改变这种执行方式。当在一个事务中执行多个操作时，要么所有的事务都被提交(commit)，那么这些修改就永久地保存下来；要么数据库管理系统将放弃所作的所有修改，整个事务**回滚(rollback)**到最初状态。 为确保数据库中数据的一致性，数据的操纵应当是离散的成组的逻辑单元：当它全部完成时，数据的一致性可以保持，而当这个单元中的一部分操作失败，整个事务应全部视为错误，所有从起始点以后的操作应全部回退到开始状态。 6.2 JDBC事务处理 数据一旦提交，就不可回滚。 数据什么时候意味着提交？ 当一个连接对象被创建时，默认情况下是自动提交事务：每次执行一个 SQL 语句时，如果执行成功，就会向数据库自动提交，而不能回滚。 **关闭数据库连接，数据就会自动的提交。**如果多个操作，每个操作使用的是自己单独的连接，则无法保证事务。即同一个事务的多个操作必须在同一个连接下。 JDBC程序中为了让多个 SQL 语句作为一个事务执行： 调用 Connection 对象的 setAutoCommit(false); 以取消自动提交事务 在所有的 SQL 语句都成功执行后，调用 commit(); 方法提交事务 在出现异常时，调用 rollback(); 方法回滚事务 若此时 Connection 没有被关闭，还可能被重复使用，则需要恢复其自动提交状态 setAutoCommit(true)。尤其是在使用数据库连接池技术时，执行close()方法前，建议恢复自动提交状态。 【案例：用户AA向用户BB转账100】 1234567891011121314151617181920212223242526272829303132333435363738public void testJDBCTransaction() &#123; Connection conn = null; try &#123; // 1.获取数据库连接 conn = JDBCUtils.getConnection(); // 2.开启事务 conn.setAutoCommit(false); // 3.进行数据库操作 String sql1 = &quot;update user_table set balance = balance - 100 where user = ?&quot;; update(conn, sql1, &quot;AA&quot;); // 模拟网络异常 //System.out.println(10 / 0); String sql2 = &quot;update user_table set balance = balance + 100 where user = ?&quot;; update(conn, sql2, &quot;BB&quot;); // 4.若没有异常，则提交事务 conn.commit(); &#125; catch (Exception e) &#123; e.printStackTrace(); // 5.若有异常，则回滚事务 try &#123; conn.rollback(); &#125; catch (SQLException e1) &#123; e1.printStackTrace(); &#125; &#125; finally &#123; try &#123; //6.恢复每次DML操作的自动提交功能 conn.setAutoCommit(true); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; //7.关闭连接 JDBCUtils.closeResource(conn, null, null); &#125; &#125; 其中，对数据库操作的方法为： 1234567891011121314151617181920//使用事务以后的通用的增删改操作（version 2.0）public void update(Connection conn ,String sql, Object... args) &#123; PreparedStatement ps = null; try &#123; // 1.获取PreparedStatement的实例 (或：预编译sql语句) ps = conn.prepareStatement(sql); // 2.填充占位符 for (int i = 0; i &lt; args.length; i++) &#123; ps.setObject(i + 1, args[i]); &#125; // 3.执行sql语句 ps.execute(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; // 4.关闭资源 JDBCUtils.closeResource(null, ps); &#125;&#125; 6.3 事务的ACID属性 原子性（Atomicity） 原子性是指事务是一个不可分割的工作单位，事务中的操作要么都发生，要么都不发生。 一致性（Consistency） 事务必须使数据库从一个一致性状态变换到另外一个一致性状态。 隔离性（Isolation） 事务的隔离性是指一个事务的执行不能被其他事务干扰，即一个事务内部的操作及使用的数据对并发的其他事务是隔离的，并发执行的各个事务之间不能互相干扰。 持久性（Durability） 持久性是指一个事务一旦被提交，它对数据库中数据的改变就是永久性的，接下来的其他操作和数据库故障不应该对其有任何影响。 6.3.1 数据库的并发问题 对于同时运行的多个事务, 当这些事务访问数据库中相同的数据时, 如果没有采取必要的隔离机制, 就会导致各种并发问题: 脏读: 对于两个事务 T1, T2, T1 读取了已经被 T2 更新但还没有被提交的字段。之后, 若 T2 回滚, T1读取的内容就是临时且无效的。 不可重复读: 对于两个事务T1, T2, T1 读取了一个字段, 然后 T2 更新了该字段。之后, T1再次读取同一个字段, 值就不同了。 幻读: 对于两个事务T1, T2, T1 从一个表中读取了一个字段, 然后 T2 在该表中插入了一些新的行。之后, 如果 T1 再次读取同一个表, 就会多出几行。 数据库事务的隔离性: 数据库系统必须具有隔离并发运行各个事务的能力, 使它们不会相互影响, 避免各种并发问题。 一个事务与其他事务隔离的程度称为隔离级别。数据库规定了多种事务隔离级别, 不同隔离级别对应不同的干扰程度, 隔离级别越高, 数据一致性就越好, 但并发性越弱。 6.3.2 四种隔离级别 数据库提供的4种事务隔离级别： Oracle 支持的 2 种事务隔离级别：READ COMMITED, SERIALIZABLE。 Oracle 默认的事务隔离级别为: READ COMMITED 。 Mysql 支持 4 种事务隔离级别。Mysql 默认的事务隔离级别为: REPEATABLE READ。 6.3.3 在MySql中设置隔离级别 每启动一个 mysql 程序, 就会获得一个单独的数据库连接. 每个数据库连接都有一个全局变量 @@tx_isolation, 表示当前的事务隔离级别。 查看当前的隔离级别: 1SELECT @@tx_isolation; 设置当前 mySQL 连接的隔离级别: 1set transaction isolation level read committed; 设置数据库系统的全局的隔离级别: 1set global transaction isolation level read committed; 补充操作： 创建mysql数据库用户： 1create user tom identified by &#x27;abc123&#x27;; 授予权限 123456#授予通过网络方式登录的tom用户，对所有库所有表的全部权限，密码设为abc123.grant all privileges on *.* to tom@&#x27;%&#x27; identified by &#x27;abc123&#x27;; #给tom用户使用本地命令行方式，授予atguigudb这个库下的所有表的插删改查的权限。grant select,insert,delete,update on atguigudb.* to tom@localhost identified by &#x27;abc123&#x27;; 第7章：DAO及相关实现类 DAO：Data Access Object访问数据信息的类和接口，包括了对数据的CRUD（Create、Retrival、Update、Delete），而不包含任何业务相关的信息。有时也称作：BaseDAO 作用：为了实现功能的模块化，更有利于代码的维护和升级。 下面是尚硅谷JavaWeb阶段书城项目中DAO使用的体现： 层次结构： 【BaseDAO.java】 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110package com.atguigu.bookstore.dao;import java.lang.reflect.ParameterizedType;import java.lang.reflect.Type;import java.sql.Connection;import java.sql.SQLException;import java.util.List;import org.apache.commons.dbutils.QueryRunner;import org.apache.commons.dbutils.handlers.BeanHandler;import org.apache.commons.dbutils.handlers.BeanListHandler;import org.apache.commons.dbutils.handlers.ScalarHandler;/** * 定义一个用来被继承的对数据库进行基本操作的Dao * * @author HanYanBing * * @param &lt;T&gt; */public abstract class BaseDao&lt;T&gt; &#123; private QueryRunner queryRunner = new QueryRunner(); // 定义一个变量来接收泛型的类型 private Class&lt;T&gt; type; // 获取T的Class对象，获取泛型的类型，泛型是在被子类继承时才确定 public BaseDao() &#123; // 获取子类的类型 Class clazz = this.getClass(); // 获取父类的类型 // getGenericSuperclass()用来获取当前类的父类的类型 // ParameterizedType表示的是带泛型的类型 ParameterizedType parameterizedType = (ParameterizedType) clazz.getGenericSuperclass(); // 获取具体的泛型类型 getActualTypeArguments获取具体的泛型的类型 // 这个方法会返回一个Type的数组 Type[] types = parameterizedType.getActualTypeArguments(); // 获取具体的泛型的类型· this.type = (Class&lt;T&gt;) types[0]; &#125; /** * 通用的增删改操作 * * @param sql * @param params * @return */ public int update(Connection conn,String sql, Object... params) &#123; int count = 0; try &#123; count = queryRunner.update(conn, sql, params); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; return count; &#125; /** * 获取一个对象 * * @param sql * @param params * @return */ public T getBean(Connection conn,String sql, Object... params) &#123; T t = null; try &#123; t = queryRunner.query(conn, sql, new BeanHandler&lt;T&gt;(type), params); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; return t; &#125; /** * 获取所有对象 * * @param sql * @param params * @return */ public List&lt;T&gt; getBeanList(Connection conn,String sql, Object... params) &#123; List&lt;T&gt; list = null; try &#123; list = queryRunner.query(conn, sql, new BeanListHandler&lt;T&gt;(type), params); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; return list; &#125; /** * 获取一个但一值得方法，专门用来执行像 select count(*)...这样的sql语句 * * @param sql * @param params * @return */ public Object getValue(Connection conn,String sql, Object... params) &#123; Object count = null; try &#123; // 调用queryRunner的query方法获取一个单一的值 count = queryRunner.query(conn, sql, new ScalarHandler&lt;&gt;(), params); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; return count; &#125;&#125; 【BookDAO.java】 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263package com.atguigu.bookstore.dao;import java.sql.Connection;import java.util.List;import com.atguigu.bookstore.beans.Book;import com.atguigu.bookstore.beans.Page;public interface BookDao &#123; /** * 从数据库中查询出所有的记录 * * @return */ List&lt;Book&gt; getBooks(Connection conn); /** * 向数据库中插入一条记录 * * @param book */ void saveBook(Connection conn,Book book); /** * 从数据库中根据图书的id删除一条记录 * * @param bookId */ void deleteBookById(Connection conn,String bookId); /** * 根据图书的id从数据库中查询出一条记录 * * @param bookId * @return */ Book getBookById(Connection conn,String bookId); /** * 根据图书的id从数据库中更新一条记录 * * @param book */ void updateBook(Connection conn,Book book); /** * 获取带分页的图书信息 * * @param page：是只包含了用户输入的pageNo属性的page对象 * @return 返回的Page对象是包含了所有属性的Page对象 */ Page&lt;Book&gt; getPageBooks(Connection conn,Page&lt;Book&gt; page); /** * 获取带分页和价格范围的图书信息 * * @param page：是只包含了用户输入的pageNo属性的page对象 * @return 返回的Page对象是包含了所有属性的Page对象 */ Page&lt;Book&gt; getPageBooksByPrice(Connection conn,Page&lt;Book&gt; page, double minPrice, double maxPrice);&#125; 【UserDAO.java】 12345678910111213141516171819202122232425262728293031package com.atguigu.bookstore.dao;import java.sql.Connection;import com.atguigu.bookstore.beans.User;public interface UserDao &#123; /** * 根据User对象中的用户名和密码从数据库中获取一条记录 * * @param user * @return User 数据库中有记录 null 数据库中无此记录 */ User getUser(Connection conn,User user); /** * 根据User对象中的用户名从数据库中获取一条记录 * * @param user * @return true 数据库中有记录 false 数据库中无此记录 */ boolean checkUsername(Connection conn,User user); /** * 向数据库中插入User对象 * * @param user */ void saveUser(Connection conn,User user);&#125; 【BookDaoImpl.java】 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495package com.atguigu.bookstore.dao.impl;import java.sql.Connection;import java.util.List;import com.atguigu.bookstore.beans.Book;import com.atguigu.bookstore.beans.Page;import com.atguigu.bookstore.dao.BaseDao;import com.atguigu.bookstore.dao.BookDao;public class BookDaoImpl extends BaseDao&lt;Book&gt; implements BookDao &#123; @Override public List&lt;Book&gt; getBooks(Connection conn) &#123; // 调用BaseDao中得到一个List的方法 List&lt;Book&gt; beanList = null; // 写sql语句 String sql = &quot;select id,title,author,price,sales,stock,img_path imgPath from books&quot;; beanList = getBeanList(conn,sql); return beanList; &#125; @Override public void saveBook(Connection conn,Book book) &#123; // 写sql语句 String sql = &quot;insert into books(title,author,price,sales,stock,img_path) values(?,?,?,?,?,?)&quot;; // 调用BaseDao中通用的增删改的方法 update(conn,sql, book.getTitle(), book.getAuthor(), book.getPrice(), book.getSales(), book.getStock(),book.getImgPath()); &#125; @Override public void deleteBookById(Connection conn,String bookId) &#123; // 写sql语句 String sql = &quot;DELETE FROM books WHERE id = ?&quot;; // 调用BaseDao中通用增删改的方法 update(conn,sql, bookId); &#125; @Override public Book getBookById(Connection conn,String bookId) &#123; // 调用BaseDao中获取一个对象的方法 Book book = null; // 写sql语句 String sql = &quot;select id,title,author,price,sales,stock,img_path imgPath from books where id = ?&quot;; book = getBean(conn,sql, bookId); return book; &#125; @Override public void updateBook(Connection conn,Book book) &#123; // 写sql语句 String sql = &quot;update books set title = ? , author = ? , price = ? , sales = ? , stock = ? where id = ?&quot;; // 调用BaseDao中通用的增删改的方法 update(conn,sql, book.getTitle(), book.getAuthor(), book.getPrice(), book.getSales(), book.getStock(), book.getId()); &#125; @Override public Page&lt;Book&gt; getPageBooks(Connection conn,Page&lt;Book&gt; page) &#123; // 获取数据库中图书的总记录数 String sql = &quot;select count(*) from books&quot;; // 调用BaseDao中获取一个单一值的方法 long totalRecord = (long) getValue(conn,sql); // 将总记录数设置都page对象中 page.setTotalRecord((int) totalRecord); // 获取当前页中的记录存放的List String sql2 = &quot;select id,title,author,price,sales,stock,img_path imgPath from books limit ?,?&quot;; // 调用BaseDao中获取一个集合的方法 List&lt;Book&gt; beanList = getBeanList(conn,sql2, (page.getPageNo() - 1) * Page.PAGE_SIZE, Page.PAGE_SIZE); // 将这个List设置到page对象中 page.setList(beanList); return page; &#125; @Override public Page&lt;Book&gt; getPageBooksByPrice(Connection conn,Page&lt;Book&gt; page, double minPrice, double maxPrice) &#123; // 获取数据库中图书的总记录数 String sql = &quot;select count(*) from books where price between ? and ?&quot;; // 调用BaseDao中获取一个单一值的方法 long totalRecord = (long) getValue(conn,sql,minPrice,maxPrice); // 将总记录数设置都page对象中 page.setTotalRecord((int) totalRecord); // 获取当前页中的记录存放的List String sql2 = &quot;select id,title,author,price,sales,stock,img_path imgPath from books where price between ? and ? limit ?,?&quot;; // 调用BaseDao中获取一个集合的方法 List&lt;Book&gt; beanList = getBeanList(conn,sql2, minPrice , maxPrice , (page.getPageNo() - 1) * Page.PAGE_SIZE, Page.PAGE_SIZE); // 将这个List设置到page对象中 page.setList(beanList); return page; &#125;&#125; 【UserDaoImpl.java】 123456789101112131415161718192021222324252627282930313233343536373839package com.atguigu.bookstore.dao.impl;import java.sql.Connection;import com.atguigu.bookstore.beans.User;import com.atguigu.bookstore.dao.BaseDao;import com.atguigu.bookstore.dao.UserDao;public class UserDaoImpl extends BaseDao&lt;User&gt; implements UserDao &#123; @Override public User getUser(Connection conn,User user) &#123; // 调用BaseDao中获取一个对象的方法 User bean = null; // 写sql语句 String sql = &quot;select id,username,password,email from users where username = ? and password = ?&quot;; bean = getBean(conn,sql, user.getUsername(), user.getPassword()); return bean; &#125; @Override public boolean checkUsername(Connection conn,User user) &#123; // 调用BaseDao中获取一个对象的方法 User bean = null; // 写sql语句 String sql = &quot;select id,username,password,email from users where username = ?&quot;; bean = getBean(conn,sql, user.getUsername()); return bean != null; &#125; @Override public void saveUser(Connection conn,User user) &#123; //写sql语句 String sql = &quot;insert into users(username,password,email) values(?,?,?)&quot;; //调用BaseDao中通用的增删改的方法 update(conn,sql, user.getUsername(),user.getPassword(),user.getEmail()); &#125;&#125; 【Book.java】 1234567891011121314151617package com.atguigu.bookstore.beans;/** * 图书类 * @author songhongkang * */public class Book &#123; private Integer id; private String title; // 书名 private String author; // 作者 private double price; // 价格 private Integer sales; // 销量 private Integer stock; // 库存 private String imgPath = &quot;static/img/default.jpg&quot;; // 封面图片的路径 //构造器，get()，set()，toString()方法略&#125; 【Page.java】 12345678910111213141516package com.atguigu.bookstore.beans;import java.util.List;/** * 页码类 * @author songhongkang * */public class Page&lt;T&gt; &#123; private List&lt;T&gt; list; // 每页查到的记录存放的集合 public static final int PAGE_SIZE = 4; // 每页显示的记录数 private int pageNo; // 当前页// private int totalPageNo; // 总页数，通过计算得到 private int totalRecord; // 总记录数，通过查询数据库得到 【User.java】 12345678910111213package com.atguigu.bookstore.beans;/** * 用户类 * @author songhongkang * */public class User &#123; private Integer id; private String username; private String password; private String email; 第8章：数据库连接池 8.1 JDBC数据库连接池的必要性 在使用开发基于数据库的web程序时，传统的模式基本是按以下步骤： 在主程序（如servlet、beans）中建立数据库连接 进行sql操作 断开数据库连接 这种模式开发，存在的问题: 普通的JDBC数据库连接使用 DriverManager 来获取，每次向数据库建立连接的时候都要将 Connection 加载到内存中，再验证用户名和密码(得花费0.05s～1s的时间)。需要数据库连接的时候，就向数据库要求一个，执行完成后再断开连接。这样的方式将会消耗大量的资源和时间。**数据库的连接资源并没有得到很好的重复利用。**若同时有几百人甚至几千人在线，频繁的进行数据库连接操作将占用很多的系统资源，严重的甚至会造成服务器的崩溃。 **对于每一次数据库连接，使用完后都得断开。**否则，如果程序出现异常而未能关闭，将会导致数据库系统中的内存泄漏，最终将导致重启数据库。（回忆：何为Java的内存泄漏：内存中存在不能被回收的对象） 这种开发不能控制被创建的连接对象数，系统资源会被毫无顾及的分配出去，如连接过多，也可能导致内存泄漏，服务器崩溃。 8.2 数据库连接池技术 为解决传统开发中的数据库连接问题，可以采用数据库连接池技术。 数据库连接池的基本思想：就是为数据库连接建立一个“缓冲池”。预先在缓冲池中放入一定数量的连接，当需要建立数据库连接时，只需从“缓冲池”中取出一个，使用完毕之后再放回去。 数据库连接池负责分配、管理和释放数据库连接，它允许应用程序重复使用一个现有的数据库连接，而不是重新建立一个。 数据库连接池在初始化时将创建一定数量的数据库连接放到连接池中，这些数据库连接的数量是由最小数据库连接数来设定的。无论这些数据库连接是否被使用，连接池都将一直保证至少拥有这么多的连接数量。连接池的最大数据库连接数量限定了这个连接池能占有的最大连接数，当应用程序向连接池请求的连接数超过最大连接数量时，这些请求将被加入到等待队列中。 工作原理： 数据库连接池技术的优点 1. 资源重用 由于数据库连接得以重用，避免了频繁创建，释放连接引起的大量性能开销。在减少系统消耗的基础上，另一方面也增加了系统运行环境的平稳性。 2. 更快的系统反应速度 数据库连接池在初始化过程中，往往已经创建了若干数据库连接置于连接池中备用。此时连接的初始化工作均已完成。对于业务请求处理而言，直接利用现有可用连接，避免了数据库连接初始化和释放过程的时间开销，从而减少了系统的响应时间 3. 新的资源分配手段 对于多应用共享同一数据库的系统而言，可在应用层通过数据库连接池的配置，实现某一应用最大可用数据库连接数的限制，避免某一应用独占所有的数据库资源 4. 统一的连接管理，避免数据库连接泄漏 在较为完善的数据库连接池实现中，可根据预先的占用超时设定，强制回收被占用连接，从而避免了常规数据库连接操作中可能出现的资源泄露 8.3 多种开源的数据库连接池 JDBC 的数据库连接池使用 javax.sql.DataSource 来表示，DataSource 只是一个接口，该接口通常由服务器(Weblogic, WebSphere, Tomcat)提供实现，也有一些开源组织提供实现，需要导入 .jar 包： DBCP 是Apache提供的数据库连接池。tomcat 服务器自带dbcp数据库连接池。速度相对c3p0较快，但因自身存在BUG，Hibernate3已不再提供支持。 C3P0 是一个开源组织提供的一个数据库连接池，**速度相对较慢，稳定性还可以。**hibernate官方推荐使用 Proxool 是sourceforge下的一个开源项目数据库连接池，有监控连接池状态的功能，稳定性较c3p0差一点 BoneCP 是一个开源组织提供的数据库连接池，速度快 Druid 是阿里提供的数据库连接池，据说是集DBCP 、C3P0 、Proxool 优点于一身的数据库连接池，但是速度不确定是否有BoneCP快（主要使用） DataSource 通常被称为数据源，它包含连接池和连接池管理两个部分，习惯上也经常把 DataSource 称为连接池 DataSource用来取代DriverManager来获取Connection，获取速度快，同时可以大幅度提高数据库访问速度。 特别注意： 数据源和数据库连接不同，数据源无需创建多个，它是产生数据库连接的工厂，因此整个应用只需要一个数据源即可。 当数据库访问结束后，程序还是像以前一样关闭数据库连接：conn.close(); 但conn.close()并没有关闭数据库的物理连接，它仅仅把数据库连接释放，归还给了数据库连接池。 8.3.1 C3P0数据库连接池 获取连接方式一 1234567891011121314151617//使用C3P0数据库连接池的方式，获取数据库的连接：不推荐public static Connection getConnection1() throws Exception&#123; ComboPooledDataSource cpds = new ComboPooledDataSource(); cpds.setDriverClass(&quot;com.mysql.jdbc.Driver&quot;); cpds.setJdbcUrl(&quot;jdbc:mysql://localhost:3306/test&quot;); cpds.setUser(&quot;root&quot;); cpds.setPassword(&quot;abc123&quot;); // cpds.setMaxPoolSize(100); //最大连接数// cpds.setInitialPoolSize(10); //初始时数据库连接池的数量 //获取连接 Connection conn = cpds.getConnection(); return conn;&#125; 获取连接方式二 123456//使用C3P0数据库连接池的配置文件方式，获取数据库的连接：推荐private static DataSource cpds = new ComboPooledDataSource(&quot;helloc3p0&quot;);public static Connection getConnection2() throws SQLException&#123; Connection conn = cpds.getConnection(); return conn;&#125; 其中，src下的配置文件为：【c3p0-config.xml】，文件名不能改。 12345678910111213141516171819202122232425&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;c3p0-config&gt; &lt;named-config name=&quot;helloc3p0&quot;&gt; &lt;!-- 获取连接的4个基本信息 --&gt; &lt;property name=&quot;user&quot;&gt;root&lt;/property&gt; &lt;property name=&quot;password&quot;&gt;abc123&lt;/property&gt; &lt;property name=&quot;jdbcUrl&quot;&gt;jdbc:mysql:///test&lt;/property&gt; &lt;property name=&quot;driverClass&quot;&gt;com.mysql.jdbc.Driver&lt;/property&gt; &lt;!-- 涉及到数据库连接池的管理的相关属性的设置 --&gt; &lt;!-- 若数据库中连接数不足时, 一次向数据库服务器申请多少个连接 --&gt; &lt;property name=&quot;acquireIncrement&quot;&gt;5&lt;/property&gt; &lt;!-- 初始化数据库连接池时连接的数量 --&gt; &lt;property name=&quot;initialPoolSize&quot;&gt;5&lt;/property&gt; &lt;!-- 数据库连接池中的最小的数据库连接数 --&gt; &lt;property name=&quot;minPoolSize&quot;&gt;5&lt;/property&gt; &lt;!-- 数据库连接池中的最大的数据库连接数 --&gt; &lt;property name=&quot;maxPoolSize&quot;&gt;10&lt;/property&gt; &lt;!-- C3P0 数据库连接池可以维护的 Statement 的个数 --&gt; &lt;property name=&quot;maxStatements&quot;&gt;20&lt;/property&gt; &lt;!-- 每个连接同时可以使用的 Statement 对象的个数 --&gt; &lt;property name=&quot;maxStatementsPerConnection&quot;&gt;5&lt;/property&gt; &lt;/named-config&gt;&lt;/c3p0-config&gt; 8.3.2 DBCP数据库连接池 DBCP 是 Apache 软件基金组织下的开源连接池实现，该连接池依赖该组织下的另一个开源系统：Common-pool。如需使用该连接池实现，应在系统中增加如下两个 jar 文件： Commons-dbcp.jar：连接池的实现 Commons-pool.jar：连接池实现的依赖库 **Tomcat 的连接池正是采用该连接池来实现的。**该数据库连接池既可以与应用服务器整合使用，也可由应用程序独立使用。 数据源和数据库连接不同，数据源无需创建多个，它是产生数据库连接的工厂，因此整个应用只需要一个数据源即可。 当数据库访问结束后，程序还是像以前一样关闭数据库连接：conn.close(); 但上面的代码并没有关闭数据库的物理连接，它仅仅把数据库连接释放，归还给了数据库连接池。 配置属性说明 属性 默认值 说明 initialSize 0 连接池启动时创建的初始化连接数量 maxActive 8 连接池中可同时连接的最大的连接数 maxIdle 8 连接池中最大的空闲的连接数，超过的空闲连接将被释放，如果设置为负数表示不限制 minIdle 0 连接池中最小的空闲的连接数，低于这个数量会被创建新的连接。该参数越接近maxIdle，性能越好，因为连接的创建和销毁，都是需要消耗资源的；但是不能太大。 maxWait 无限制 最大等待时间，当没有可用连接时，连接池等待连接释放的最大时间，超过该时间限制会抛出异常，如果设置-1表示无限等待 poolPreparedStatements false 开启池的Statement是否prepared maxOpenPreparedStatements 无限制 开启池的prepared 后的同时最大连接数 minEvictableIdleTimeMillis 连接池中连接，在时间段内一直空闲， 被逐出连接池的时间 removeAbandonedTimeout 300 超过时间限制，回收没有用(废弃)的连接 removeAbandoned false 超过removeAbandonedTimeout时间后，是否进 行没用连接（废弃）的回收 获取连接方式一： 1234567891011121314public static Connection getConnection3() throws Exception &#123; BasicDataSource source = new BasicDataSource(); source.setDriverClassName(&quot;com.mysql.jdbc.Driver&quot;); source.setUrl(&quot;jdbc:mysql:///test&quot;); source.setUsername(&quot;root&quot;); source.setPassword(&quot;abc123&quot;); // source.setInitialSize(10); Connection conn = source.getConnection(); return conn;&#125; 获取连接方式二： 12345678910111213141516171819202122//使用dbcp数据库连接池的配置文件方式，获取数据库的连接：推荐private static DataSource source = null;static&#123; try &#123; Properties pros = new Properties(); InputStream is = DBCPTest.class.getClassLoader().getResourceAsStream(&quot;dbcp.properties&quot;); pros.load(is); //根据提供的BasicDataSourceFactory创建对应的DataSource对象 source = BasicDataSourceFactory.createDataSource(pros); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;public static Connection getConnection4() throws Exception &#123; Connection conn = source.getConnection(); return conn;&#125; 其中，src下的配置文件为：【dbcp.properties】 1234567driverClassName=com.mysql.jdbc.Driverurl=jdbc:mysql://localhost:3306/test?rewriteBatchedStatements=true&amp;useServerPrepStmts=falseusername=rootpassword=abc123initialSize=10#... 8.3.3 Druid（德鲁伊）数据库连接池 Druid是阿里巴巴开源平台上一个数据库连接池实现，它结合了C3P0、DBCP、Proxool等DB池的优点，同时加入了日志监控，可以很好的监控DB池连接和SQL的执行情况，可以说是针对监控而生的DB连接池，可以说是目前最好的连接池之一。 123456789101112131415161718package com.atguigu.druid;import java.sql.Connection;import java.util.Properties;import javax.sql.DataSource;import com.alibaba.druid.pool.DruidDataSourceFactory;public class TestDruid &#123; public static void main(String[] args) throws Exception &#123; Properties pro = new Properties(); pro.load(TestDruid.class.getClassLoader().getResourceAsStream(&quot;druid.properties&quot;)); DataSource ds = DruidDataSourceFactory.createDataSource(pro); Connection conn = ds.getConnection(); System.out.println(conn); &#125;&#125; 其中，src下的配置文件为：【druid.properties】 123456789url=jdbc:mysql://localhost:3306/test?rewriteBatchedStatements=trueusername=rootpassword=123456driverClassName=com.mysql.jdbc.DriverinitialSize=10maxActive=20maxWait=1000filters=wall 详细配置参数： 配置 缺省 说明 name 配置这个属性的意义在于，如果存在多个数据源，监控的时候可以通过名字来区分开来。 如果没有配置，将会生成一个名字，格式是：”DataSource-” + System.identityHashCode(this) url 连接数据库的url，不同数据库不一样。例如：mysql : jdbc:mysql://10.20.153.104:3306/druid2 oracle : jdbc:oracle:thin:@10.20.149.85:1521:ocnauto username 连接数据库的用户名 password 连接数据库的密码。如果你不希望密码直接写在配置文件中，可以使用ConfigFilter。详细看这里：https://github.com/alibaba/druid/wiki/使用ConfigFilter driverClassName 根据url自动识别 这一项可配可不配，如果不配置druid会根据url自动识别dbType，然后选择相应的driverClassName(建议配置下) initialSize 0 初始化时建立物理连接的个数。初始化发生在显示调用init方法，或者第一次getConnection时 maxActive 8 最大连接池数量 maxIdle 8 已经不再使用，配置了也没效果 minIdle 最小连接池数量 maxWait 获取连接时最大等待时间，单位毫秒。配置了maxWait之后，缺省启用公平锁，并发效率会有所下降，如果需要可以通过配置useUnfairLock属性为true使用非公平锁。 poolPreparedStatements false 是否缓存preparedStatement，也就是PSCache。PSCache对支持游标的数据库性能提升巨大，比如说oracle。在mysql下建议关闭。 maxOpenPreparedStatements -1 要启用PSCache，必须配置大于0，当大于0时，poolPreparedStatements自动触发修改为true。在Druid中，不会存在Oracle下PSCache占用内存过多的问题，可以把这个数值配置大一些，比如说100 validationQuery 用来检测连接是否有效的sql，要求是一个查询语句。如果validationQuery为null，testOnBorrow、testOnReturn、testWhileIdle都不会其作用。 testOnBorrow true 申请连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能。 testOnReturn false 归还连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能 testWhileIdle false 建议配置为true，不影响性能，并且保证安全性。申请连接的时候检测，如果空闲时间大于timeBetweenEvictionRunsMillis，执行validationQuery检测连接是否有效。 timeBetweenEvictionRunsMillis 有两个含义： 1)Destroy线程会检测连接的间隔时间2)testWhileIdle的判断依据，详细看testWhileIdle属性的说明 numTestsPerEvictionRun 不再使用，一个DruidDataSource只支持一个EvictionRun minEvictableIdleTimeMillis connectionInitSqls 物理连接初始化的时候执行的sql exceptionSorter 根据dbType自动识别 当数据库抛出一些不可恢复的异常时，抛弃连接 filters 属性类型是字符串，通过别名的方式配置扩展插件，常用的插件有： 监控统计用的filter:stat日志用的filter:log4j防御sql注入的filter:wall proxyFilters 类型是List，如果同时配置了filters和proxyFilters，是组合关系，并非替换关系 第9章：Apache-DBUtils实现CRUD操作 9.1 Apache-DBUtils简介 commons-dbutils 是 Apache 组织提供的一个开源 JDBC工具类库，它是对JDBC的简单封装，学习成本极低，并且使用dbutils能极大简化jdbc编码的工作量，同时也不会影响程序的性能。 API介绍： org.apache.commons.dbutils.QueryRunner org.apache.commons.dbutils.ResultSetHandler 工具类：org.apache.commons.dbutils.DbUtils API包说明： 9.2 主要API的使用 9.2.1 DbUtils DbUtils ：提供如关闭连接、装载JDBC驱动程序等常规工作的工具类，里面的所有方法都是静态的。主要方法如下： public static void close(…) throws java.sql.SQLException： DbUtils类提供了三个重载的关闭方法。这些方法检查所提供的参数是不是NULL，如果不是的话，它们就关闭Connection、Statement和ResultSet。 public static void closeQuietly(…): 这一类方法不仅能在Connection、Statement和ResultSet为NULL情况下避免关闭，还能隐藏一些在程序中抛出的SQLEeception。 public static void commitAndClose(Connection conn)throws SQLException： 用来提交连接的事务，然后关闭连接 public static void commitAndCloseQuietly(Connection conn)： 用来提交连接，然后关闭连接，并且在关闭连接时不抛出SQL异常。 public static void rollback(Connection conn)throws SQLException：允许conn为null，因为方法内部做了判断 public static void rollbackAndClose(Connection conn)throws SQLException rollbackAndCloseQuietly(Connection) public static boolean loadDriver(java.lang.String driverClassName)：这一方装载并注册JDBC驱动程序，如果成功就返回true。使用该方法，你不需要捕捉这个异常ClassNotFoundException。 9.2.2 QueryRunner类 该类简单化了SQL查询，它与ResultSetHandler组合在一起使用可以完成大部分的数据库操作，能够大大减少编码量。 QueryRunner类提供了两个构造器： 默认的构造器 需要一个 javax.sql.DataSource 来作参数的构造器 QueryRunner类的主要方法： 更新 public int update(Connection conn, String sql, Object… params) throws SQLException:用来执行一个更新（插入、更新或删除）操作。 … 插入 public T insert(Connection conn,String sql,ResultSetHandler rsh, Object… params) throws SQLException：只支持INSERT语句，其中 rsh - The handler used to create the result object from the ResultSet of auto-generated keys. 返回值: An object generated by the handler.即自动生成的键值 … 批处理 public int[] batch(Connection conn,String sql,Object[][] params)throws SQLException： INSERT, UPDATE, or DELETE语句 public T insertBatch(Connection conn,String sql,ResultSetHandler rsh,Object[][] params)throws SQLException：只支持INSERT语句 … 查询 public Object query(Connection conn, String sql, ResultSetHandler rsh,Object… params) throws SQLException：执行一个查询操作，在这个查询中，对象数组中的每个元素值被用来作为查询语句的置换参数。该方法会自行处理 PreparedStatement 和 ResultSet 的创建和关闭。 … 测试 12345678910111213// 测试添加@Testpublic void testInsert() throws Exception &#123; QueryRunner runner = new QueryRunner(); Connection conn = JDBCUtils.getConnection3(); String sql = &quot;insert into customers(name,email,birth)values(?,?,?)&quot;; int count = runner.update(conn, sql, &quot;何成飞&quot;, &quot;he@qq.com&quot;, &quot;1992-09-08&quot;); System.out.println(&quot;添加了&quot; + count + &quot;条记录&quot;); JDBCUtils.closeResource(conn, null);&#125; 12345678910111213// 测试删除@Testpublic void testDelete() throws Exception &#123; QueryRunner runner = new QueryRunner(); Connection conn = JDBCUtils.getConnection3(); String sql = &quot;delete from customers where id &lt; ?&quot;; int count = runner.update(conn, sql,3); System.out.println(&quot;删除了&quot; + count + &quot;条记录&quot;); JDBCUtils.closeResource(conn, null);&#125; 9.2.3 ResultSetHandler接口及实现类 该接口用于处理 java.sql.ResultSet，将数据按要求转换为另一种形式。 ResultSetHandler 接口提供了一个单独的方法：Object handle (java.sql.ResultSet .rs)。 接口的主要实现类： ArrayHandler：把结果集中的第一行数据转成对象数组。 ArrayListHandler：把结果集中的每一行数据都转成一个数组，再存放到List中。 **BeanHandler：**将结果集中的第一行数据封装到一个对应的JavaBean实例中。 **BeanListHandler：**将结果集中的每一行数据都封装到一个对应的JavaBean实例中，存放到List里。 ColumnListHandler：将结果集中某一列的数据存放到List中。 KeyedHandler(name)：将结果集中的每一行数据都封装到一个Map里，再把这些map再存到一个map里，其key为指定的key。 **MapHandler：**将结果集中的第一行数据封装到一个Map里，key是列名，value就是对应的值。 **MapListHandler：**将结果集中的每一行数据都封装到一个Map里，然后再存放到List **ScalarHandler：**查询单个值对象 测试 12345678910111213141516171819/* * 测试查询:查询一条记录 * * 使用ResultSetHandler的实现类：BeanHandler */@Testpublic void testQueryInstance() throws Exception&#123; QueryRunner runner = new QueryRunner(); Connection conn = JDBCUtils.getConnection3(); String sql = &quot;select id,name,email,birth from customers where id = ?&quot;; // BeanHandler&lt;Customer&gt; handler = new BeanHandler&lt;&gt;(Customer.class); Customer customer = runner.query(conn, sql, handler, 23); System.out.println(customer); JDBCUtils.closeResource(conn, null);&#125; 1234567891011121314151617181920/* * 测试查询:查询多条记录构成的集合 * * 使用ResultSetHandler的实现类：BeanListHandler */@Testpublic void testQueryList() throws Exception&#123; QueryRunner runner = new QueryRunner(); Connection conn = JDBCUtils.getConnection3(); String sql = &quot;select id,name,email,birth from customers where id &lt; ?&quot;; // BeanListHandler&lt;Customer&gt; handler = new BeanListHandler&lt;&gt;(Customer.class); List&lt;Customer&gt; list = runner.query(conn, sql, handler, 23); list.forEach(System.out::println); JDBCUtils.closeResource(conn, null);&#125; 12345678910111213141516171819202122232425262728293031323334353637/* * 自定义ResultSetHandler的实现类 */@Testpublic void testQueryInstance1() throws Exception&#123; QueryRunner runner = new QueryRunner(); Connection conn = JDBCUtils.getConnection3(); String sql = &quot;select id,name,email,birth from customers where id = ?&quot;; ResultSetHandler&lt;Customer&gt; handler = new ResultSetHandler&lt;Customer&gt;() &#123; @Override public Customer handle(ResultSet rs) throws SQLException &#123; System.out.println(&quot;handle&quot;);// return new Customer(1,&quot;Tom&quot;,&quot;tom@126.com&quot;,new Date(123323432L)); if(rs.next())&#123; int id = rs.getInt(&quot;id&quot;); String name = rs.getString(&quot;name&quot;); String email = rs.getString(&quot;email&quot;); Date birth = rs.getDate(&quot;birth&quot;); return new Customer(id, name, email, birth); &#125; return null; &#125; &#125;; Customer customer = runner.query(conn, sql, handler, 23); System.out.println(customer); JDBCUtils.closeResource(conn, null);&#125; 12345678910111213141516171819202122232425/* * 如何查询类似于最大的，最小的，平均的，总和，个数相关的数据， * 使用ScalarHandler * */@Testpublic void testQueryValue() throws Exception&#123; QueryRunner runner = new QueryRunner(); Connection conn = JDBCUtils.getConnection3(); //测试一：// String sql = &quot;select count(*) from customers where id &lt; ?&quot;;// ScalarHandler handler = new ScalarHandler();// long count = (long) runner.query(conn, sql, handler, 20);// System.out.println(count); //测试二： String sql = &quot;select max(birth) from customers&quot;; ScalarHandler handler = new ScalarHandler(); Date birth = (Date) runner.query(conn, sql, handler); System.out.println(birth); JDBCUtils.closeResource(conn, null);&#125; JDBC总结 12345678910111213141516171819202122232425262728293031323334353637总结@Testpublic void testUpdateWithTx() &#123; Connection conn = null; try &#123; //1.获取连接的操作（ //① 手写的连接：JDBCUtils.getConnection(); //② 使用数据库连接池：C3P0;DBCP;Druid //2.对数据表进行一系列CRUD操作 //① 使用PreparedStatement实现通用的增删改、查询操作（version 1.0 \\ version 2.0)//version2.0的增删改public void update(Connection conn,String sql,Object ... args)&#123;&#125;//version2.0的查询 public &lt;T&gt; T getInstance(Connection conn,Class&lt;T&gt; clazz,String sql,Object ... args)&#123;&#125; //② 使用dbutils提供的jar包中提供的QueryRunner类 //提交数据 conn.commit(); &#125; catch (Exception e) &#123; e.printStackTrace(); try &#123; //回滚数据 conn.rollback(); &#125; catch (SQLException e1) &#123; e1.printStackTrace(); &#125; &#125;finally&#123; //3.关闭连接等操作 //① JDBCUtils.closeResource(); //② 使用dbutils提供的jar包中提供的DbUtils类提供了关闭的相关操作 &#125;&#125; 来自：尚硅谷 JDBC","categories":[{"name":"Java","slug":"Java","permalink":"http://littlewuuu.com/categories/Java/"}],"tags":[{"name":"JavaJDBC","slug":"JavaJDBC","permalink":"http://littlewuuu.com/tags/JavaJDBC/"}]},{"title":"Filter&Listener&Ajax","slug":"黑马/12-Filter&Listener&Ajax","date":"2022-08-21T22:00:00.000Z","updated":"2022-12-01T15:44:18.301Z","comments":true,"path":"2022/08/22/黑马/12-Filter&Listener&Ajax/","link":"","permalink":"http://littlewuuu.com/2022/08/22/%E9%BB%91%E9%A9%AC/12-Filter&Listener&Ajax/","excerpt":"","text":"Filter&amp;Listener&amp;Ajax 今日目标： 能够使用 Filter 完成登陆状态校验功能 能够使用 axios 发送 ajax 请求 熟悉 json 格式，并能使用 Fastjson 完成 java 对象和 json 串的相互转换 使用 axios + json 完成综合案例 1，Filter 1.1 Filter概述 Filter 表示过滤器，是 JavaWeb 三大组件(Servlet、Filter、Listener)之一。Servlet 我们之前都已经学习过了，Filter和Listener 我们今天都会进行学习。 过滤器可以把对资源的请求拦截下来，从而实现一些特殊的功能。 如下图所示，浏览器可以访问服务器上的所有的资源（servlet、jsp、html等） 而在访问到这些资源之前可以使过滤器拦截来下，也就是说在访问资源之前会先经过 Filter，如下图 拦截器拦截到后可以做什么功能呢？ ==过滤器一般完成一些通用的操作。==比如每个资源都要写一些代码完成某个功能，我们总不能在每个资源中写这样的代码吧，而此时我们可以将这些代码写在过滤器中，因为请求每一个资源都要经过过滤器。 我们之前做的品牌数据管理的案例中就已经做了登陆的功能，而如果我们不登录能不能访问到数据呢？我们可以在浏览器直接访问首页 ，可以看到 查询所有 的超链接 当我点击该按钮，居然可以看到品牌的数据 这显然和我们的要求不符。我们希望实现的效果是用户如果登陆过了就跳转到品牌数据展示的页面；如果没有登陆就跳转到登陆页面让用户进行登陆，要实现这个效果需要在每一个资源中都写上这段逻辑，而像这种通用的操作，我们就可以放在过滤器中进行实现。这个就是权限控制，以后我们还会进行细粒度权限控制。过滤器还可以做 统一编码处理、 敏感字符处理 等等… 1.2 Filter快速入门 1.2.1 开发步骤 进行 Filter 开发分成以下三步实现 定义类，实现 Filter接口，并重写其所有方法 配置Filter拦截资源的路径：在类上定义 @WebFilter 注解。而注解的 value 属性值 /* 表示拦截所有的资源 在doFilter方法中输出一句话，并放行 上述代码中的 chain.doFilter(request,response); 就是放行，也就是让其访问本该访问的资源。 1.2.2 代码演示 创建一个项目，项目下有一个 hello.jsp 页面，项目结构如下： pom.xml 配置文件内容如下： 1234567891011121314151617181920212223242526272829303132333435363738&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;org.example&lt;/groupId&gt; &lt;artifactId&gt;filter-demo&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;war&lt;/packaging&gt; &lt;properties&gt; &lt;maven.compiler.source&gt;8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;8&lt;/maven.compiler.target&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;3.1.0&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.tomcat.maven&lt;/groupId&gt; &lt;artifactId&gt;tomcat7-maven-plugin&lt;/artifactId&gt; &lt;version&gt;2.2&lt;/version&gt; &lt;configuration&gt; &lt;port&gt;80&lt;/port&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; hello.jsp 页面内容如下： 123456789&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;hello JSP~&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt; 我们现在在浏览器输入 http://localhost/filter-demo/hello.jsp 访问 hello.jsp 页面，这里是可以访问到 hello.jsp 页面内容的。 接下来编写过滤器。过滤器是 Web 三大组件之一，所以我们将 filter 创建在 com.itheima.web.filter 包下，起名为 FilterDemo 1234567891011121314151617@WebFilter(&quot;/*&quot;)public class FilterDemo implements Filter &#123; @Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException &#123; System.out.println(&quot;FilterDemo...&quot;); &#125; @Override public void init(FilterConfig filterConfig) throws ServletException &#123; &#125; @Override public void destroy() &#123; &#125;&#125; 重启启动服务器，再次重新访问 hello.jsp 页面，这次发现页面没有任何效果，但是在 idea 的控制台可以看到如下内容 上述效果说明 FilterDemo 这个过滤器的 doFilter() 方法执行了，但是为什么在浏览器上看不到 hello.jsp 页面的内容呢？这是因为在 doFilter() 方法中添加放行的方法才能访问到 hello.jsp 页面。那就在 doFilter() 方法中添加放行的代码 12//放行 chain.doFilter(request,response); 再次重启服务器并访问 hello.jsp 页面，发现这次就可以在浏览器上看到页面效果。 FilterDemo 过滤器完整代码如下： 12345678910111213141516171819@WebFilter(&quot;/*&quot;)public class FilterDemo implements Filter &#123; @Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException &#123; System.out.println(&quot;1.FilterDemo...&quot;); //放行 chain.doFilter(request,response); &#125; @Override public void init(FilterConfig filterConfig) throws ServletException &#123; &#125; @Override public void destroy() &#123; &#125;&#125; 1.3 Filter执行流程 如上图是使用过滤器的流程，我们通过以下问题来研究过滤器的执行流程： 放行后访问对应资源，资源访问完成后，还会回到Filter中吗？ 从上图就可以看出肯定 会 回到Filter中 如果回到Filter中，是重头执行还是执行放行后的逻辑呢？ 如果是重头执行的话，就意味着 放行前逻辑 会被执行两次，肯定不会这样设计了；所以访问完资源后，会回到 放行后逻辑，执行该部分代码。 通过上述的说明，我们就可以总结Filter的执行流程如下： 接下来我们通过代码验证一下，在 doFilter() 方法前后都加上输出语句，如下 同时在 hello.jsp 页面加上输出语句，如下 执行访问该资源打印的顺序是按照我们标记的标号进行打印的话，说明我们上边总结出来的流程是没有问题的。启动服务器访问 hello.jsp 页面，在控制台打印的内容如下： 以后我们可以将对请求进行处理的代码放在放行之前进行处理，而如果请求完资源后还要对响应的数据进行处理时可以在放行后进行逻辑处理。 1.4 Filter拦截路径配置 拦截路径表示 Filter 会对请求的哪些资源进行拦截，使用 @WebFilter 注解进行配置。如：@WebFilter(&quot;拦截路径&quot;) 拦截路径有如下四种配置方式： 拦截具体的资源：/index.jsp：只有访问index.jsp时才会被拦截 目录拦截：/user/*：访问/user下的所有资源，都会被拦截 后缀名拦截：*.jsp：访问后缀名为jsp的资源，都会被拦截 拦截所有：/*：访问所有资源，都会被拦截 通过上面拦截路径的学习，大家会发现拦截路径的配置方式和 Servlet 的请求资源路径配置方式一样，但是表示的含义不同。 1.5 过滤器链 1.5.1 概述 过滤器链是指在一个Web应用，可以配置多个过滤器，这多个过滤器称为过滤器链。 如下图就是一个过滤器链，我们学习过滤器链主要是学习过滤器链执行的流程 上图中的过滤器链执行是按照以下流程执行： 执行 Filter1 的放行前逻辑代码 执行 Filter1 的放行代码 执行 Filter2 的放行前逻辑代码 执行 Filter2 的放行代码 访问到资源 执行 Filter2 的放行后逻辑代码 执行 Filter1 的放行后逻辑代码 以上流程串起来就像一条链子，故称之为过滤器链。 1.5.2 代码演示 编写第一个过滤器 FilterDemo ，配置成拦截所有资源 12345678910111213141516171819202122@WebFilter(&quot;/*&quot;)public class FilterDemo implements Filter &#123; @Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException &#123; //1. 放行前，对 request数据进行处理 System.out.println(&quot;1.FilterDemo...&quot;); //放行 chain.doFilter(request,response); //2. 放行后，对Response 数据进行处理 System.out.println(&quot;3.FilterDemo...&quot;); &#125; @Override public void init(FilterConfig filterConfig) throws ServletException &#123; &#125; @Override public void destroy() &#123; &#125;&#125; 编写第二个过滤器 FilterDemo2 ，配置炒年糕拦截所有资源 1234567891011121314151617181920212223@WebFilter(&quot;/*&quot;)public class FilterDemo2 implements Filter &#123; @Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException &#123; //1. 放行前，对 request数据进行处理 System.out.println(&quot;2.FilterDemo...&quot;); //放行 chain.doFilter(request,response); //2. 放行后，对Response 数据进行处理 System.out.println(&quot;4.FilterDemo...&quot;); &#125; @Override public void init(FilterConfig filterConfig) throws ServletException &#123; &#125; @Override public void destroy() &#123; &#125;&#125; 修改 hello.jsp 页面中脚本的输出语句 123456789101112&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;hello JSP~&lt;/h1&gt; &lt;% System.out.println(&quot;3.hello jsp&quot;); %&gt;&lt;/body&gt;&lt;/html&gt; 启动服务器，在浏览器输入 http://localhost/filter-demo/hello.jsp 进行测试，在控制台打印内容如下 从结果可以看到确实是按照我们之前说的执行流程进行执行的。 1.5.3 问题 上面代码中为什么是先执行 FilterDemo ，后执行 FilterDemo2 呢？ 我们现在使用的是注解配置Filter，而这种配置方式的优先级是按照过滤器类名(字符串)的自然排序。 比如有如下两个名称的过滤器 ： BFilterDemo 和 AFilterDemo 。那一定是 AFilterDemo 过滤器先执行。 1.6 案例 1.6.1 需求 访问服务器资源时，需要先进行登录验证，如果没有登录，则自动跳转到登录页面 1.6.2 分析 我们要实现该功能是在每一个资源里加入登陆状态校验的代码吗？显然是不需要的，只需要写一个 Filter ，在该过滤器中进行登陆状态校验即可。而在该 Filter 中逻辑如下： 1.6.3 代码实现 1.6.3.1 创建Filter 在 brand-demo 工程创建 com.itheima.web.filter 包，在该下创建名为 LoginFilter 的过滤器 12345678910111213@WebFilter(&quot;/*&quot;)public class LoginFilter implements Filter &#123; @Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws ServletException, IOException &#123; &#125; public void init(FilterConfig config) throws ServletException &#123; &#125; public void destroy() &#123; &#125;&#125; 1.6.3.2 编写逻辑代码 在 doFilter() 方法中编写登陆状态校验的逻辑代码。 我们首先需要从 session 对象中获取用户信息，但是 ServletRequest 类型的 requset 对象没有获取 session 对象的方法，所以此时需要将 request对象强转成 HttpServletRequest 对象。 1HttpServletRequest req = (HttpServletRequest) request; 然后完成以下逻辑 获取Session对象 从Session对象中获取名为 user 的数据 判断获取到的数据是否是 null 如果不是，说明已经登陆，放行 如果是，说明尚未登陆，将提示信息存储到域对象中并跳转到登陆页面 代码如下： 123456789101112131415161718192021222324252627282930@WebFilter(&quot;/*&quot;)public class LoginFilter implements Filter &#123; @Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws ServletException, IOException &#123; HttpServletRequest req = (HttpServletRequest) request; //1. 判断session中是否有user //如果登录了，那么在相关的 Servlet 中已经把 user 存到 session 中了 HttpSession session = req.getSession(); Object user = session.getAttribute(&quot;user&quot;); //2. 判断user是否为null if(user != null)&#123; // 登录过了 //放行 chain.doFilter(request, response); &#125;else &#123; // 没有登陆，存储提示信息，跳转到登录页面 req.setAttribute(&quot;login_msg&quot;,&quot;您尚未登陆！&quot;); req.getRequestDispatcher(&quot;/login.jsp&quot;).forward(req,response); &#125; &#125; public void init(FilterConfig config) throws ServletException &#123; &#125; public void destroy() &#123; &#125;&#125; 1.6.3.3 测试并抛出问题 在浏览器上输入 http://localhost:8080/brand-demo/ ，可以看到如下页面效果 从上面效果可以看出没有登陆确实是跳转到登陆页面了，但是登陆页面为什么展示成这种效果了呢？ 1.6.3.4 问题分析及解决 因为登陆页面需要 css/login.css 这个文件进行样式的渲染，下图是登陆页面引入的css文件图解 而在请求这个css资源时被过滤器拦截，就相当于没有加载到样式文件导致的。解决这个问题，只需要对所以的登陆相关的资源进行放行即可。还有一种情况就是当我没有用户信息时需要进行注册，而注册时也希望被过滤器放行。 综上，我们需要在判断session中是否包含用户信息之前，应该加上对登陆及注册相关资源放行的逻辑处理 1234567891011121314151617181920//判断访问资源路径是否和登录注册相关//1,在数组中存储登陆和注册相关的资源路径String[] urls = &#123;&quot;/login.jsp&quot;,&quot;/imgs/&quot;,&quot;/css/&quot;,&quot;/loginServlet&quot;,&quot;/register.jsp&quot;,&quot;/registerServlet&quot;,&quot;/checkCodeServlet&quot;&#125;;//2,获取当前访问的资源路径String url = req.getRequestURL().toString(); //3,遍历数组，获取到每一个需要放行的资源路径for (String u : urls) &#123; //4,判断当前访问的资源路径字符串是否包含要放行的的资源路径字符串 /* 比如当前访问的资源路径是 /brand-demo/login.jsp 而字符串 /brand-demo/login.jsp 包含了 字符串 /login.jsp ，所以这个字符串就需要放行 */ if(url.contains(u))&#123; //找到了，放行 chain.doFilter(request, response); //break; return; &#125;&#125; 1.6.3.5 过滤器完整代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950@WebFilter(&quot;/*&quot;)public class LoginFilter implements Filter &#123; @Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws ServletException, IOException &#123; HttpServletRequest req = (HttpServletRequest) request; //判断访问资源路径是否和登录注册相关 //1,在数组中存储登陆和注册相关的资源路径 String[] urls = &#123;&quot;/login.jsp&quot;,&quot;/imgs/&quot;,&quot;/css/&quot;,&quot;/loginServlet&quot;,&quot;/register.jsp&quot;,&quot;/registerServlet&quot;,&quot;/checkCodeServlet&quot;&#125;; //2,获取当前访问的资源路径 String url = req.getRequestURL().toString(); //3,遍历数组，获取到每一个需要放行的资源路径 for (String u : urls) &#123; //4,判断当前访问的资源路径字符串是否包含要放行的的资源路径字符串 /* 比如当前访问的资源路径是 /brand-demo/login.jsp 而字符串 /brand-demo/login.jsp 包含了 字符串 /login.jsp ，所以这个字符串就需要放行 */ if(url.contains(u))&#123; //找到了，放行 chain.doFilter(request, response); //break; return; &#125; &#125; //1. 判断session中是否有user HttpSession session = req.getSession(); Object user = session.getAttribute(&quot;user&quot;); //2. 判断user是否为null if(user != null)&#123; // 登录过了 //放行 chain.doFilter(request, response); &#125;else &#123; // 没有登陆，存储提示信息，跳转到登录页面 req.setAttribute(&quot;login_msg&quot;,&quot;您尚未登陆！&quot;); req.getRequestDispatcher(&quot;/login.jsp&quot;).forward(req,response); &#125; &#125; public void init(FilterConfig config) throws ServletException &#123; &#125; public void destroy() &#123; &#125;&#125; 2，Listener 2.1 概述 Listener 表示监听器，是 JavaWeb 三大组件(Servlet、Filter、Listener)之一。 监听器可以监听就是在 application，session，request 三个对象创建、销毁或者往其中添加修改删除属性时自动执行代码的功能组件。 request 和 session 我们学习过。而 application 是 ServletContext 类型的对象。 ServletContext 代表整个web应用，在服务器启动的时候，tomcat会自动创建该对象。在服务器关闭时会自动销毁该对象。 2.2 分类 JavaWeb 提供了8个监听器： 这里面只有 ServletContextListener 这个监听器后期我们会接触到，ServletContextListener 是用来监听 ServletContext 对象的创建和销毁。 ServletContextListener 接口中有以下两个方法 void contextInitialized(ServletContextEvent sce)：ServletContext 对象被创建了会自动执行的方法 void contextDestroyed(ServletContextEvent sce)：ServletContext 对象被销毁时会自动执行的方法 2.3 代码演示 我们只演示一下 ServletContextListener 监听器 定义一个类，实现ServletContextListener 接口 重写所有的抽象方法 使用 @WebListener 进行配置 代码如下： 12345678910111213@WebListenerpublic class ContextLoaderListener implements ServletContextListener &#123; @Override public void contextInitialized(ServletContextEvent sce) &#123; //加载资源 System.out.println(&quot;ContextLoaderListener...&quot;); &#125; @Override public void contextDestroyed(ServletContextEvent sce) &#123; //释放资源 &#125;&#125; 启动服务器，就可以在启动的日志信息中看到 contextInitialized() 方法输出的内容，同时也说明了 ServletContext 对象在服务器启动的时候被创建了。 3，Ajax 3.1 概述 AJAX (Asynchronous JavaScript And XML)：异步的 JavaScript 和 XML。 我们先来说概念中的 JavaScript 和 XML，JavaScript 表明该技术和前端相关；XML 是指以此进行数据交换。而这两个我们之前都学习过。 3.1.1 作用 AJAX 作用有以下两方面： 与服务器进行数据交换：通过AJAX可以给服务器发送请求，服务器将数据直接响应回给浏览器。如下图 我们先来看之前做功能的流程，如下图： 如上图，Servlet 调用完业务逻辑层后将数据存储到域对象中，然后跳转到指定的 jsp 页面，在页面上使用 EL表达式 和 JSTL 标签库进行数据的展示。 而我们学习了AJAX 后，就可以使用AJAX和服务器进行通信，以达到使用 HTML+AJAX来替换JSP页面了。如下图，浏览器发送请求servlet，servlet 调用完业务逻辑层后将数据直接响应回给浏览器页面，页面使用 HTML 来进行数据展示。 异步交互：可以在不重新加载整个页面的情况下，与服务器交换数据并更新部分网页的技术，如：搜索联想、用户名是否可用校验，等等… 上图所示的效果我们经常见到，在我们输入一些关键字（例如 奥运）后就会在下面联想出相关的内容，而联想出来的这部分数据肯定是存储在百度的服务器上，而我们并没有看出页面重新刷新，这就是 更新局部页面 的效果。再如下图： 我们在用户名的输入框输入用户名，当输入框一失去焦点，如果用户名已经被占用就会在下方展示提示的信息；在这整个过程中也没有页面的刷新，只是在局部展示出了提示信息，这就是 更新局部页面 的效果。 3.1.2 同步和异步 知道了局部刷新后，接下来我们再聊聊同步和异步: 同步发送请求过程如下 ​ 浏览器页面在发送请求给服务器，在服务器处理请求的过程中，浏览器页面不能做其他的操作。只能等到服务器响应结束后才能，浏览器页面才能继续做其他的操作。 异步发送请求过程如下 浏览器页面发送请求给服务器，在服务器处理请求的过程中，浏览器页面还可以做其他的操作。 3.2 快速入门 3.2.1 服务端实现 在项目的创建 com.itheima.web.servlet ，并在该包下创建名为 AjaxServlet 的servlet 12345678910111213@WebServlet(&quot;/ajaxServlet&quot;)public class AjaxServlet extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; //1. 响应数据 response.getWriter().write(&quot;hello ajax~&quot;); &#125; @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; this.doGet(request, response); &#125;&#125; 3.2.2 客户端实现 在 webapp 下创建名为 01-ajax-demo1.html 的页面，在该页面书写 ajax 代码 创建核心对象，不同的浏览器创建的对象是不同的 1234567 var xhttp;if (window.XMLHttpRequest) &#123; xhttp = new XMLHttpRequest();&#125; else &#123; // code for IE6, IE5 xhttp = new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);&#125; 发送请求 1234//建立连接xhttp.open(&quot;GET&quot;, &quot;http://localhost:8080/ajax-demo/ajaxServlet&quot;);//发送请求xhttp.send(); 获取响应 123456xhttp.onreadystatechange = function() &#123; if (this.readyState == 4 &amp;&amp; this.status == 200) &#123; // 通过 this.responseText 可以获取到服务端响应的数据 alert(this.responseText); &#125;&#125;; 完整代码如下： 123456789101112131415161718192021222324252627282930&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;script&gt; //1. 创建核心对象 var xhttp; if (window.XMLHttpRequest) &#123; xhttp = new XMLHttpRequest(); &#125; else &#123; // code for IE6, IE5 xhttp = new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;); &#125; //2. 发送请求 xhttp.open(&quot;GET&quot;, &quot;http://localhost:8080/ajax-demo/ajaxServlet&quot;); xhttp.send(); //3. 获取响应 xhttp.onreadystatechange = function() &#123; if (this.readyState == 4 &amp;&amp; this.status == 200) &#123; alert(this.responseText); &#125; &#125;;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 3.2.3 测试 在浏览器地址栏输入 http://localhost:8080/ajax-demo/01-ajax-demo1.html ，在 01-ajax-demo1.html加载的时候就会发送 ajax 请求，效果如下 我们可以通过 开发者模式 查看发送的 AJAX 请求。在浏览器上按 F12 快捷键 这个是查看所有的请求，如果我们只是想看 异步请求的话，点击上图中 All 旁边的 XHR，会发现只展示 Type 是 xhr 的请求。如下图： 3.3 案例 需求：在完成用户注册时，当用户名输入框失去焦点时，校验用户名是否在数据库已存在 3.3.1 分析 前端完成的逻辑 给用户名输入框绑定光标失去焦点事件 onblur 发送 ajax请求，携带username参数 处理响应：是否显示提示信息 后端完成的逻辑 接收用户名 调用service查询User。此案例是为了演示前后端异步交互，所以此处我们不做业务逻辑处理 返回标记 整体流程如下： 3.3.2 后端实现 在 com.ithiema.web.servlet 包中定义名为 SelectUserServlet 的servlet。代码如下： 1234567891011121314151617@WebServlet(&quot;/selectUserServlet&quot;)public class SelectUserServlet extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; //1. 接收用户名 String username = request.getParameter(&quot;username&quot;); //2. 调用service查询User对象，此处不进行业务逻辑处理，直接给 flag 赋值为 true，表明用户名占用 boolean flag = true; //3. 响应标记 response.getWriter().write(&quot;&quot; + flag); &#125; @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; this.doGet(request, response); &#125;&#125; 3.3.3 前端实现 将 04-资料\\1. 验证用户名案例\\1. 静态页面 下的文件整体拷贝到项目下 webapp 下。并在 register.html 页面的 body 结束标签前编写 script 标签，在该标签中实现如下逻辑 第一步：给用户名输入框绑定光标失去焦点事件 onblur 1234//1. 给用户名输入框绑定 失去焦点事件document.getElementById(&quot;username&quot;).onblur = function () &#123; &#125; 第二步：发送 ajax请求，携带username参数 在 第一步 绑定的匿名函数中书写发送 ajax 请求的代码 12345678910111213141516171819//2. 发送ajax请求//2.1. 创建核心对象var xhttp;if (window.XMLHttpRequest) &#123; xhttp = new XMLHttpRequest();&#125; else &#123; // code for IE6, IE5 xhttp = new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);&#125;//2.2. 发送请求xhttp.open(&quot;GET&quot;, &quot;http://localhost:8080/ajax-demo/selectUserServlet);xhttp.send();//2.3. 获取响应xhttp.onreadystatechange = function() &#123; if (this.readyState == 4 &amp;&amp; this.status == 200) &#123; //处理响应的结果 &#125;&#125;; 由于我们发送的是 GET 请求，所以需要在 URL 后拼接从输入框获取的用户名数据。而我们在 第一步 绑定的匿名函数中通过以下代码可以获取用户名数据 12// 获取用户名的值var username = this.value; //this ： 给谁绑定的事件，this就代表谁 而携带数据需要将 URL 修改为： 1xhttp.open(&quot;GET&quot;, &quot;http://localhost:8080/ajax-demo/selectUserServlet?username=&quot;+username); 第三步：处理响应：是否显示提示信息 当 this.readyState == 4 &amp;&amp; this.status == 200 条件满足时，说明已经成功响应数据了。 此时需要判断响应的数据是否是 “true” 字符串，如果是说明用户名已经占用给出错误提示；如果不是说明用户名未被占用清除错误提示。代码如下 12345678//判断if(this.responseText == &quot;true&quot;)&#123; //用户名存在，显示提示信息 document.getElementById(&quot;username_err&quot;).style.display = &#x27;&#x27;;&#125;else &#123; //用户名不存在 ，清楚提示信息 document.getElementById(&quot;username_err&quot;).style.display = &#x27;none&#x27;;&#125; 综上所述，前端完成代码如下： 123456789101112131415161718192021222324252627282930313233//1. 给用户名输入框绑定 失去焦点事件document.getElementById(&quot;username&quot;).onblur = function () &#123; //2. 发送ajax请求 // 获取用户名的值 var username = this.value; //2.1. 创建核心对象 var xhttp; if (window.XMLHttpRequest) &#123; xhttp = new XMLHttpRequest(); &#125; else &#123; // code for IE6, IE5 xhttp = new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;); &#125; //2.2. 发送请求 xhttp.open(&quot;GET&quot;, &quot;http://localhost:8080/ajax-demo/selectUserServlet?username=&quot;+username); xhttp.send(); //2.3. 获取响应 xhttp.onreadystatechange = function() &#123; if (this.readyState == 4 &amp;&amp; this.status == 200) &#123; //alert(this.responseText); //判断 if(this.responseText == &quot;true&quot;)&#123; //用户名存在，显示提示信息 document.getElementById(&quot;username_err&quot;).style.display = &#x27;&#x27;; &#125;else &#123; //用户名不存在 ，清楚提示信息 document.getElementById(&quot;username_err&quot;).style.display = &#x27;none&#x27;; &#125; &#125; &#125;;&#125; 4，axios Axios 对原生的AJAX进行封装，简化书写。 Axios官网是：https://www.axios-http.cn 4.1 基本使用 axios 使用是比较简单的，分为以下两步： 引入 axios 的 js 文件 12&lt;script src=&quot;js/axios-0.18.0.js&quot;&gt;&lt;/script&gt;//js 目录下面的 axios-0.18.0.js 文件 使用axios 发送请求，并获取响应结果 发送 get 请求 123456axios(&#123; method:&quot;get&quot;, url:&quot;http://localhost:8080/ajax-demo1/aJAXDemo1?username=zhangsan&quot;&#125;).then(function (resp)&#123; alert(resp.data);&#125;) 发送 post 请求 1234567axios(&#123; method:&quot;post&quot;, url:&quot;http://localhost:8080/ajax-demo1/aJAXDemo1&quot;, data:&quot;username=zhangsan&quot;&#125;).then(function (resp)&#123; alert(resp.data);&#125;); axios() 是用来发送异步请求的，小括号中使用 js 对象传递请求相关的参数： method 属性：用来设置请求方式的。取值为 get 或者 post。 url 属性：用来书写请求的资源路径。如果是 get 请求，需要将请求参数拼接到路径的后面，格式为： url?参数名=参数值&amp;参数名2=参数值2。 data 属性：作为请求体被发送的数据。也就是说如果是 post 请求的话，数据需要作为 data 属性的值。 then() 需要传递一个匿名函数。我们将 then() 中传递的匿名函数称为 回调函数，**意思是该匿名函数在发送请求时不会被调用，而是在成功响应后调用的函数。**而该回调函数中的 resp 参数是对响应的数据进行封装的对象，通过 resp.data 可以获取到响应的数据。 4.2 快速入门 4.2.1 后端实现 定义一个用于接收请求的servlet，代码如下： 123456789101112131415161718@WebServlet(&quot;/axiosServlet&quot;)public class AxiosServlet extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; System.out.println(&quot;get...&quot;); //1. 接收请求参数 String username = request.getParameter(&quot;username&quot;); System.out.println(username); //2. 响应数据 response.getWriter().write(&quot;hello Axios~&quot;); &#125; @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; System.out.println(&quot;post...&quot;); this.doGet(request, response); &#125;&#125; 4.2.2 前端实现 引入 js 文件 1&lt;script src=&quot;js/axios-0.18.0.js&quot;&gt;&lt;/script&gt; 发送 ajax 请求 get 请求 123456axios(&#123; method:&quot;get&quot;, url:&quot;http://localhost:8080/ajax-demo/axiosServlet?username=zhangsan&quot;&#125;).then(function (resp) &#123; alert(resp.data);&#125;) post 请求 1234567axios(&#123; method:&quot;post&quot;, url:&quot;http://localhost:8080/ajax-demo/axiosServlet&quot;, data:&quot;username=zhangsan&quot;&#125;).then(function (resp) &#123; alert(resp.data);&#125;) 整体页面代码如下： 1234567891011121314151617181920212223242526272829&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;script src=&quot;js/axios-0.18.0.js&quot;&gt;&lt;/script&gt;&lt;script&gt; //1. get /* axios(&#123; method:&quot;get&quot;, url:&quot;http://localhost:8080/ajax-demo/axiosServlet?username=zhangsan&quot; &#125;).then(function (resp) &#123; alert(resp.data); &#125;)*/ //2. post 在js中&#123;&#125; 表示一个js对象，而这个js对象中有三个属性 axios(&#123; method:&quot;post&quot;, url:&quot;http://localhost:8080/ajax-demo/axiosServlet&quot;, data:&quot;username=zhangsan&quot; &#125;).then(function (resp) &#123; alert(resp.data); &#125;)&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 4.3 请求方法别名（简化版） 为了方便起见， Axios 已经为所有支持的请求方法提供了别名。如下： get 请求 ： axios.get(url[,config]) delete 请求 ： axios.delete(url[,config]) head 请求 ： axios.head(url[,config]) options 请求 ： axios.option(url[,config]) post 请求：axios.post(url[,data[,config]) put 请求：axios.put(url[,data[,config]) patch 请求：axios.patch(url[,data[,config]) 而我们只关注 get 请求和 post 请求。 入门案例中的 get 请求代码可以改为如下： 123axios.get(&quot;http://localhost:8080/ajax-demo/axiosServlet?username=zhangsan&quot;).then(function (resp) &#123; alert(resp.data);&#125;); 入门案例中的 post 请求代码可以改为如下： 123axios.post(&quot;http://localhost:8080/ajax-demo/axiosServlet&quot;,&quot;username=zhangsan&quot;).then(function (resp) &#123; alert(resp.data);&#125;) 5，JSON 5.1 概述 概念：JavaScript Object Notation。JavaScript 对象表示法. 如下是 JavaScript 对象的定义格式： 12345&#123; name:&quot;zhangsan&quot;, age:23, city:&quot;北京&quot;&#125; 接下来我们再看看 JSON 的格式： 12345&#123; &quot;name&quot;:&quot;zhangsan&quot;, &quot;age&quot;:23, &quot;city&quot;:&quot;北京&quot;&#125; 通过上面 js 对象格式和 json 格式进行对比，发现两个格式特别像。只不过 js 对象中的属性名可以使用引号（可以是单引号，也可以是双引号）；而 json 格式中的键要求必须使用双引号括起来，这是 json 格式的规定。json 格式的数据有什么作用呢？ 作用：由于其语法格式简单，层次结构鲜明，现多用于作为数据载体，在网络中进行数据传输。如下图所示就是服务端给浏览器响应的数据，这个数据比较简单，如果现需要将 JAVA 对象中封装的数据响应回给浏览器的话，应该以何种数据传输呢？ 大家还记得 ajax 的概念吗？ 是 异步的 JavaScript 和 xml。这里的 xml就是以前进行数据传递的方式，如下： 12345&lt;student&gt; &lt;name&gt;张三&lt;/name&gt; &lt;age&gt;23&lt;/age&gt; &lt;city&gt;北京&lt;/city&gt;&lt;/student&gt; 再看 json 描述以上数据的写法： 12345&#123; &quot;name&quot;:&quot;张三&quot;, &quot;age&quot;:23, &quot;city&quot;:&quot;北京&quot;&#125; 上面两种格式进行对比后就会发现 json 格式数据的简单，以及所占的字节数少等优点。 5.2 JSON 基础语法 5.2.1 定义格式 JSON 本质就是一个字符串，但是该字符串内容是有一定的格式要求的。 定义格式如下： 1234var 变量名 = &#123;&quot;key&quot;:value, &quot;key&quot;:value, ... &#125;; JSON 串的键要求必须使用双引号括起来，而值根据要表示的类型确定。value 的数据类型分为如下 数字（整数或浮点数） 字符串（使用双引号括起来） 逻辑值（true或者false） 数组（在方括号中） 对象（在花括号中） null 示例： 1234var jsonStr = &#123;&quot;name&quot;:&quot;zhangsan&quot;, &quot;age&quot;:23, &quot;addr&quot;:[&quot;北京&quot;,&quot;上海&quot;,&quot;西安&quot;] &#125;; 5.2.2 代码演示 创建一个页面，在该页面的 &lt;script&gt; 标签中定义json字符串 1234567891011121314151617&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;script&gt; //1. 定义JSON字符串 var jsonStr = &#123;&quot;name&quot;:&quot;zhangsan&quot;, &quot;age&quot;:23, &quot;addr&quot;:[&quot;北京&quot;,&quot;上海&quot;,&quot;西安&quot;]&#125;; alert(jsonStr);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 通过浏览器打开，页面效果如下图所示 现在我们需要获取到该 JSON 串中的 name 属性值，应该怎么处理呢？ 如果它是一个 js 对象，我们就可以通过 js对象.属性名 的方式来获取数据。JS 提供了一个对象 JSON ，该对象有如下两个方法： parse(str) ：将 JSON串转换为 js 对象。使用方式是： var jsObject = JSON.parse(jsonStr); stringify(obj) ：将 js 对象转换为 JSON 串。使用方式是：var jsonStr = JSON.stringify(jsObject) 代码演示： 12345678910111213141516171819202122&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;script&gt; //1. 定义JSON字符串 var jsonStr = &#x27;&#123;&quot;name&quot;:&quot;zhangsan&quot;,&quot;age&quot;:23,&quot;addr&quot;:[&quot;北京&quot;,&quot;上海&quot;,&quot;西安&quot;]&#125;&#x27; alert(jsonStr); //2. 将 JSON 字符串转为 JS 对象 let jsObject = JSON.parse(jsonStr); alert(jsObject) alert(jsObject.name) //3. 将 JS 对象转换为 JSON 字符串 let jsonStr2 = JSON.stringify(jsObject); alert(jsonStr2)&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 5.2.3 发送异步请求携带参数 后面我们使用 axios 发送请求时，如果要携带复杂的数据时都会以 JSON 格式进行传递，如下 1234567axios(&#123; method:&quot;post&quot;, url:&quot;http://localhost:8080/ajax-demo/axiosServlet&quot;, data:&quot;username=zhangsan&quot;&#125;).then(function (resp) &#123; alert(resp.data);&#125;) 请求参数不可能由我们自己拼接字符串吧？肯定不用，可以提前定义一个 js 对象，用来封装需要提交的参数，然后使用 JSON.stringify(js对象) 转换为 JSON 串，再将该 JSON 串作为 axios 的 data 属性值进行请求参数的提交。如下： 123456789var jsObject = &#123;name:&quot;张三&quot;&#125;;axios(&#123; method:&quot;post&quot;, url:&quot;http://localhost:8080/ajax-demo/axiosServlet&quot;, data: JSON.stringify(jsObject)&#125;).then(function (resp) &#123; alert(resp.data);&#125;) 而 axios 是一个很强大的工具。我们只需要将需要提交的参数封装成 js 对象，并将该 js 对象作为 axios 的 data 属性值进行，它会自动将 js 对象转换为 JSON 串进行提交。如下： 123456789var jsObject = &#123;name:&quot;张三&quot;&#125;;axios(&#123; method:&quot;post&quot;, url:&quot;http://localhost:8080/ajax-demo/axiosServlet&quot;, data:jsObject //这里 axios 会将该js对象转换为 json 串的&#125;).then(function (resp) &#123; alert(resp.data);&#125;) 注意： js 提供的 JSON 对象我们只需要了解一下即可。因为 axios 会自动对 js 对象和 JSON 串进行想换转换。 发送异步请求时，如果请求参数是 JSON 格式，那请求方式必须是 POST。因为 JSON 串需要放在请求体中。 5.3 JSON串和Java对象的相互转换 学习完 json 后，接下来聊聊 json 的作用。以后我们会以 json 格式的数据进行前后端交互。前端发送请求时，如果是复杂的数据就会以 json 提交给后端；而后端如果需要响应一些复杂的数据时，也需要以 json 格式将数据响应回给浏览器。 在后端我们就需要重点学习以下两部分操作： 请求数据：JSON字符串转为Java对象 响应数据：Java对象转为JSON字符串 接下来给大家介绍一套 API，可以实现上面两部分操作。这套 API 就是 Fastjson 5.3.1 Fastjson 概述 Fastjson 是阿里巴巴提供的一个Java语言编写的高性能功能完善的 JSON 库，是目前Java语言中最快的 JSON 库，可以实现 Java 对象和 JSON 字符串的相互转换。 5.3.2 Fastjson 使用 Fastjson 使用也是比较简单的，分为以下三步完成 导入坐标 12345&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.2.62&lt;/version&gt;&lt;/dependency&gt; Java对象转JSON 1String jsonStr = JSON.toJSONString(obj); 将 Java 对象转换为 JSON 串，只需要使用 Fastjson 提供的 JSON 类中的 toJSONString() 静态方法即可。 JSON字符串转Java对象 1User user = JSON.parseObject(jsonStr, User.class); 将 json 转换为 Java 对象，只需要使用 Fastjson 提供的 JSON 类中的 parseObject() 静态方法即可。 5.3.3 代码演示 引入坐标 创建一个类，专门用来测试 Java 对象和 JSON 串的相互转换，代码如下： 123456789101112131415161718public class FastJsonDemo &#123; public static void main(String[] args) &#123; //1. 将Java对象转为JSON字符串 User user = new User(); user.setId(1); user.setUsername(&quot;zhangsan&quot;); user.setPassword(&quot;123&quot;); String jsonString = JSON.toJSONString(user); System.out.println(jsonString);//&#123;&quot;id&quot;:1,&quot;password&quot;:&quot;123&quot;,&quot;username&quot;:&quot;zhangsan&quot;&#125; //2. 将JSON字符串转为Java对象 User u = JSON.parseObject(&quot;&#123;\\&quot;id\\&quot;:1,\\&quot;password\\&quot;:\\&quot;123\\&quot;,\\&quot;username\\&quot;:\\&quot;zhangsan\\&quot;&#125;&quot;, User.class); System.out.println(u); &#125;&#125; 6，案例 6.1 需求 使用Axios + JSON 完成品牌列表数据查询和添加。页面效果还是下图所示： 6.2 查询所有功能 如上图所示就该功能的整体流程。前后端需以 JSON 格式进行数据的传递；由于此功能是查询所有的功能，前端发送 ajax 请求不需要携带参数，而后端响应数据需以如下格式的 json 数据 6.2.1 环境准备 将 02-AJAX\\04-资料\\3. 品牌列表案例\\初始工程 下的 brand-demo 工程拷贝到我们自己 工作空间 ，然后再将项目导入到我们自己的 Idea 中。工程目录结构如下： 注意： 在给定的原始工程中已经给定一些代码。而在此案例中我们只关注前后端交互代码实现 要根据自己的数据库环境去修改连接数据库的信息，在 mybatis-config.xml 核心配置文件中修改 6.2.2 后端实现 在 com.itheima.web 包下创建名为 SelectAllServlet 的 servlet，具体的逻辑如下： 调用 service 的 selectAll() 方法进行查询所有的逻辑处理 将查询到的集合数据转换为 json 数据。我们将此过程称为 序列化；如果是将 json 数据转换为 Java 对象，我们称之为 反序列化 将 json 数据响应回给浏览器。这里一定要设置响应数据的类型及字符集 response.setContentType(&quot;text/json;charset=utf-8&quot;); SelectAllServlet 代码如下： 12345678910111213141516171819202122@WebServlet(&quot;/selectAllServlet&quot;)public class SelectAllServlet extends HttpServlet &#123; private BrandService brandService = new BrandService(); @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; //1. 调用Service查询 List&lt;Brand&gt; brands = brandService.selectAll(); //2. 将集合转换为JSON数据 序列化 String jsonString = JSON.toJSONString(brands); //3. 响应数据 application/json text/json response.setContentType(&quot;text/json;charset=utf-8&quot;); response.getWriter().write(jsonString); &#125; @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; this.doGet(request, response); &#125;&#125; 6.2.3 前端实现 引入 js 文件 在 brand.html 页面引入 axios 的 js 文件 1&lt;script src=&quot;js/axios-0.18.0.js&quot;&gt;&lt;/script&gt; 绑定 页面加载完毕 事件 在 brand.html 页面绑定加载完毕事件，该事件是在页面加载完毕后被触发，代码如下 123window.onload = function() &#123; &#125; 发送异步请求 在页面加载完毕事件绑定的匿名函数中发送异步请求，代码如下： 1234567 //2. 发送ajax请求axios(&#123; method:&quot;get&quot;, url:&quot;http://localhost:8080/brand-demo/selectAllServlet&quot;&#125;).then(function (resp) &#123;&#125;); 处理响应数据 在 then 中的回调函数中通过 resp.data 可以获取响应回来的数据，而数据格式如下 现在我们需要拼接字符串，将下面表格中的所有的 tr 拼接到一个字符串中，然后使用 document.getElementById(&quot;brandTable&quot;).innerHTML = 拼接好的字符串 就可以动态的展示出用户想看到的数据 而表头行是固定的，所以先定义初始值是表头行数据的字符串，如下 1234567891011//获取数据let brands = resp.data;let tableData = &quot; &lt;tr&gt;\\n&quot; + &quot; &lt;th&gt;序号&lt;/th&gt;\\n&quot; + &quot; &lt;th&gt;品牌名称&lt;/th&gt;\\n&quot; + &quot; &lt;th&gt;企业名称&lt;/th&gt;\\n&quot; + &quot; &lt;th&gt;排序&lt;/th&gt;\\n&quot; + &quot; &lt;th&gt;品牌介绍&lt;/th&gt;\\n&quot; + &quot; &lt;th&gt;状态&lt;/th&gt;\\n&quot; + &quot; &lt;th&gt;操作&lt;/th&gt;\\n&quot; + &quot; &lt;/tr&gt;&quot;; 接下来遍历响应回来的数据 brands ，拿到每一条品牌数据 1234for (let i = 0; i &lt; brands.length ; i++) &#123; let brand = brands[i]; &#125; 紧接着就是从 brand 对象中获取数据并且拼接 数据行，累加到 tableData 字符串变量中 1234567891011tableData += &quot;\\n&quot; + &quot; &lt;tr align=\\&quot;center\\&quot;&gt;\\n&quot; + &quot; &lt;td&gt;&quot;+(i+1)+&quot;&lt;/td&gt;\\n&quot; + &quot; &lt;td&gt;&quot;+brand.brandName+&quot;&lt;/td&gt;\\n&quot; + &quot; &lt;td&gt;&quot;+brand.companyName+&quot;&lt;/td&gt;\\n&quot; + &quot; &lt;td&gt;&quot;+brand.ordered+&quot;&lt;/td&gt;\\n&quot; + &quot; &lt;td&gt;&quot;+brand.description+&quot;&lt;/td&gt;\\n&quot; + &quot; &lt;td&gt;&quot;+brand.status+&quot;&lt;/td&gt;\\n&quot; + &quot;\\n&quot; + &quot; &lt;td&gt;&lt;a href=\\&quot;#\\&quot;&gt;修改&lt;/a&gt; &lt;a href=\\&quot;#\\&quot;&gt;删除&lt;/a&gt;&lt;/td&gt;\\n&quot; + &quot; &lt;/tr&gt;&quot;; 最后再将拼接好的字符串写到表格中 12// 设置表格数据document.getElementById(&quot;brandTable&quot;).innerHTML = tableData; 整体页面代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;a href=&quot;addBrand.html&quot;&gt;&lt;input type=&quot;button&quot; value=&quot;新增&quot;&gt;&lt;/a&gt;&lt;br&gt;&lt;hr&gt;&lt;table id=&quot;brandTable&quot; border=&quot;1&quot; cellspacing=&quot;0&quot; width=&quot;100%&quot;&gt; &lt;/table&gt;&lt;script src=&quot;js/axios-0.18.0.js&quot;&gt;&lt;/script&gt;&lt;script&gt; //1. 当页面加载完成后，发送ajax请求 window.onload = function () &#123; //2. 发送ajax请求 axios(&#123; method:&quot;get&quot;, url:&quot;http://localhost:8080/brand-demo/selectAllServlet&quot; &#125;).then(function (resp) &#123; //获取数据 let brands = resp.data; let tableData = &quot; &lt;tr&gt;\\n&quot; + &quot; &lt;th&gt;序号&lt;/th&gt;\\n&quot; + &quot; &lt;th&gt;品牌名称&lt;/th&gt;\\n&quot; + &quot; &lt;th&gt;企业名称&lt;/th&gt;\\n&quot; + &quot; &lt;th&gt;排序&lt;/th&gt;\\n&quot; + &quot; &lt;th&gt;品牌介绍&lt;/th&gt;\\n&quot; + &quot; &lt;th&gt;状态&lt;/th&gt;\\n&quot; + &quot; &lt;th&gt;操作&lt;/th&gt;\\n&quot; + &quot; &lt;/tr&gt;&quot;; for (let i = 0; i &lt; brands.length ; i++) &#123; let brand = brands[i]; tableData += &quot;\\n&quot; + &quot; &lt;tr align=\\&quot;center\\&quot;&gt;\\n&quot; + &quot; &lt;td&gt;&quot;+(i+1)+&quot;&lt;/td&gt;\\n&quot; + &quot; &lt;td&gt;&quot;+brand.brandName+&quot;&lt;/td&gt;\\n&quot; + &quot; &lt;td&gt;&quot;+brand.companyName+&quot;&lt;/td&gt;\\n&quot; + &quot; &lt;td&gt;&quot;+brand.ordered+&quot;&lt;/td&gt;\\n&quot; + &quot; &lt;td&gt;&quot;+brand.description+&quot;&lt;/td&gt;\\n&quot; + &quot; &lt;td&gt;&quot;+brand.status+&quot;&lt;/td&gt;\\n&quot; + &quot;\\n&quot; + &quot; &lt;td&gt;&lt;a href=\\&quot;#\\&quot;&gt;修改&lt;/a&gt; &lt;a href=\\&quot;#\\&quot;&gt;删除&lt;/a&gt;&lt;/td&gt;\\n&quot; + &quot; &lt;/tr&gt;&quot;; &#125; // 设置表格数据 document.getElementById(&quot;brandTable&quot;).innerHTML = tableData; &#125;) &#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 6.3 添加品牌功能 如上所示，当我们点击 新增 按钮，会跳转到 addBrand.html 页面。在 addBrand.html 页面输入数据后点击 提交 按钮，就会将数据提交到后端，而后端将数据保存到数据库中。 具体的前后端交互的流程如下： 说明： 前端需要将用户输入的数据提交到后端，这部分数据需要以 json 格式进行提交，数据格式如下： 6.3.1 后端实现 在 com.itheima.web 包下创建名为 AddServlet 的 servlet，具体的逻辑如下： 获取请求参数 由于前端提交的是 json 格式的数据，所以我们不能使用 request.getParameter() 方法获取请求参数 如果提交的数据格式是 username=zhangsan&amp;age=23 ，后端就可以使用 request.getParameter() 方法获取 如果提交的数据格式是 json，后端就需要通过 request 对象获取输入流，再通过输入流读取数据 将获取到的请求参数（json格式的数据）转换为 Brand 对象 调用 service 的 add() 方法进行添加数据的逻辑处理 将 json 数据响应回给浏览器。 AddServlet 代码如下： 12345678910111213141516171819202122232425262728@WebServlet(&quot;/addServlet&quot;)public class AddServlet extends HttpServlet &#123; private BrandService brandService = new BrandService(); @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; //1. 接收数据,request.getParameter 不能接收json的数据 /* String brandName = request.getParameter(&quot;brandName&quot;); System.out.println(brandName);*/ // 获取请求体数据 BufferedReader br = request.getReader(); String params = br.readLine(); // 将JSON字符串转为Java对象 Brand brand = JSON.parseObject(params, Brand.class); //2. 调用service 添加 brandService.add(brand); //3. 响应成功标识 response.getWriter().write(&quot;success&quot;); &#125; @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; this.doGet(request, response); &#125;&#125; 6.3.2 前端实现 在 addBrand.html 页面给 提交 按钮绑定点击事件，并在绑定的匿名函数中发送异步请求，代码如下： 1234567891011121314//1. 给按钮绑定单击事件document.getElementById(&quot;btn&quot;).onclick = function () &#123; //2. 发送ajax请求 axios(&#123; method:&quot;post&quot;, url:&quot;http://localhost:8080/brand-demo/addServlet&quot;, data:??? &#125;).then(function (resp) &#123; // 判断响应数据是否为 success if(resp.data == &quot;success&quot;)&#123; location.href = &quot;http://localhost:8080/brand-demo/brand.html&quot;; &#125; &#125;)&#125; 现在我们只需要考虑如何获取页面上用户输入的数据即可。 首先我们先定义如下的一个 js 对象，该对象是用来封装页面上输入的数据，并将该对象作为上面发送异步请求时 data 属性的值。 12345678// 将表单数据转为jsonvar formData = &#123; brandName:&quot;&quot;, companyName:&quot;&quot;, ordered:&quot;&quot;, description:&quot;&quot;, status:&quot;&quot;,&#125;; 接下来获取输入框输入的数据，并将获取到的数据赋值给 formData 对象指定的属性。比如获取用户名的输入框数据，并把该数据赋值给 formData 对象的 brandName 属性 1234// 获取表单数据let brandName = document.getElementById(&quot;brandName&quot;).value;// 设置数据formData.brandName = brandName; ==说明：其他的输入框都用同样的方式获取并赋值。==但是有一个比较特殊，就是状态数据，如下图是页面内容 我们需要判断哪儿个被选中，再将选中的单选框数据赋值给 formData 对象的 status 属性，代码实现如下： 1234567let status = document.getElementsByName(&quot;status&quot;);for (let i = 0; i &lt; status.length; i++) &#123; if(status[i].checked)&#123; // formData.status = status[i].value ; &#125;&#125; 整体页面代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;添加品牌&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h3&gt;添加品牌&lt;/h3&gt;&lt;form action=&quot;&quot; method=&quot;post&quot;&gt; 品牌名称：&lt;input id=&quot;brandName&quot; name=&quot;brandName&quot;&gt;&lt;br&gt; 企业名称：&lt;input id=&quot;companyName&quot; name=&quot;companyName&quot;&gt;&lt;br&gt; 排序：&lt;input id=&quot;ordered&quot; name=&quot;ordered&quot;&gt;&lt;br&gt; 描述信息：&lt;textarea rows=&quot;5&quot; cols=&quot;20&quot; id=&quot;description&quot; name=&quot;description&quot;&gt;&lt;/textarea&gt;&lt;br&gt; 状态： &lt;input type=&quot;radio&quot; name=&quot;status&quot; value=&quot;0&quot;&gt;禁用 &lt;input type=&quot;radio&quot; name=&quot;status&quot; value=&quot;1&quot;&gt;启用&lt;br&gt; &lt;input type=&quot;button&quot; id=&quot;btn&quot; value=&quot;提交&quot;&gt;&lt;/form&gt;&lt;script src=&quot;js/axios-0.18.0.js&quot;&gt;&lt;/script&gt;&lt;script&gt; //1. 给按钮绑定单击事件 document.getElementById(&quot;btn&quot;).onclick = function () &#123; // 将表单数据转为json var formData = &#123; brandName:&quot;&quot;, companyName:&quot;&quot;, ordered:&quot;&quot;, description:&quot;&quot;, status:&quot;&quot;, &#125;; // 获取表单数据 let brandName = document.getElementById(&quot;brandName&quot;).value; // 设置数据 formData.brandName = brandName; // 获取表单数据 let companyName = document.getElementById(&quot;companyName&quot;).value; // 设置数据 formData.companyName = companyName; // 获取表单数据 let ordered = document.getElementById(&quot;ordered&quot;).value; // 设置数据 formData.ordered = ordered; // 获取表单数据 let description = document.getElementById(&quot;description&quot;).value; // 设置数据 formData.description = description; let status = document.getElementsByName(&quot;status&quot;); for (let i = 0; i &lt; status.length; i++) &#123; if(status[i].checked)&#123; //checked表示被选择了 formData.status = status[i].value ; &#125; &#125; //console.log(formData); //2. 发送ajax请求 axios(&#123; method:&quot;post&quot;, url:&quot;http://localhost:8080/brand-demo/addServlet&quot;, data:formData &#125;).then(function (resp) &#123; // 判断响应数据是否为 success if(resp.data == &quot;success&quot;)&#123; location.href = &quot;http://localhost:8080/brand-demo/brand.html&quot;; &#125; &#125;) &#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 说明： 查询所有 功能和 添加品牌 功能就全部实现，大家肯定会感觉前端的代码很复杂；而这只是暂时的，后面学习了 vue 前端框架后，这部分前端代码就可以进行很大程度的简化。 来源：it 黑马 JavaWeb 教程","categories":[{"name":"Java","slug":"Java","permalink":"http://littlewuuu.com/categories/Java/"}],"tags":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://littlewuuu.com/tags/JavaWeb/"}]},{"title":"FinalCase","slug":"黑马/14-综合案例","date":"2022-08-21T22:00:00.000Z","updated":"2022-12-01T15:44:38.822Z","comments":true,"path":"2022/08/22/黑马/14-综合案例/","link":"","permalink":"http://littlewuuu.com/2022/08/22/%E9%BB%91%E9%A9%AC/14-%E7%BB%BC%E5%90%88%E6%A1%88%E4%BE%8B/","excerpt":"","text":"综合案例 今日目标： 能够完成查询所有功能 能够完成添加功能 能够理解 BaseServlet 思想 能够完成批量删除功能 能够完成分页查询功能 能够完成条件查询功能 1，功能介绍 以上是我们在综合案例要实现的功能。对数据的除了对数据的增删改查功能外，还有一些复杂的功能，如 批量删除、分页查询、条件查询 等功能 批量删除 功能：每条数据前都有复选框，当我选中多条数据并点击 批量删除 按钮后，会发送请求到后端并删除数据库中指定的多条数据。 分页查询 功能：当数据库中有很多数据时，我们不可能将所有的数据展示在一页里，这个时候就需要分页展示数据。 条件查询 功能：数据库量大的时候，我们就需要精确的查询一些想看到的数据，这个时候就需要通过条件查询。 这里的 修改品牌 和 删除品牌 功能在课程上不做讲解，留作同学来下的练习。 2，环境准备 环境准备我们主要完成以下两件事即可 将资料的 brand-case 模块导入到 idea中 执行资料中提供的 tb_brand.sql脚本 2.1 工程准备 将 04-资料\\01-初始工程 中的 brand-case 工程导入到我们自己的 idea 中。工程结构如下： 2.2 创建表 下面是创建表的语句 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768-- 删除tb_brand表drop table if exists tb_brand;-- 创建tb_brand表create table tb_brand ( -- id 主键 id int primary key auto_increment, -- 品牌名称 brand_name varchar(20), -- 企业名称 company_name varchar(20), -- 排序字段 ordered int, -- 描述信息 description varchar(100), -- 状态：0：禁用 1：启用 status int);-- 添加数据insert into tb_brand (brand_name, company_name, ordered, description, status)values (&#x27;华为&#x27;, &#x27;华为技术有限公司&#x27;, 100, &#x27;万物互联&#x27;, 1), (&#x27;小米&#x27;, &#x27;小米科技有限公司&#x27;, 50, &#x27;are you ok&#x27;, 1), (&#x27;格力&#x27;, &#x27;格力电器股份有限公司&#x27;, 30, &#x27;让世界爱上中国造&#x27;, 1), (&#x27;阿里巴巴&#x27;, &#x27;阿里巴巴集团控股有限公司&#x27;, 10, &#x27;买买买&#x27;, 1), (&#x27;腾讯&#x27;, &#x27;腾讯计算机系统有限公司&#x27;, 50, &#x27;玩玩玩&#x27;, 0), (&#x27;百度&#x27;, &#x27;百度在线网络技术公司&#x27;, 5, &#x27;搜搜搜&#x27;, 0), (&#x27;京东&#x27;, &#x27;北京京东世纪贸易有限公司&#x27;, 40, &#x27;就是快&#x27;, 1), (&#x27;小米&#x27;, &#x27;小米科技有限公司&#x27;, 50, &#x27;are you ok&#x27;, 1), (&#x27;三只松鼠&#x27;, &#x27;三只松鼠股份有限公司&#x27;, 5, &#x27;好吃不上火&#x27;, 0), (&#x27;华为&#x27;, &#x27;华为技术有限公司&#x27;, 100, &#x27;万物互联&#x27;, 1), (&#x27;小米&#x27;, &#x27;小米科技有限公司&#x27;, 50, &#x27;are you ok&#x27;, 1), (&#x27;格力&#x27;, &#x27;格力电器股份有限公司&#x27;, 30, &#x27;让世界爱上中国造&#x27;, 1), (&#x27;阿里巴巴&#x27;, &#x27;阿里巴巴集团控股有限公司&#x27;, 10, &#x27;买买买&#x27;, 1), (&#x27;腾讯&#x27;, &#x27;腾讯计算机系统有限公司&#x27;, 50, &#x27;玩玩玩&#x27;, 0), (&#x27;百度&#x27;, &#x27;百度在线网络技术公司&#x27;, 5, &#x27;搜搜搜&#x27;, 0), (&#x27;京东&#x27;, &#x27;北京京东世纪贸易有限公司&#x27;, 40, &#x27;就是快&#x27;, 1), (&#x27;华为&#x27;, &#x27;华为技术有限公司&#x27;, 100, &#x27;万物互联&#x27;, 1), (&#x27;小米&#x27;, &#x27;小米科技有限公司&#x27;, 50, &#x27;are you ok&#x27;, 1), (&#x27;格力&#x27;, &#x27;格力电器股份有限公司&#x27;, 30, &#x27;让世界爱上中国造&#x27;, 1), (&#x27;阿里巴巴&#x27;, &#x27;阿里巴巴集团控股有限公司&#x27;, 10, &#x27;买买买&#x27;, 1), (&#x27;腾讯&#x27;, &#x27;腾讯计算机系统有限公司&#x27;, 50, &#x27;玩玩玩&#x27;, 0), (&#x27;百度&#x27;, &#x27;百度在线网络技术公司&#x27;, 5, &#x27;搜搜搜&#x27;, 0), (&#x27;京东&#x27;, &#x27;北京京东世纪贸易有限公司&#x27;, 40, &#x27;就是快&#x27;, 1), (&#x27;小米&#x27;, &#x27;小米科技有限公司&#x27;, 50, &#x27;are you ok&#x27;, 1), (&#x27;三只松鼠&#x27;, &#x27;三只松鼠股份有限公司&#x27;, 5, &#x27;好吃不上火&#x27;, 0), (&#x27;华为&#x27;, &#x27;华为技术有限公司&#x27;, 100, &#x27;万物互联&#x27;, 1), (&#x27;小米&#x27;, &#x27;小米科技有限公司&#x27;, 50, &#x27;are you ok&#x27;, 1), (&#x27;格力&#x27;, &#x27;格力电器股份有限公司&#x27;, 30, &#x27;让世界爱上中国造&#x27;, 1), (&#x27;阿里巴巴&#x27;, &#x27;阿里巴巴集团控股有限公司&#x27;, 10, &#x27;买买买&#x27;, 1), (&#x27;腾讯&#x27;, &#x27;腾讯计算机系统有限公司&#x27;, 50, &#x27;玩玩玩&#x27;, 0), (&#x27;百度&#x27;, &#x27;百度在线网络技术公司&#x27;, 5, &#x27;搜搜搜&#x27;, 0), (&#x27;京东&#x27;, &#x27;北京京东世纪贸易有限公司&#x27;, 40, &#x27;就是快&#x27;, 1), (&#x27;华为&#x27;, &#x27;华为技术有限公司&#x27;, 100, &#x27;万物互联&#x27;, 1), (&#x27;小米&#x27;, &#x27;小米科技有限公司&#x27;, 50, &#x27;are you ok&#x27;, 1), (&#x27;格力&#x27;, &#x27;格力电器股份有限公司&#x27;, 30, &#x27;让世界爱上中国造&#x27;, 1), (&#x27;阿里巴巴&#x27;, &#x27;阿里巴巴集团控股有限公司&#x27;, 10, &#x27;买买买&#x27;, 1), (&#x27;腾讯&#x27;, &#x27;腾讯计算机系统有限公司&#x27;, 50, &#x27;玩玩玩&#x27;, 0), (&#x27;百度&#x27;, &#x27;百度在线网络技术公司&#x27;, 5, &#x27;搜搜搜&#x27;, 0), (&#x27;京东&#x27;, &#x27;北京京东世纪贸易有限公司&#x27;, 40, &#x27;就是快&#x27;, 1), (&#x27;小米&#x27;, &#x27;小米科技有限公司&#x27;, 50, &#x27;are you ok&#x27;, 1), (&#x27;三只松鼠&#x27;, &#x27;三只松鼠股份有限公司&#x27;, 5, &#x27;好吃不上火&#x27;, 0), (&#x27;华为&#x27;, &#x27;华为技术有限公司&#x27;, 100, &#x27;万物互联&#x27;, 1), (&#x27;小米&#x27;, &#x27;小米科技有限公司&#x27;, 50, &#x27;are you ok&#x27;, 1), (&#x27;格力&#x27;, &#x27;格力电器股份有限公司&#x27;, 30, &#x27;让世界爱上中国造&#x27;, 1), (&#x27;阿里巴巴&#x27;, &#x27;阿里巴巴集团控股有限公司&#x27;, 10, &#x27;买买买&#x27;, 1), (&#x27;腾讯&#x27;, &#x27;腾讯计算机系统有限公司&#x27;, 50, &#x27;玩玩玩&#x27;, 0), (&#x27;百度&#x27;, &#x27;百度在线网络技术公司&#x27;, 5, &#x27;搜搜搜&#x27;, 0), (&#x27;京东&#x27;, &#x27;北京京东世纪贸易有限公司&#x27;, 40, &#x27;就是快&#x27;, 1); 3，查询所有功能 如上图所示是查询所有品牌数据在页面展示的效果。要实现这个功能，要先搞明白如下问题： 什么时候发送异步请求？ 页面加载完毕后就需要在页面上看到所有的品牌数据。所以在 mounted() 这个构造函数中写发送异步请求的代码。 请求需要携带参数吗？ 查询所有功能不需要携带什么参数。 响应的数据格式是什么样？ 后端是需要将 List&lt;Brand&gt; 对象转换为 JSON 格式的数据并响应回给浏览器。响应数据格式如下： 整体流程如下 我们先实现后端程序，然后再实现前端程序。 3.1 后端实现 3.1.1 dao方法实现 在 com.itheima.mapper.BrandMapper 接口中定义抽象方法，并使用 @Select 注解编写 sql 语句 123456/** * 查询所有 * @return */@Select(&quot;select * from tb_brand&quot;)List&lt;Brand&gt; selectAll(); 由于表中有些字段名和实体类中的属性名没有对应，所以需要在 com/itheima/mapper/BrandMapper.xml 映射配置文件中定义结果映射 ，使用resultMap 标签。映射配置文件内容如下： 1234567891011&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.itheima.mapper.BrandMapper&quot;&gt; &lt;resultMap id=&quot;brandResultMap&quot; type=&quot;brand&quot;&gt; &lt;result property=&quot;brandName&quot; column=&quot;brand_name&quot; /&gt; &lt;result property=&quot;companyName&quot; column=&quot;company_name&quot; /&gt; &lt;/resultMap&gt;&lt;/mapper&gt; 定义完结果映射关系后，在接口 selectAll() 方法上引用该结构映射。使用 @ResultMap(&quot;brandResultMap&quot;) 注解 完整接口的 selectAll() 方法如下： 1234567/** * 查询所有 * @return */@Select(&quot;select * from tb_brand&quot;)@ResultMap(&quot;brandResultMap&quot;)List&lt;Brand&gt; selectAll(); 3.1.2 service方法实现 在 com.itheima.service 包下创建 BrandService 接口，在该接口中定义查询所有的抽象方法 12345678public interface BrandService &#123; /** * 查询所有 * @return */ List&lt;Brand&gt; selectAll();&#125; 并在 com.itheima.service 下再创建 impl 包；impl 表示是放 service 层接口的实现类的包。 在该包下创建名为 BrandServiceImpl 类 123456public class BrandServiceImpl implements BrandService &#123; @Override public List&lt;Brand&gt; selectAll() &#123; &#125;&#125; 此处为什么要给 service 定义接口呢？因为service定义了接口后，在 servlet 中就可以使用多态的形式创建Service实现类的对象，如下： 这里使用多态是因为方便我们后期解除 Servlet 和 service 的耦合。从上面的代码我们可以看到 SelectAllServlet 类和 BrandServiceImpl 类之间是耦合在一起的，如果后期 BrandService 有其它更好的实现类（例如叫 BrandServiceImpl），那就需要修改 SelectAllServlet 类中的代码。后面我们学习了 Spring 框架后就可以解除 SelectAllServlet 类和红色框括起来的代码耦合。而现在咱们还做不到解除耦合，在这里只需要理解为什么定义接口即可。 BrandServiceImpl 类代码如下： 1234567891011121314151617181920public class BrandServiceImpl implements BrandService &#123; //1. 创建SqlSessionFactory 工厂对象 SqlSessionFactory factory = SqlSessionFactoryUtils.getSqlSessionFactory(); @Override public List&lt;Brand&gt; selectAll() &#123; //2. 获取SqlSession对象 SqlSession sqlSession = factory.openSession(); //3. 获取BrandMapper BrandMapper mapper = sqlSession.getMapper(BrandMapper.class); //4. 调用方法 List&lt;Brand&gt; brands = mapper.selectAll(); //5. 释放资源 sqlSession.close(); return brands; &#125;&#125; 3.1.3 servlet实现 在 com.itheima.web.servlet 包下定义名为 SelectAllServlet 的查询所有的 servlet。该 servlet 逻辑如下： 调用service的 selectAll() 方法查询所有的品牌数据，并接口返回结果 将返回的结果转换为 json 数据 响应 json 数据 代码如下： 123456789101112131415161718192021@WebServlet(&quot;/selectAllServlet&quot;)public class SelectAllServlet extends HttpServlet &#123; private BrandService brandService = new BrandServiceImpl(); @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; //1. 调用service查询 List&lt;Brand&gt; brands = brandService.selectAll(); //2. 转为JSON String jsonString = JSON.toJSONString(brands); //3. 写数据 response.setContentType(&quot;text/json;charset=utf-8&quot;); //告知浏览器响应的数据是什么， 告知浏览器使用什么字符集进行解码 response.getWriter().write(jsonString); &#125; @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; this.doGet(request, response); &#125;&#125; 3.1.4 测试后端程序 在浏览器输入访问 servlet 的资源路径 http://localhost:8080/brand-case/selectAllServlet ，如果没有报错，并能看到如下信息表明后端程序没有问题 3.2 前端实现 前端需要在页面加载完毕后发送 ajax 请求，所以发送请求的逻辑应该放在 mounted() 钩子函数中。而响应回来的数据需要赋值给表格绑定的数据模型，从下图可以看出表格绑定的数据模型是 tableData 前端代码如下： 1234567891011mounted()&#123; //当页面加载完成后，发送异步请求，获取数据 var _this = this; axios(&#123; method:&quot;get&quot;, url:&quot;http://localhost:8080/brand-case/selectAllServlet&quot; &#125;).then(function (resp) &#123; _this.tableData = resp.data; &#125;)&#125; 4，添加功能 上图是添加数据的对话框，当点击 提交 按钮后就需要将数据提交到后端，并将数据保存到数据库中。下图是整体的流程： 页面发送请求时，需要将输入框输入的内容提交给后端程序，而这里是以 json 格式进行传递的。而具体的数据格式如下： 注意：由于是添加数据，所以上述json数据中id是没有值的。 4.1 后端实现 4.1.1 dao方法实现 在 BrandMapper 接口中定义 add() 添加方法，并使用 @Insert 注解编写sql语句 123456/** * 添加数据 * @param brand */@Insert(&quot;insert into tb_brand values(null,#&#123;brandName&#125;,#&#123;companyName&#125;,#&#123;ordered&#125;,#&#123;description&#125;,#&#123;status&#125;)&quot;)void add(Brand brand); 4.1.2 service方法实现 在 BrandService 接口中定义 add() 添加数据的业务逻辑方法 12345/** * 添加数据 * @param brand */void add(Brand brand); 在 BrandServiceImpl 类中重写 add() 方法，并进行业务逻辑实现 1234567891011121314@Overridepublic void add(Brand brand) &#123; //2. 获取SqlSession对象 SqlSession sqlSession = factory.openSession(); //3. 获取BrandMapper BrandMapper mapper = sqlSession.getMapper(BrandMapper.class); //4. 调用方法 mapper.add(brand); sqlSession.commit();//提交事务 //5. 释放资源 sqlSession.close();&#125; 注意：增删改操作一定要提交事务。 4.1.3 servlet实现 在 com.itheima.web.servlet 包写定义名为 AddServlet 的 Servlet。该 Servlet 的逻辑如下： 接收页面提交的数据。页面到时候提交的数据是 json 格式的数据，所以此处需要使用输入流读取数据 将接收到的数据转换为 Brand 对象 调用 service 的 add() 方法进行添加的业务逻辑处理 给浏览器响应添加成功的标识，这里直接给浏览器响应 success 字符串表示成功 servlet 代码实现如下： 123456789101112131415161718192021222324@WebServlet(&quot;/addServlet&quot;)public class AddServlet extends HttpServlet &#123; private BrandService brandService = new BrandServiceImpl(); @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; //1. 接收品牌数据 BufferedReader br = request.getReader(); String params = br.readLine();//json字符串 //转为Brand对象 Brand brand = JSON.parseObject(params, Brand.class); //2. 调用service添加 brandService.add(brand); //3. 响应成功的标识 response.getWriter().write(&quot;success&quot;); &#125; @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; this.doGet(request, response); &#125;&#125; 4.2 前端实现 上图左边是页面效果，里面的 提交 按钮可以通过上图右边看出绑定了一个 单击事件，而该事件绑定的是 addBrand 函数，所以添加数据功能的逻辑代码应该写在 addBrand() 函数中。在此方法中需要发送异步请求并将表单中输入的数据作为参数进行传递。如下 12345678910111213// 添加数据addBrand() &#123; var _this = this; // 发送ajax请求，添加数据 axios(&#123; method:&quot;post&quot;, url:&quot;http://localhost:8080/brand-case/addServlet&quot;, data:_this.brand &#125;).then(function (resp) &#123; //响应数据的处理逻辑 &#125;)&#125; 在 then 函数中的匿名函数是成功后的回调函数，而 resp.data 就可以获取到响应回来的数据，如果值是 success 表示数据添加成功。成功后我们需要做一下逻辑处理： 关闭新增对话框窗口 如下图所示是添加数据的对话框代码，从代码中可以看到此对话框绑定了 dialogVisible 数据模型，只需要将该数据模型的值设置为 false，就可以关闭新增对话框窗口了。 重新查询数据 数据添加成功与否，用户只要能在页面上查看到数据说明添加成功。而此处需要重新发送异步请求获取所有的品牌数据，而这段代码在 查询所有 功能中已经实现，所以我们可以将此功能代码进行抽取，抽取到一个 selectAll() 函数中 1234567891011// 查询所有数据selectAll()&#123; var _this = this; axios(&#123; method:&quot;get&quot;, url:&quot;http://localhost:8080/brand-case/selectAllServlet&quot; &#125;).then(function (resp) &#123; _this.tableData = resp.data; &#125;)&#125; 那么就需要将 mounted() 钩子函数中代码改进为 1234mounted()&#123; //当页面加载完成后，发送异步请求，获取数据 this.selectAll();&#125; 同时在新增响应的回调中调用 selectAll() 进行数据的重新查询。 弹出消息给用户提示添加成功 上图左边就是 elementUI 官网提供的成功提示代码，而上图右边是具体的效果。 注意：上面的this需要的是表示 VUE 对象的this。 综上所述，前端代码如下： 123456789101112131415161718192021222324// 添加数据addBrand() &#123; var _this = this; // 发送ajax请求，添加数据 axios(&#123; method:&quot;post&quot;, url:&quot;http://localhost:8080/brand-case/addServlet&quot;, data:_this.brand &#125;).then(function (resp) &#123; if(resp.data == &quot;success&quot;)&#123; //添加成功 //关闭窗口 _this.dialogVisible = false; // 重新查询数据 _this.selectAll(); // 弹出消息提示 _this.$message(&#123; message: &#x27;恭喜你，添加成功&#x27;, type: &#x27;success&#x27; &#125;); &#125; &#125;)&#125; 5，servlet优化 5.1 问题导入 Web 层的 Servlet 个数太多了，不利于管理和编写 通过之前的两个功能，我们发现每一个功能都需要定义一个 servlet，一个模块需要实现增删改查功能，就需要4个 servlet，模块一多就会造成servlet 泛滥。此时我们就想 servlet 能不能像 service 一样，一个模块只定义一个 servlet，而每一个功能只需要在该 servlet 中定义对应的方法。例如下面代码： 1234567891011121314@WebServlet(&quot;/brand/*&quot;)public class BrandServlet &#123; //查询所有 public void selectAll(...) &#123;&#125; //添加数据 public void add(...) &#123;&#125; //修改数据 public void update(...) &#123;&#125; //删除删除 public void delete(...) &#123;&#125;&#125; 而我们知道发送请求 servlet，tomcat 会自动的调用 service() 方法，之前我们在自定义的 servlet 中重写 doGet() 方法和 doPost() 方法，当我们访问该 servlet 时会根据请求方式将请求分发给 doGet() 或者 doPost() 方法，如下图 那么我们也可以仿照这样请求分发的思想，在 service() 方法中根据具体的操作调用对应的方法，如：查询所有就调用 selectAll() 方法，添加企业信息就调用 add() 方法。 为了做到通用，我们定义一个通用的 servlet 类，在定义其他的 servlet 是不需要继承 HttpServlet，而继承我们定义的 BaseServlet，在 BaseServlet 中调用具体 servlet（如BrandServlet）中的对应方法。 123456public class BaseServlet extends HttpServlet &#123; @Override protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //进行请求的分发 &#125;&#125; BrandServlet 定义就需要修改为如下： 1234567891011121314@WebServlet(&quot;/brand/*&quot;)public class BrandServlet extends BaseServlet &#123; //用户实现分页查询 public void selectAll(...) &#123;&#125; //添加企业信息 public void add(...) &#123;&#125; //修改企业信息 public void update(...) &#123;&#125; //删除企业信息 public void delete(...) &#123;&#125;&#125; 那么如何在 BaseServlet 中调用对应的方法呢？比如查询所有就调用 selectAll() 方法。 可以规定在发送请求时，请求资源的二级路径（/brandServlet/selectAll）和需要调用的方法名相同，如： 查询所有数据的路径以后就需要写成： http://localhost:8080/brand-case/brandServlet/selectAll 添加数据的路径以后就需要写成： http://localhost:8080/brand-case/brandServlet/add 修改数据的路径以后就需要写成： http://localhost:8080/brand-case/brandServlet/update 删除数据的路径以后就需要写成： http://localhost:8080/brand-case/brandServlet/delete 这样的话，在 BaseServlet 中就需要获取到资源的二级路径作为方法名，然后调用该方法 12345678910111213141516171819202122232425262728public class BaseServlet extends HttpServlet &#123; @Override protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //1. 获取请求路径 String uri = req.getRequestURI(); // 例如路径为：/brand-case/brand/selectAll //2. 获取最后一段路径，方法名 int index = uri.lastIndexOf(&#x27;/&#x27;); String methodName = uri.substring(index + 1); // 获取到资源的二级路径 selectAll //2. 执行方法 //2.1 获取BrandServlet /UserServlet 字节码对象 Class //System.out.println(this); Class&lt;? extends BaseServlet&gt; cls = this.getClass(); //2.2 获取方法 Method对象 try &#123; Method method = cls.getMethod(methodName,？？？); //4,调用该方法 method.invoke(this,？？？); &#125; catch (NoSuchMethodException e) &#123; e.printStackTrace(); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; catch (InvocationTargetException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 通过上面代码发现根据方法名获取对应方法的 Method 对象时需要指定方法参数的字节码对象。解决这个问题，可以将方法的参数类型规定死，而方法中可能需要用到 request 对象和 response 对象，所以指定方法的参数为 HttpServletRequest 和 HttpServletResponse，那么 BrandServlet 代码就可以改进为： 1234567891011121314@WebServlet(&quot;/brand/*&quot;)public class BrandServlet extends BaseServlet &#123; //用户实现分页查询 public void selectAll(HttpServletRequest req, HttpServletResponse resp) &#123;&#125; //添加企业信息 public void add(HttpServletRequest req, HttpServletResponse resp) &#123;&#125; //修改企业信息 public void update(HttpServletRequest req, HttpServletResponse resp) &#123;&#125; //删除企业信息 public void delete(HttpServletRequest req, HttpServletResponse resp) &#123;&#125;&#125; BaseServlet代码可以改进为： 123456789101112131415161718192021222324252627282930public class BaseServlet extends HttpServlet &#123; //根据请求的最后一段路径来进行方法分发 @Override protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //1. 获取请求路径 String uri = req.getRequestURI(); // 例如路径为：/brand-case/brand/selectAll //2. 获取最后一段路径，方法名 int index = uri.lastIndexOf(&#x27;/&#x27;); String methodName = uri.substring(index + 1); // 获取到资源的二级路径 selectAll //2. 执行方法 //2.1 获取BrandServlet /UserServlet 字节码对象 Class //System.out.println(this); Class&lt;? extends BaseServlet&gt; cls = this.getClass(); //2.2 获取方法 Method对象 try &#123; Method method = cls.getMethod(methodName, HttpServletRequest.class, HttpServletResponse.class); //2.3 执行方法 method.invoke(this,req,resp); &#125; catch (NoSuchMethodException e) &#123; e.printStackTrace(); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; catch (InvocationTargetException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 5.2 代码优化 5.2.1 后端优化 定义了 BaseServlet 后，针对品牌模块我们定义一个 BrandServlet 的 Servlet，并使其继承 BaseServlet 。在BrandServlet中定义 以下功能的方法： 查询所有 功能：方法名声明为 selectAll ，并将之前的 SelectAllServlet 中的逻辑代码拷贝到该方法中 添加数据 功能：方法名声明为 add ，并将之前的 AddServlet 中的逻辑代码拷贝到该方法中 具体代码如下： 12345678910111213141516171819202122232425262728293031@WebServlet(&quot;/brand/*&quot;)public class BrandServlet extends BaseServlet&#123; private BrandService brandService = new BrandServiceImpl(); public void selectAll(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; //1. 调用service查询 List&lt;Brand&gt; brands = brandService.selectAll(); //2. 转为JSON String jsonString = JSON.toJSONString(brands); //3. 写数据 response.setContentType(&quot;text/json;charset=utf-8&quot;); response.getWriter().write(jsonString); &#125; public void add(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; //1. 接收品牌数据 BufferedReader br = request.getReader(); String params = br.readLine();//json字符串 //转为Brand对象 Brand brand = JSON.parseObject(params, Brand.class); //2. 调用service添加 brandService.add(brand); //3. 响应成功的标识 response.getWriter().write(&quot;success&quot;); &#125;&#125; 5.2.2 前端优化 页面中之前发送的请求的路径都需要进行修改，selectAll() 函数中发送异步请求的 url 应该改为 http://localhost:8080/brand-case/brand/selectAll 。具体代码如下： 1234567891011// 查询分页数据selectAll()&#123; var _this = this; axios(&#123; method:&quot;get&quot;, url:&quot;http://localhost:8080/brand-case/brand/selectAll&quot; &#125;).then(function (resp) &#123; _this.tableData = resp.data; &#125;)&#125; addBrand() 函数中发送异步请求的 url 应该改为 http://localhost:8080/brand-case/brand/add 。具体代码如下： 12345678910111213141516171819202122232425// 添加数据addBrand() &#123; //console.log(this.brand); var _this = this; // 发送ajax请求，添加数据 axios(&#123; method:&quot;post&quot;, url:&quot;http://localhost:8080/brand-case/brand/add&quot;, data:_this.brand &#125;).then(function (resp) &#123; if(resp.data == &quot;success&quot;)&#123; //添加成功 //关闭窗口 _this.dialogVisible = false; // 重新查询数据 _this.selectAll(); // 弹出消息提示 _this.$message(&#123; message: &#x27;恭喜你，添加成功&#x27;, type: &#x27;success&#x27; &#125;); &#125; &#125;)&#125; 6，批量删除 如上图所示点击多条数据前的复选框就意味着要删除这些数据，而点击了 批量删除 按钮后，需要让用户确认一下，因为有可能是用户误操作的，当用户确定后需要给后端发送请求并携带者需要删除数据的多个id值，后端程序删除数据库中的数据。具体的流程如下： 注意： 前端发送请求时需要将要删除的多个id值以json格式提交给后端，而该json格式数据如下： 1[1,2,3,4] 6.1 后端实现 6.1.1 dao方法实现 在 BrandMapper 接口中定义 deleteByIds() 添加方法，由于这里面要用到动态 sql ，属于复杂的sql操作，建议使用映射配置文件。 接口方法声明如下： 12345 /** * 批量删除 * @param ids */void deleteByIds(@Param(&quot;ids&quot;) int[] ids); 在 BrandMapper.xml 映射配置文件中添加 statement 123456&lt;delete id=&quot;deleteByIds&quot;&gt; delete from tb_brand where id in &lt;foreach collection=&quot;ids&quot; item=&quot;id&quot; separator=&quot;,&quot; open=&quot;(&quot; close=&quot;)&quot;&gt; #&#123;id&#125; &lt;/foreach&gt;&lt;/delete&gt; 6.1.2 service方法实现 在 BrandService 接口中定义 deleteByIds() 批量删除的业务逻辑方法 12345/** * 批量删除 * @param ids */void deleteByIds( int[] ids); 在 BrandServiceImpl 类中重写 deleteByIds() 方法，并进行业务逻辑实现 123456789101112131415@Overridepublic void deleteByIds(int[] ids) &#123; //2. 获取SqlSession对象 SqlSession sqlSession = factory.openSession(); //3. 获取BrandMapper BrandMapper mapper = sqlSession.getMapper(BrandMapper.class); //4. 调用方法 mapper.deleteByIds(ids); sqlSession.commit();//提交事务 //5. 释放资源 sqlSession.close();&#125; 6.1.3 servlet实现 在 BrandServlet 类中定义 deleteByIds() 方法。而该方法的逻辑如下： 接收页面提交的数据。页面到时候提交的数据是 json 格式的数据，所以此处需要使用输入流读取数据 接收页面提交的数据。页面到时候提交的数据是 json 格式的数据，所以此处需要使用输入流读取数据 将接收到的数据转换为 int[] 数组 调用 service 的 deleteByIds() 方法进行批量删除的业务逻辑处理 给浏览器响应添加成功的标识，这里直接给浏览器响应 success 字符串表示成功 servlet 中 deleteByIds() 方法代码实现如下： 1234567891011public void deleteByIds(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; //1. 接收数据 json [1,2,3] BufferedReader br = request.getReader(); String params = br.readLine();//json字符串 //转为 int[] int[] ids = JSON.parseObject(params, int[].class); //2. 调用service添加 brandService.deleteByIds(ids); //3. 响应成功的标识 response.getWriter().write(&quot;success&quot;);&#125; 6.2 前端实现 此功能的前端代码实现稍微有点麻烦，分为以下几步实现 6.2.1 获取选中的id值 从上图可以看出表格复选框绑定了一个 selection-change 事件，该事件是当选择项发生变化时会触发。该事件绑定了 handleSelectionChange 函数，而该函数有一个参数 val ，该参数是获取选中行的数据，如下 而我们只需要将所有选中数据的id值提交给服务端即可，获取id的逻辑我们书写在 批量删除 按钮绑定的函数中。 在 批量删除 按钮绑定单击事件，并给绑定触发时调用的函数，如下 并在Vue对象中的 methods 中定义 deleteByIds() 函数，在该函数中从 multipleSelection 数据模型中获取所选数据的id值。要完成这个功能需要在 Vue 对象中定义一个数据模型 selectedIds:[]，在 deleteByIds() 函数中遍历 multipleSelection 数组，并获取到每一个所选数据的id值存储到 selectedIds 数组中，代码实现如下： 12345//1. 创建id数组 [1,2,3], 从 this.multipleSelection 获取即可for (let i = 0; i &lt; this.multipleSelection.length; i++) &#123; let selectionElement = this.multipleSelection[i]; this.selectedIds[i] = selectionElement.id;&#125; 6.2.2 发送异步请求 使用 axios 发送异步请求并经上一步获取到的存储所有的 id 数组作为请求参数 1234567891011121314151617181920//2. 发送AJAX请求var _this = this;// 发送ajax请求，添加数据axios(&#123; method:&quot;post&quot;, url:&quot;http://localhost:8080/brand-case/brand/deleteByIds&quot;, data:_this.selectedIds&#125;).then(function (resp) &#123; if(resp.data == &quot;success&quot;)&#123; //删除成功 // 重新查询数据 _this.selectAll(); // 弹出消息提示 _this.$message(&#123; message: &#x27;恭喜你，删除成功&#x27;, type: &#x27;success&#x27; &#125;); &#125;&#125;) 6.2.3 确定框实现 由于删除操作是比较危险的；有时候可能是由于用户的误操作点击了 批量删除 按钮，所以在点击了按钮后需要先给用户确认提示。而确认框在 elementUI 中也提供了，如下图 而在点击 确定 按钮后需要执行之前删除的逻辑。因此前端代码实现如下： 1234567891011121314151617181920212223242526272829303132333435363738394041 // 批量删除deleteByIds()&#123; // 弹出确认提示框 this.$confirm(&#x27;此操作将删除该数据, 是否继续?&#x27;, &#x27;提示&#x27;, &#123; confirmButtonText: &#x27;确定&#x27;, cancelButtonText: &#x27;取消&#x27;, type: &#x27;warning&#x27; &#125;).then(() =&gt; &#123; //用户点击确认按钮 //1. 创建id数组 [1,2,3], 从 this.multipleSelection 获取即可 for (let i = 0; i &lt; this.multipleSelection.length; i++) &#123; let selectionElement = this.multipleSelection[i]; this.selectedIds[i] = selectionElement.id; &#125; //2. 发送AJAX请求 var _this = this; // 发送ajax请求，添加数据 axios(&#123; method:&quot;post&quot;, url:&quot;http://localhost:8080/brand-case/brand/deleteByIds&quot;, data:_this.selectedIds &#125;).then(function (resp) &#123; if(resp.data == &quot;success&quot;)&#123; //删除成功 // 重新查询数据 _this.selectAll(); // 弹出消息提示 _this.$message(&#123; message: &#x27;恭喜你，删除成功&#x27;, type: &#x27;success&#x27; &#125;); &#125; &#125;) &#125;).catch(() =&gt; &#123; //用户点击取消按钮 this.$message(&#123; type: &#x27;info&#x27;, message: &#x27;已取消删除&#x27; &#125;); &#125;);&#125; 7，分页查询 我们之前做的 查询所有 功能中将数据库中所有的数据查询出来并展示到页面上，试想如果数据库中的数据有很多（假设有十几万条）的时候，将数据全部展示出来肯定不现实，那如何解决这个问题呢？几乎所有的网站都会使用分页解决这个问题。每次只展示一页的数据，比如一页展示10条数据，如果还想看其他的数据，可以通过点击页码进行查询 7.1 分析 7.1.1 分页查询sql 分页查询也是从数据库进行查询的，所以我们要分页对应的SQL语句应该怎么写。分页查询使用 LIMIT 关键字，格式为：LIMIT 开始索引 每页显示的条数。以后前端页面在发送请求携带参数时，它并不明确开始索引是什么，但是它知道查询第几页。所以 开始索引 需要在后端进行计算，计算的公式是 ：开始索引 = （当前页码 - 1）* 每页显示条数 比如查询第一页的数据的 SQL 语句是： 1select * from tb_brand limit 0,5; 查询第二页的数据的 SQL 语句是： 1select * from tb_brand limit 5,5; 查询第三页的数据的 SQL 语句是： 1select * from tb_brand limit 10,5; 7.1.2 前后端数据分析 分页查询功能时候比较复杂的，所以我们要先分析清楚以下两个问题： 前端需要传递什么参数给后端 根据上一步对分页查询 SQL 语句分析得出，前端需要给后端两个参数 当前页码 ： currentPage 每页显示条数：pageSize 后端需要响应什么数据给前端 上图是分页查询页面展示的效果，从上面我们可以看出需要响应以下联股份数据 当前页需要展示的数据。我们在后端一般会存储到 List 集合中 总共记录数。在上图页面中需要展示总的记录数，所以这部分数据也需要。总的页面 elementUI 的分页组件会自动计算，我们不需要关心 而这两部分需要封装到 PageBean 对象中，并将该对象转换为 json 格式的数据响应回给浏览器 通过上面的分析我们需要先在 pojo 包下创建 PageBean 类，为了做到通过会将其定义成泛型类，代码如下： 123456789101112131415161718192021222324//分页查询的JavaBeanpublic class PageBean&lt;T&gt; &#123; // 总记录数 private int totalCount; // 当前页数据 private List&lt;T&gt; rows; public int getTotalCount() &#123; return totalCount; &#125; public void setTotalCount(int totalCount) &#123; this.totalCount = totalCount; &#125; public List&lt;T&gt; getRows() &#123; return rows; &#125; public void setRows(List&lt;T&gt; rows) &#123; this.rows = rows; &#125;&#125; 7.1.3 流程分析 后端需要响应总记录数 和 当前页的数据 两部分数据给前端，所以在 BrandMapper 接口中需要定义两个方法： selectByPage() ：查询当前页的数据的方法 selectTotalCount() ：查询总记录的方法 整体流程如下： 7.2 后端实现 7.2.1 dao方法实现 在 BrandMapper 接口中定义 selectByPage() 方法进行分页查询，代码如下： 123456789/** * 分页查询 * @param begin * @param size * @return */@Select(&quot;select * from tb_brand limit #&#123;begin&#125; , #&#123;size&#125;&quot;)@ResultMap(&quot;brandResultMap&quot;)List&lt;Brand&gt; selectByPage(@Param(&quot;begin&quot;) int begin,@Param(&quot;size&quot;) int size); 在 BrandMapper 接口中定义 selectTotalCount() 方法进行统计记录数，代码如下： 123456/** * 查询总记录数 * @return */@Select(&quot;select count(*) from tb_brand &quot;)int selectTotalCount(); 7.2.2 service方法实现 在 BrandService 接口中定义 selectByPage() 分页查询数据的业务逻辑方法 1234567/** * 分页查询 * @param currentPage 当前页码 * @param pageSize 每页展示条数 * @return */ PageBean&lt;Brand&gt; selectByPage(int currentPage,int pageSize); 在 BrandServiceImpl 类中重写 selectByPage() 方法，并进行业务逻辑实现 1234567891011121314151617181920212223@Overridepublic PageBean&lt;Brand&gt; selectByPage(int currentPage, int pageSize) &#123; //2. 获取SqlSession对象 SqlSession sqlSession = factory.openSession(); //3. 获取BrandMapper BrandMapper mapper = sqlSession.getMapper(BrandMapper.class); //4. 计算开始索引 int begin = (currentPage - 1) * pageSize; // 计算查询条目数 int size = pageSize; //5. 查询当前页数据 List&lt;Brand&gt; rows = mapper.selectByPage(begin, size); //6. 查询总记录数 int totalCount = mapper.selectTotalCount(); //7. 封装PageBean对象 PageBean&lt;Brand&gt; pageBean = new PageBean&lt;&gt;(); pageBean.setRows(rows); pageBean.setTotalCount(totalCount); //8. 释放资源 sqlSession.close(); return pageBean;&#125; 7.2.3 servlet实现 在 BrandServlet 类中定义 selectByPage() 方法。而该方法的逻辑如下： 获取页面提交的 当前页码 和 每页显示条目数 两个数据。这两个参数是在url后进行拼接的，格式是 url?currentPage=1&amp;pageSize=5。获取这样的参数需要使用 requet.getparameter() 方法获取。 调用 service 的 selectByPage() 方法进行分页查询的业务逻辑处理 将查询到的数据转换为 json 格式的数据 响应 json 数据 servlet 中 selectByPage() 方法代码实现如下： 1234567891011121314151617public void selectByPage(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; //1. 接收 当前页码 和 每页展示条数 url?currentPage=1&amp;pageSize=5 String _currentPage = request.getParameter(&quot;currentPage&quot;); String _pageSize = request.getParameter(&quot;pageSize&quot;); int currentPage = Integer.parseInt(_currentPage); int pageSize = Integer.parseInt(_pageSize); //2. 调用service查询 PageBean&lt;Brand&gt; pageBean = brandService.selectByPage(currentPage, pageSize); //2. 转为JSON String jsonString = JSON.toJSONString(pageBean); //3. 写数据 response.setContentType(&quot;text/json;charset=utf-8&quot;); response.getWriter().write(jsonString);&#125; 7.2.4 测试 在浏览器上地址栏输入 http://localhost:8080/brand-case/brand/selectByPage?currentPage=1&amp;pageSize=5 ，查询到以下数据 7.3 前端实现 7.3.1 selectAll 代码改进 selectAll() 函数之前是查询所有数据，现需要改成分页查询。 请求路径应改为 http://localhost:8080/brand-case/brand/selectByPage?currentPage=1&amp;pageSize=5 ，而 currentPage 和 pageSize 是需要携带的参数，分别是 当前页码 和 每页显示的条目数。 刚才我们对后端代码进行测试可以看出响应回来的数据，所以在异步请求的成功回调函数（then 中的匿名函数）中给页面表格的数据模型赋值 _this.tableData = resp.data.rows;。整体代码如下 12345678var _this = this;axios(&#123; method:&quot;post&quot;, url:&quot;http://localhost:8080/brand-case/brand/selectByPage？currentPage=1&amp;pageSize=5&quot;&#125;).then(resp =&gt;&#123; //设置表格数据 _this.tableData = resp.data.rows; // &#123;rows:[],totalCount:100&#125;&#125;) 响应的数据中还有总记录数，要进行总记录数展示需要在页面绑定数据模型 注意：该数据模型需要在Vue对象中声明出来。 那异步请求的代码就可以优化为 12345678910var _this = this;axios(&#123; method:&quot;post&quot;, url:&quot;http://localhost:8080/brand-case/brand/selectByPage?currentPage=1&amp;pageSize=5&quot;&#125;).then(resp =&gt;&#123; //设置表格数据 _this.tableData = resp.data.rows; // &#123;rows:[],totalCount:100&#125; //设置总记录数 _this.totalCount = resp.data.totalCount;&#125;) 而页面中分页组件给 当前页码 和 每页显示的条目数 都绑定了数据模型 所以 selectAll() 函数中发送异步请求的资源路径中不能将当前页码和 每页显示条目数写死，代码就可以优化为 12345678910var _this = this;axios(&#123; method:&quot;post&quot;, url:&quot;http://localhost:8080/brand-case/brand/selectByPage?currentPage=&quot;+this.currentPage+&quot;&amp;pageSize=&quot; + this.pageSize&#125;).then(resp =&gt;&#123; //设置表格数据 _this.tableData = resp.data.rows; // &#123;rows:[],totalCount:100&#125; //设置总记录数 _this.totalCount = resp.data.totalCount;&#125;) 7.3.2 改变每页条目数 当我们改变每页显示的条目数后，需要重新发送异步请求。而下图是分页组件代码，@size-change 就是每页显示的条目数发生变化时会触发的事件 而该事件绑定了一个 handleSizeChange 函数，整个逻辑如下： 123456handleSizeChange(val) &#123; //我们选择的是 ‘5条/页’ 此值就是 5.而我们选择了 `10条/页` 此值就是 10 // 重新设置每页显示的条数 this.pageSize = val; //调用 selectAll 函数重新分页查询数据 this.selectAll();&#125; 7.3.3 改变当前页码 当我们改变页码时，需要重新发送异步请求。而下图是分页组件代码，@current-change 就是页码发生变化时会触发的事件 而该事件绑定了一个 handleSizeChange 函数，整个逻辑如下： 123456handleCurrentChange(val) &#123; //val 就是改变后的页码 // 重新设置当前页码 this.currentPage = val; //调用 selectAll 函数重新分页查询数据 this.selectAll();&#125; 8，条件查询 上图就是用来输入条件查询的条件数据的。要做条件查询功能，先明确以下三个问题 3个条件之间什么关系？ 同时满足，所用 SQL 中多个条件需要使用 and 关键字连接 3个条件必须全部填写吗？ 不需要。想根据哪儿个条件查询就写那个，所以这里需要使用动态 sql 语句 条件查询需要分页吗？ 需要 根据上面三个问题的明确，我们就可以确定sql语句了： 整个条件分页查询流程如下 8.1 后端实现 8.1.1 dao实现 在 BrandMapper 接口中定义 selectByPageAndCondition() 方法 和 selectTotalCountByCondition 方法，用来进行条件分页查询功能，方法如下： 12345678910111213/** * 分页条件查询 * @param begin * @param size * @return */List&lt;Brand&gt; selectByPageAndCondition(@Param(&quot;begin&quot;) int begin,@Param(&quot;size&quot;) int size,@Param(&quot;brand&quot;) Brand brand);/** * 根据条件查询总记录数 * @return */int selectTotalCountByCondition(Brand brand); 参数： begin 分页查询的起始索引 size 分页查询的每页条目数 brand 用来封装条件的对象 由于这是一个复杂的查询语句，需要使用动态sql；所以我们在映射配置文件中书写 sql 语句。brand_name 字段和 company_name 字段需要进行模糊查询，所以需要使用 % 占位符。映射配置文件中 statement 书写如下： 1234567891011121314151617181920212223242526272829303132333435363738&lt;!--查询满足条件的数据并进行分页--&gt;&lt;select id=&quot;selectByPageAndCondition&quot; resultMap=&quot;brandResultMap&quot;&gt; select * from tb_brand &lt;where&gt; &lt;if test=&quot;brand.brandName != null and brand.brandName != &#x27;&#x27; &quot;&gt; and brand_name like #&#123;brand.brandName&#125; &lt;/if&gt; &lt;if test=&quot;brand.companyName != null and brand.companyName != &#x27;&#x27; &quot;&gt; and company_name like #&#123;brand.companyName&#125; &lt;/if&gt; &lt;if test=&quot;brand.status != null&quot;&gt; and status = #&#123;brand.status&#125; &lt;/if&gt; &lt;/where&gt; limit #&#123;begin&#125; , #&#123;size&#125;&lt;/select&gt;&lt;!--查询满足条件的数据条目数--&gt;&lt;select id=&quot;selectTotalCountByCondition&quot; resultType=&quot;java.lang.Integer&quot;&gt; select count(*) from tb_brand &lt;where&gt; &lt;if test=&quot;brandName != null and brandName != &#x27;&#x27; &quot;&gt; and brand_name like #&#123;brandName&#125; &lt;/if&gt; &lt;if test=&quot;companyName != null and companyName != &#x27;&#x27; &quot;&gt; and company_name like #&#123;companyName&#125; &lt;/if&gt; &lt;if test=&quot;status != null&quot;&gt; and status = #&#123;status&#125; &lt;/if&gt; &lt;/where&gt;&lt;/select&gt; 8.1.2 service实现 在 BrandService 接口中定义 selectByPageAndCondition() 分页查询数据的业务逻辑方法 12345678 /** * 分页条件查询 * @param currentPage * @param pageSize * @param brand * @return */PageBean&lt;Brand&gt; selectByPageAndCondition(int currentPage,int pageSize,Brand brand); 在 BrandServiceImpl 类中重写 selectByPageAndCondition() 方法，并进行业务逻辑实现 12345678910111213141516171819202122232425262728293031323334353637383940@Override public PageBean&lt;Brand&gt; selectByPageAndCondition(int currentPage, int pageSize, Brand brand) &#123; //2. 获取SqlSession对象 SqlSession sqlSession = factory.openSession(); //3. 获取BrandMapper BrandMapper mapper = sqlSession.getMapper(BrandMapper.class); //4. 计算开始索引 int begin = (currentPage - 1) * pageSize; // 计算查询条目数 int size = pageSize; // 处理brand条件，模糊表达式 String brandName = brand.getBrandName(); if (brandName != null &amp;&amp; brandName.length() &gt; 0) &#123; brand.setBrandName(&quot;%&quot; + brandName + &quot;%&quot;); &#125; String companyName = brand.getCompanyName(); if (companyName != null &amp;&amp; companyName.length() &gt; 0) &#123; brand.setCompanyName(&quot;%&quot; + companyName + &quot;%&quot;); &#125; //5. 查询当前页数据 List&lt;Brand&gt; rows = mapper.selectByPageAndCondition(begin, size, brand); //6. 查询总记录数 int totalCount = mapper.selectTotalCountByCondition(brand); //7. 封装PageBean对象 PageBean&lt;Brand&gt; pageBean = new PageBean&lt;&gt;(); pageBean.setRows(rows); pageBean.setTotalCount(totalCount); //8. 释放资源 sqlSession.close(); return pageBean; 注意：brandName 和 companyName 属性值到时候需要进行模糊查询，所以前后需要拼接上 %。 8.1.3 servlet实现 在 BrandServlet 类中定义 selectByPageAndCondition() 方法。而该方法的逻辑如下： 获取页面提交的 当前页码 和 每页显示条目数 两个数据。这两个参数是在url后进行拼接的，格式是 url?currentPage=1&amp;pageSize=5。获取这样的参数需要使用 requet.getparameter() 方法获取。 获取页面提交的 条件数据 ，并将数据封装到一个Brand对象中。由于这部分数据到时候是需要以 json 格式进行提交的，所以我们需要通过流获取数据，具体代码如下： 123456// 获取查询条件对象BufferedReader br = request.getReader();String params = br.readLine();//json字符串//转为 BrandBrand brand = JSON.parseObject(params, Brand.class); 调用 service 的 selectByPageAndCondition() 方法进行分页查询的业务逻辑处理 将查询到的数据转换为 json 格式的数据 响应 json 数据 servlet 中 selectByPageAndCondition() 方法代码实现如下： 123456789101112131415161718192021222324252627282930313233/** * 分页条件查询 * @param request * @param response * @throws ServletException * @throws IOException */public void selectByPageAndCondition(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; //1. 接收 当前页码 和 每页展示条数 url?currentPage=1&amp;pageSize=5 String _currentPage = request.getParameter(&quot;currentPage&quot;); String _pageSize = request.getParameter(&quot;pageSize&quot;); int currentPage = Integer.parseInt(_currentPage); int pageSize = Integer.parseInt(_pageSize); // 获取查询条件对象 BufferedReader br = request.getReader(); String params = br.readLine();//json字符串 //转为 Brand Brand brand = JSON.parseObject(params, Brand.class); //2. 调用service查询 PageBean&lt;Brand&gt; pageBean = brandService.selectByPageAndCondition(currentPage,pageSize,brand); //2. 转为JSON String jsonString = JSON.toJSONString(pageBean); //3. 写数据 response.setContentType(&quot;text/json;charset=utf-8&quot;); response.getWriter().write(jsonString);&#125; 8.2 前端实现 前端代码我们从以下几方面实现： 查询表单绑定查询条件对象模型 这一步在页面上已经实现了，页面代码如下： 点击查询按钮查询数据 从上面页面可以看到给 查询 按钮绑定了 onSubmit() 函数，而在 onSubmit() 函数中只需要调用 selectAll() 函数进行条件分页查询。 改进 selectAll() 函数 子页面加载完成后发送异步请求，需要携带当前页码、每页显示条数、查询条件对象。接下来先对携带的数据进行说明： 当前页码 和 每页显示条数 这两个参数我们会拼接到 URL 的后面 查询条件对象 这个参数需要以 json 格式提交给后端程序 修改 selectAll() 函数逻辑为 12345678910111213var _this = this;axios(&#123; method:&quot;post&quot;, url:&quot;http://localhost:8080/brand-case/brand/selectByPageAndCondition?currentPage=&quot;+this.currentPage+&quot;&amp;pageSize=&quot;+this.pageSize, data:this.brand&#125;).then(function (resp) &#123; //设置表格数据 _this.tableData = resp.data.rows; // &#123;rows:[],totalCount:100&#125; //设置总记录数 _this.totalCount = resp.data.totalCount;&#125;) 9，前端代码优化 咱们已经将所有的功能实现完毕。而针对前端代码中的发送异步请求的代码，如下 12345678910111213var _this = this;axios(&#123; method:&quot;post&quot;, url:&quot;http://localhost:8080/brand-case/brand/selectByPageAndCondition?currentPage=&quot;+this.currentPage+&quot;&amp;pageSize=&quot;+this.pageSize, data:this.brand&#125;).then(function (resp) &#123; //设置表格数据 _this.tableData = resp.data.rows; // &#123;rows:[],totalCount:100&#125; //设置总记录数 _this.totalCount = resp.data.totalCount;&#125;) 需要在成功的回调函数（也就是then 函数中的匿名函数）中使用this，都需要在外边使用 _this 记录一下 this 所指向的对象；因为在外边的 this 表示的是 Vue 对象，而回调函数中的 this 表示的不是 vue 对象。这里我们可以使用 ECMAScript6 中的新语法（箭头函数）来简化这部分代码，如上面的代码可以简化为: 1234567891011axios(&#123; method:&quot;post&quot;, url:&quot;http://localhost:8080/brand-case/brand/selectByPageAndCondition?currentPage=&quot;+this.currentPage+&quot;&amp;pageSize=&quot;+this.pageSize, data:this.brand&#125;).then((resp) =&gt; &#123; //设置表格数据 this.tableData = resp.data.rows; // &#123;rows:[],totalCount:100&#125; //设置总记录数 this.totalCount = resp.data.totalCount;&#125;) 箭头函数语法： 123(参数) =&gt; &#123; 逻辑代码&#125; 箭头函数的作用： 替换（简化）匿名函数。 来源：it 黑马 JavaWeb 教程","categories":[{"name":"Java","slug":"Java","permalink":"http://littlewuuu.com/categories/Java/"}],"tags":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://littlewuuu.com/tags/JavaWeb/"}]},{"title":"Request&Response","slug":"黑马/10-Request&Response","date":"2022-08-21T22:00:00.000Z","updated":"2022-12-01T15:45:03.681Z","comments":true,"path":"2022/08/22/黑马/10-Request&Response/","link":"","permalink":"http://littlewuuu.com/2022/08/22/%E9%BB%91%E9%A9%AC/10-Request&Response/","excerpt":"","text":"Request&amp;Response 今日目标 掌握Request对象的概念与使用 掌握Response对象的概念与使用 能够完成用户登录注册案例的实现 能够完成SqlSessionFactory工具类的抽取 1，Request和Response的概述 ==Request是请求对象，Response是响应对象。==这两个对象在我们使用Servlet的时候有看到： 此时，我们就需要思考一个问题request和response这两个参数的作用是什么? request:获取请求数据 浏览器会发送HTTP请求到后台服务器[Tomcat] HTTP的请求中会包含很多请求数据[请求行+请求头+请求体] 后台服务器[Tomcat]会对HTTP请求中的数据进行解析并把解析结果存入到一个对象中 所存入的对象即为request对象，所以我们可以从request对象中获取请求的相关参数 获取到数据后就可以继续后续的业务，比如获取用户名和密码就可以实现登录操作的相关业务 response:设置响应数据 业务处理完后，后台就需要给前端返回业务处理的结果即响应数据 把响应数据封装到response对象中 后台服务器[Tomcat]会解析response对象,按照[响应行+响应头+响应体]格式拼接结果 浏览器最终解析结果，把内容展示在浏览器给用户浏览 对于上述所讲的内容，我们通过一个案例来初步体验下request和response对象的使用。 1234567891011121314151617@WebServlet(&quot;/demo3&quot;)public class ServletDemo3 extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; //使用request对象 获取请求数据 String name = request.getParameter(&quot;name&quot;);//url?name=zhangsan //使用response对象 设置响应数据 response.setHeader(&quot;content-type&quot;,&quot;text/html;charset=utf-8&quot;); response.getWriter().write(&quot;&lt;h1&gt;&quot;+name+&quot;,欢迎您！&lt;/h1&gt;&quot;); &#125; @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; System.out.println(&quot;Post...&quot;); &#125;&#125; 启动成功后就可以通过浏览器来访问，并且根据传入参数的不同就可以在页面上展示不同的内容: 小结 在这节中，我们主要认识了下request对象和reponse对象: request对象是用来封装请求数据的对象 response对象是用来封装响应数据的对象 目前我们只知道这两个对象是用来干什么的，那么它们具体是如何实现的，就需要我们继续深入的学习。接下来，就先从Request对象来学习,主要学习下面这些内容: request继承体系 request获取请求参数 request请求转发 2，Request对象 2.1 Request继承体系 在学习这节内容之前，我们先思考一个问题，前面在介绍Request和Reponse对象的时候，比较细心的同学可能已经发现： 当我们的Servlet类实现的是Servlet接口的时候，service方法中的参数是ServletRequest和ServletResponse 当我们的Servlet类继承的是HttpServlet类的时候，doGet和doPost方法中的参数就变成HttpServletRequest和HttpServletReponse 那么， ServletRequest和HttpServletRequest的关系是什么? request对象是有谁来创建的? request提供了哪些API,这些API从哪里查? 首先，我们先来看下Request的继承体系: 从上图中可以看出，ServletRequest和HttpServletRequest都是Java提供的，所以我们可以打开JavaEE提供的API文档[参考: 资料/JavaEE7-api.chm],打开后可以看到: 所以ServletRequest和HttpServletRequest是继承关系，并且两个都是接口，接口是无法创建对象，这个时候就引发了下面这个问题: 这个时候，我们就需要用到Request继承体系中的RequestFacade: 该类实现了HttpServletRequest接口，也间接实现了ServletRequest接口。 Servlet类中的service方法、doGet方法或者是doPost方法最终都是由Web服务器[Tomcat]来调用的，所以Tomcat提供了方法参数接口的具体实现类，并完成了对象的创建 要想了解RequestFacade中都提供了哪些方法，我们可以直接查看JavaEE的API文档中关于ServletRequest和HttpServletRequest的接口文档，因为RequestFacade实现了其接口就需要重写接口中的方法 对于上述结论，要想验证，可以编写一个Servlet，在方法中把request对象打印下，就能看到最终的对象是不是RequestFacade,代码如下: 1234567891011@WebServlet(&quot;/demo2&quot;)public class ServletDemo2 extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; System.out.println(request); &#125; @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; &#125;&#125; 启动服务器，运行访问http://localhost:8080/request-demo/demo2,得到运行结果: 小结 Request的继承体系为ServletRequest–&gt;HttpServletRequest–&gt;RequestFacade Tomcat需要解析请求数据，封装为request对象,并且创建request对象传递到service方法 使用request对象，可以查阅JavaEE API文档的HttpServletRequest接口中方法说明 2.2 Request获取请求数据 HTTP请求数据总共分为三部分内容，分别是请求行、请求头、请求体，对于这三部分内容的数据，分别该如何获取，首先我们先来学习请求行数据如何获取? 2.2.1 获取请求行数据 请求行包含三块内容，分别是请求方式、请求资源路径、HTTP协议及版本 对于这三部分内容，request对象都提供了对应的API方法来获取，具体如下: 获取请求方式: GET 1String getMethod() 获取虚拟目录(项目访问路径): /request-demo 1String getContextPath() 获取URL(统一资源定位符): http://localhost:8080/request-demo/req1 1StringBuffer getRequestURL() 获取URI(统一资源标识符): /request-demo/req1 1String getRequestURI() 获取请求参数(GET方式): username=zhangsan&amp;password=123 1String getQueryString() 介绍完上述方法后，咱们通过代码把上述方法都使用下: 123456789101112131415161718192021222324252627/** * request 获取请求数据 */@WebServlet(&quot;/req1&quot;)public class RequestDemo1 extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; // String getMethod()：获取请求方式： GET String method = req.getMethod(); System.out.println(method);//GET // String getContextPath()：获取虚拟目录(项目访问路径)：/request-demo String contextPath = req.getContextPath(); System.out.println(contextPath); // StringBuffer getRequestURL(): 获取URL(统一资源定位符)：http://localhost:8080/request-demo/req1 StringBuffer url = req.getRequestURL(); System.out.println(url.toString()); // String getRequestURI()：获取URI(统一资源标识符)： /request-demo/req1 String uri = req.getRequestURI(); System.out.println(uri); // String getQueryString()：获取请求参数（GET方式）： username=zhangsan String queryString = req.getQueryString(); System.out.println(queryString); &#125; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; &#125;&#125; 启动服务器，访问http://localhost:8080/request-demo/req1?username=zhangsan&amp;passwrod=123，获取的结果如下: 2.2.2 获取请求头数据 对于请求头的数据，格式为key: value如下: 所以根据请求头名称获取对应值的方法为: 1String getHeader(String name) 接下来，在代码中如果想要获取客户端浏览器的版本信息，则可以使用 12345678910111213141516/** * request 获取请求数据 */@WebServlet(&quot;/req1&quot;)public class RequestDemo1 extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //获取请求头: user-agent: 浏览器的版本信息 String agent = req.getHeader(&quot;user-agent&quot;); System.out.println(agent); &#125; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; &#125;&#125; 重新启动服务器后，http://localhost:8080/request-demo/req1?username=zhangsan&amp;passwrod=123，获取的结果如下: 2.2.3 获取请求体数据 浏览器在发送GET请求的时候是没有请求体的，所以需要把请求方式变更为POST，请求体中的数据格式如下: 对于请求体中的数据，Request对象提供了如下两种方式来获取其中的数据，分别是: 获取字节输入流，如果前端发送的是字节数据，比如传递的是文件数据，则使用该方法 12ServletInputStream getInputStream()该方法可以获取字节 获取字符输入流，如果前端发送的是纯文本数据，则使用该方法 1BufferedReader getReader() 接下来，大家需要思考，要想获取到请求体的内容该如何实现? 具体实现的步骤如下: 1.准备一个页面，在页面中添加form表单,用来发送post请求 2.在Servlet的doPost方法中获取请求体数据 3.在doPost方法中使用request的getReader()或者getInputStream()来获取 4.访问测试 在项目的webapp目录下添加一个html页面，名称为：req.html 123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;!-- action:form表单提交的请求地址 method:请求方式，指定为post--&gt;&lt;form action=&quot;/request-demo/req1&quot; method=&quot;post&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;username&quot;&gt; &lt;input type=&quot;password&quot; name=&quot;password&quot;&gt; &lt;input type=&quot;submit&quot;&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 在Servlet的doPost方法中获取数据 12345678910111213/** * request 获取请求数据 */@WebServlet(&quot;/req1&quot;)public class RequestDemo1 extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; &#125; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //在此处获取请求体中的数据 &#125;&#125; 调用getReader()或者getInputStream()方法，因为目前前端传递的是纯文本数据，所以我们采用getReader()方法来获取 123456789101112131415161718/** * request 获取请求数据 */@WebServlet(&quot;/req1&quot;)public class RequestDemo1 extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; &#125; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //获取post 请求体：请求参数 //1. 获取字符输入流 BufferedReader br = req.getReader(); //2. 读取数据 String line = br.readLine(); System.out.println(line); &#125;&#125; 注意 BufferedReader流是通过request对象来获取的，当请求完成后request对象就会被销毁，request对象被销毁后，BufferedReader流就会自动关闭，所以此处就不需要手动关闭流了。 启动服务器，通过浏览器访问http://localhost:8080/request-demo/req.html 点击提交按钮后，就可以在控制台看到前端所发送的请求数据 小结 HTTP请求数据中包含了请求行、请求头和请求体，针对这三部分内容，Request对象都提供了对应的API方法来获取对应的值: 请求行 getMethod()获取请求方式 getContextPath()获取项目访问路径 getRequestURL()获取请求URL getRequestURI()获取请求URI getQueryString()获取GET请求方式的请求参数 请求头 getHeader(String name)根据请求头名称获取其对应的值 请求体 注意: 浏览器发送的POST请求才有请求体 如果是纯文本数据:getReader() 如果是字节数据如文件数据:getInputStream() 2.2.4 获取请求参数的通用方式 在学习下面内容之前，我们先提出两个问题: 什么是请求参数? 请求参数和请求数据的关系是什么? 1.什么是请求参数? 为了能更好的回答上述两个问题，我们拿用户登录的例子来说明 1.1 想要登录网址，需要进入登录页面 1.2 在登录页面输入用户名和密码 1.3 将用户名和密码提交到后台 1.4 后台校验用户名和密码是否正确 1.5 如果正确，则正常登录，如果不正确，则提示用户名或密码错误 上述例子中，用户名和密码其实就是我们所说的请求参数。 2.什么是请求数据? 请求数据则是包含请求行、请求头和请求体的所有数据 3.请求参数和请求数据的关系是什么? 3.1 请求参数是请求数据中的部分内容 3.2 如果是GET请求，请求参数在请求行中 3.3 如果是POST请求，请求参数一般在请求体中 对于请求参数的获取,常用的有以下两种: GET方式: 1String getQueryString() POST方式: 1BufferedReader getReader(); 有了上述的知识储备，我们来实现一个案例需求: （1）发送一个GET请求并携带用户名，后台接收后打印到控制台 （2）发送一个POST请求并携带用户名，后台接收后打印到控制台 此处大家需要注意的是GET请求和POST请求接收参数的方式不一样，具体实现的代码如下: 12345678910111213141516@WebServlet(&quot;/req1&quot;)public class RequestDemo1 extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; String result = req.getQueryString(); System.out.println(result); &#125; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; BufferedReader br = req.getReader(); String result = br.readLine(); System.out.println(result); &#125;&#125; 对于上述的代码，会存在什么问题呢? 如何解决上述重复代码的问题呢? 当然，也可以在doGet中调用doPost,在doPost中完成参数的获取和打印,另外需要注意的是，doGet和doPost方法都必须存在，不能删除任意一个。 GET请求和POST请求获取请求参数的方式不一样，在获取请求参数这块该如何实现呢? 要想实现，我们就需要思考: GET请求方式和POST请求方式区别主要在于获取请求参数的方式不一样，是否可以提供一种统一获取请求参数的方式，从而统一doGet和doPost方法内的代码? 解决方案一: 1234567891011121314151617181920212223@WebServlet(&quot;/req1&quot;)public class RequestDemo1 extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //获取请求方式 String method = req.getMethod(); //获取请求参数 String params = &quot;&quot;; if(&quot;GET&quot;.equals(method))&#123; params = req.getQueryString(); &#125;else if(&quot;POST&quot;.equals(method))&#123; BufferedReader reader = req.getReader(); params = reader.readLine(); &#125; //将请求参数进行打印控制台 System.out.println(params); &#125; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; this.doGet(req,resp); &#125;&#125; 使用request的getMethod()来获取请求方式，根据请求方式的不同分别获取请求参数值，这样就可以解决上述问题，但是以后每个Servlet都需要这样写代码，实现起来比较麻烦，这种方案我们不采用 解决方案二: request对象已经将上述获取请求参数的方法进行了封装，并且request提供的方法实现的功能更强大，以后只需要调用request提供的方法即可，在request的方法中都实现了哪些操作? (1)根据不同的请求方式获取请求参数，获取的内容如下: (2)把获取到的内容进行分割，内容如下: (3)把分割后端数据，存入到一个Map集合中: 注意:因为参数的值可能是一个，也可能有多个，所以Map的值的类型为String数组。 基于上述理论，request对象为我们提供了如下方法: 获取所有参数Map集合 1Map&lt;String,String[]&gt; getParameterMap() 根据名称获取参数值（数组） 1String[] getParameterValues(String name) 根据名称获取参数值(单个值) 1String getParameter(String name) 接下来，我们通过案例来把上述的三个方法进行实例演示: 1.修改req.html页面，添加爱好选项，爱好可以同时选多个 1234567891011121314151617&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form action=&quot;/request-demo/req2&quot; method=&quot;get&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;username&quot;&gt;&lt;br&gt; &lt;input type=&quot;password&quot; name=&quot;password&quot;&gt;&lt;br&gt; &lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; value=&quot;1&quot;&gt; 游泳 &lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; value=&quot;2&quot;&gt; 爬山 &lt;br&gt; &lt;input type=&quot;submit&quot;&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 2.在Servlet代码中获取页面传递GET请求的参数值 2.1获取GET方式的所有请求参数 1234567891011121314151617181920212223242526272829/** * request 通用方式获取请求参数 */@WebServlet(&quot;/req2&quot;)public class RequestDemo2 extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //GET请求逻辑 System.out.println(&quot;get....&quot;); //1. 获取所有参数的Map集合 Map&lt;String, String[]&gt; map = req.getParameterMap(); for (String key : map.keySet()) &#123; // username:zhangsan lisi System.out.print(key+&quot;:&quot;); //获取值 String[] values = map.get(key); for (String value : values) &#123; System.out.print(value + &quot; &quot;); &#125; System.out.println(); &#125; &#125; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; &#125;&#125; 获取的结果为: 2.2获取GET请求参数中的爱好，结果是数组值 1234567891011121314151617181920/** * request 通用方式获取请求参数 */@WebServlet(&quot;/req2&quot;)public class RequestDemo2 extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //GET请求逻辑 //... System.out.println(&quot;------------&quot;); String[] hobbies = req.getParameterValues(&quot;hobby&quot;); for (String hobby : hobbies) &#123; System.out.println(hobby); &#125; &#125; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; &#125;&#125; 获取的结果为: 2.3获取GET请求参数中的用户名和密码，结果是单个值 12345678910111213141516171819/** * request 通用方式获取请求参数 */@WebServlet(&quot;/req2&quot;)public class RequestDemo2 extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //GET请求逻辑 //... String username = req.getParameter(&quot;username&quot;); String password = req.getParameter(&quot;password&quot;); System.out.println(username); System.out.println(password); &#125; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; &#125;&#125; 获取的结果为: 3.在Servlet代码中获取页面传递POST请求的参数值 3.1将req.html页面form表单的提交方式改成post 3.2将doGet方法中的内容复制到doPost方法中即可 小结 req.getParameter()方法使用的频率会比较高 以后我们再写代码的时候，就只需要按照如下格式来编写: 1234567891011public class RequestDemo1 extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //采用request提供的获取请求参数的通用方式来获取请求参数 //编写其他的业务代码... &#125; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; this.doGet(req,resp); &#125;&#125; 2.3 IDEA快速创建Servlet 使用通用方式获取请求参数后，屏蔽了GET和POST的请求方式代码的不同，则代码可以定义如下格式: 由于格式固定，所以我们可以使用IDEA提供的模板来制作一个Servlet的模板，这样我们后期在创建Servlet的时候就会更高效，具体如何实现: (1)按照自己的需求，修改Servlet创建的模板内容 （2）使用servlet模板创建Servlet类 2.4 请求参数中文乱码问题 问题展示: (1)将req.html页面的请求方式修改为get 1234567891011121314151617&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form action=&quot;/request-demo/req2&quot; method=&quot;get&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;username&quot;&gt;&lt;br&gt; &lt;input type=&quot;password&quot; name=&quot;password&quot;&gt;&lt;br&gt; &lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; value=&quot;1&quot;&gt; 游泳 &lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; value=&quot;2&quot;&gt; 爬山 &lt;br&gt; &lt;input type=&quot;submit&quot;&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; (2)在Servlet方法中获取参数，并打印 1234567891011121314151617/** * 中文乱码问题解决方案 */@WebServlet(&quot;/req4&quot;)public class RequestDemo4 extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; //1. 获取username String username = request.getParameter(&quot;username&quot;); System.out.println(username); &#125; @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; this.doGet(request, response); &#125;&#125; （3）启动服务器，页面上输入中文参数 （4）查看控制台打印内容 （5）把req.html页面的请求方式改成post,再次发送请求和中文参数 （6）查看控制台打印内容，依然为乱码 通过上面的案例，会发现，不管是GET还是POST请求，在发送的请求参数中如果有中文，在后台接收的时候，都会出现中文乱码的问题。具体该如何解决呢？ 2.4.1 POST请求解决方案 分析出现中文乱码的原因： POST的请求参数是通过request的getReader()来获取流中的数据 TOMCAT在获取流的时候采用的编码是ISO-8859-1 ISO-8859-1编码是不支持中文的，所以会出现乱码 解决方案： 页面设置的编码格式为UTF-8 把TOMCAT在获取流数据之前的编码设置为UTF-8 通过request.setCharacterEncoding(“UTF-8”)设置编码,UTF-8也可以写成小写 修改后的代码为: 1234567891011121314151617181920/** * 中文乱码问题解决方案 */@WebServlet(&quot;/req4&quot;)public class RequestDemo4 extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; //1. 解决乱码: POST getReader() //设置字符输入流的编码，设置的字符集要和页面保持一致 request.setCharacterEncoding(&quot;UTF-8&quot;); //2. 获取username String username = request.getParameter(&quot;username&quot;); System.out.println(username); &#125; @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; this.doGet(request, response); &#125;&#125; 重新发送POST请求，就会在控制台看到正常展示的中文结果。 至此POST请求中文乱码的问题就已经解决，但是这种方案不适用于GET请求，这个原因是什么呢，咱们下面再分析。 2.4.2 GET请求解决方案 刚才提到一个问题是POST请求的中文乱码解决方案为什么不适用GET请求？ GET请求获取请求参数的方式是request.getQueryString() POST请求获取请求参数的方式是request.getReader() request.setCharacterEncoding(“utf-8”)是设置request处理流的编码 getQueryString方法并没有通过流的方式获取数据 所以GET请求不能用设置编码的方式来解决中文乱码问题，那问题又来了，如何解决GET请求的中文乱码呢? 首先我们需要先分析下GET请求出现乱码的原因: (1)浏览器通过HTTP协议发送请求和数据给后台服务器（Tomcat) (2)浏览器在发送HTTP的过程中会对中文数据进行URL编码 (3)在进行URL编码的时候会采用页面&lt;meta&gt;标签指定的UTF-8的方式进行编码，张三编码后的结果为%E5%BC%A0%E4%B8%89 (4)后台服务器(Tomcat)接收到%E5%BC%A0%E4%B8%89后会默认按照ISO-8859-1进行URL解码 (5)由于前后编码与解码采用的格式不一样，就会导致后台获取到的数据为乱码。 思考: 如果把req.html页面的&lt;meta&gt;标签的charset属性改成ISO-8859-1,后台不做操作，能解决中文乱码问题么? 答案是否定的，因为ISO-8859-1本身是不支持中文展示的，所以改了标签的charset属性后，会导致页面上的中文内容都无法正常展示。 分析完上面的问题后，我们会发现，其中有两个我们不熟悉的内容就是URL编码和URL解码，什么是URL编码，什么又是URL解码呢? URL编码 这块知识我们只需要了解下即可,具体编码过程分两步，分别是: (1)将字符串按照编码方式转为二进制 (2)每个字节转为2个16进制数并在前边加上% 张三按照UTF-8的方式转换成二进制的结果为: 11110 0101 1011 1100 1010 0000 1110 0100 1011 1000 1000 1001 这个结果是如何计算的? 使用http://www.mytju.com/classcode/tools/encode_utf8.asp，输入张三 就可以获取张和三分别对应的10进制，然后在使用计算器，选择程序员模式，计算出对应的二进制数据结果: 在计算的十六进制结果中，每两位前面加一个%,就可以获取到%E5%BC%A0%E4%B8%89。 当然你从上面所提供的网站中就已经能看到编码16进制的结果了: 但是对于上面的计算过程，如果没有工具，纯手工计算的话，相对来说还是比较复杂的，我们也不需要进行手动计算，在Java中已经为我们提供了编码和解码的API工具类可以让我们更快速的进行编码和解码: 编码: 1java.net.URLEncoder.encode(&quot;需要被编码的内容&quot;,&quot;字符集(UTF-8)&quot;) 解码: 1java.net.URLDecoder.decode(&quot;需要被解码的内容&quot;,&quot;字符集(UTF-8)&quot;) 接下来咱们对张三来进行编码和解码 123456789101112131415public class URLDemo &#123; public static void main(String[] args) throws UnsupportedEncodingException &#123; String username = &quot;张三&quot;; //1. URL编码 String encode = URLEncoder.encode(username, &quot;utf-8&quot;); System.out.println(encode); //打印:%E5%BC%A0%E4%B8%89 //2. URL解码 //String decode = URLDecoder.decode(encode, &quot;utf-8&quot;);//打印:张三 String decode = URLDecoder.decode(encode, &quot;ISO-8859-1&quot;);//打印:`å¼ ä¸ ` System.out.println(decode); &#125;&#125; 到这，我们就可以分析出GET请求中文参数出现乱码的原因了， 浏览器把中文参数按照UTF-8进行URL编码 Tomcat对获取到的内容进行了ISO-8859-1的URL解码 在控制台就会出现类上å¼ ä¸的乱码，最后一位是个空格 清楚了出现乱码的原因，接下来我们就需要想办法进行解决 从上图可以看住， 在进行编码和解码的时候，不管使用的是哪个字符集，他们对应的%E5%BC%A0%E4%B8%89是一致的 那他们对应的二进制值也是一样的，为: 1110 0101 1011 1100 1010 0000 1110 0100 1011 1000 1000 1001 1234567891011121314151617181920212223242526272829303132333435* 为所以我们可以考虑把`å¼ ä¸`转换成字节，在把字节转换成`张三`，在转换的过程中是它们的编码一致，就可以解决中文乱码问题。具体的实现步骤为:&gt;1.按照ISO-8859-1编码获取乱码`å¼ ä¸`对应的字节数组&gt;&gt;2.按照UTF-8编码获取字节数组对应的字符串实现代码如下:```javapublic class URLDemo &#123; public static void main(String[] args) throws UnsupportedEncodingException &#123; String username = &quot;张三&quot;; //1. URL编码 String encode = URLEncoder.encode(username, &quot;utf-8&quot;); System.out.println(encode); //2. URL解码 String decode = URLDecoder.decode(encode, &quot;ISO-8859-1&quot;); System.out.println(decode); //此处打印的是对应的乱码数据 //3. 转换为字节数据,编码 byte[] bytes = decode.getBytes(&quot;ISO-8859-1&quot;); for (byte b : bytes) &#123; System.out.print(b + &quot; &quot;); &#125; //此处打印的是:-27 -68 -96 -28 -72 -119 //4. 将字节数组转为字符串，解码 String s = new String(bytes, &quot;utf-8&quot;); System.out.println(s); //此处打印的是张三 &#125;&#125; 说明:在第18行中打印的数据是-27 -68 -96 -28 -72 -119和张三转换成的二进制数据1110 0101 1011 1100 1010 0000 1110 0100 1011 1000 1000 1001为什么不一样呢？ 其实打印出来的是十进制数据，我们只需要使用计算机换算下就能得到他们的对应关系，如下图: 至此对于GET请求中文乱码的解决方案，我们就已经分析完了，最后在代码中去实现下: 1234567891011121314151617181920212223242526272829303132/** * 中文乱码问题解决方案 */@WebServlet(&quot;/req4&quot;)public class RequestDemo4 extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; //1. 解决乱码：POST，getReader() //request.setCharacterEncoding(&quot;UTF-8&quot;);//设置字符输入流的编码 //2. 获取username String username = request.getParameter(&quot;username&quot;); System.out.println(&quot;解决乱码前：&quot;+username); //3. GET,获取参数的方式：getQueryString // 乱码原因：tomcat进行URL解码，默认的字符集ISO-8859-1 /* //3.1 先对乱码数据进行编码：转为字节数组 byte[] bytes = username.getBytes(StandardCharsets.ISO_8859_1); //3.2 字节数组解码 username = new String(bytes, StandardCharsets.UTF_8);*/ username = new String(username.getBytes(StandardCharsets.ISO_8859_1),StandardCharsets.UTF_8); System.out.println(&quot;解决乱码后：&quot;+username); &#125; @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; this.doGet(request, response); &#125;&#125; 注意 把request.setCharacterEncoding(&quot;UTF-8&quot;)代码注释掉后，会发现GET请求参数乱码解决方案同时也可也把POST请求参数乱码的问题也解决了 只不过对于POST请求参数一般都会比较多，采用这种方式解决乱码起来比较麻烦，所以对于POST请求还是建议使用设置编码的方式进行。 另外需要说明一点的是Tomcat8.0之后，已将GET请求乱码问题解决，设置默认的解码方式为UTF-8 小结 中文乱码解决方案 POST请求和GET请求的参数中如果有中文，后台接收数据就会出现中文乱码问题 GET请求在Tomcat8.0以后的版本就不会出现了 POST请求解决方案是:设置输入流的编码 12request.setCharacterEncoding(&quot;UTF-8&quot;);注意:设置的字符集要和页面保持一致 通用方式（GET/POST）：需要先解码，再编码 1new String(username.getBytes(&quot;ISO-8859-1&quot;),&quot;UTF-8&quot;); URL编码实现方式: 编码: 1URLEncoder.encode(str,&quot;UTF-8&quot;); 解码: 1URLDecoder.decode(s,&quot;ISO-8859-1&quot;); 2.5 Request请求转发 请求转发(forward):一种在服务器内部的资源跳转方式。 (1)浏览器发送请求给服务器，服务器中对应的资源A接收到请求 (2)资源A处理完请求后将请求发给资源B (3)资源B处理完后将结果响应给浏览器 (4)请求从资源A到资源B的过程就叫请求转发 请求转发的实现方式: 1req.getRequestDispatcher(&quot;资源B路径&quot;).forward(req,resp); 具体如何来使用，我们先来看下需求: 针对上述需求，具体的实现步骤为: 1.创建一个RequestDemo5类，接收/req5的请求，在doGet方法中打印demo5 2.创建一个RequestDemo6类，接收/req6的请求，在doGet方法中打印demo6 3.在RequestDemo5的方法中使用 ​ req.getRequestDispatcher(“/req6”).forward(req,resp)进行请求转发 4.启动测试 (1)创建RequestDemo5类 123456789101112131415/** * 请求转发 */@WebServlet(&quot;/req5&quot;)public class RequestDemo5 extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; System.out.println(&quot;demo5...&quot;); &#125; @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; this.doGet(request, response); &#125;&#125; (2)创建RequestDemo6类 123456789101112131415/** * 请求转发 */@WebServlet(&quot;/req6&quot;)public class RequestDemo6 extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; System.out.println(&quot;demo6...&quot;); &#125; @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; this.doGet(request, response); &#125;&#125; (3)在RequestDemo5的doGet方法中进行请求转发 1234567891011121314151617/** * 请求转发 */@WebServlet(&quot;/req5&quot;)public class RequestDemo5 extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; System.out.println(&quot;demo5...&quot;); //请求转发 request.getRequestDispatcher(&quot;/req6&quot;).forward(request,response); &#125; @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; this.doGet(request, response); &#125;&#125; (4)启动测试 访问http://localhost:8080/request-demo/req5,就可以在控制台看到如下内容: 说明请求已经转发到了/req6 请求转发资源间共享数据:使用Request对象 此处主要解决的问题是把请求从/req5转发到/req6的时候，如何传递数据给/req6。 需要使用request对象提供的三个方法: 存储数据到request域[范围,数据是存储在request对象]中 1void setAttribute(String name,Object o); 根据key获取值 1Object getAttribute(String name); 根据key删除该键值对 1void removeAttribute(String name); 接着上个需求来: 1.在RequestDemo5的doGet方法中转发请求之前，将数据存入request域对象中 2.在RequestDemo6的doGet方法从request域对象中获取数据，并将数据打印到控制台 3.启动访问测试 (1)修改RequestDemo5中的方法 1234567891011121314151617@WebServlet(&quot;/req5&quot;)public class RequestDemo5 extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; System.out.println(&quot;demo5...&quot;); //存储数据 request.setAttribute(&quot;msg&quot;,&quot;hello&quot;); //请求转发 request.getRequestDispatcher(&quot;/req6&quot;).forward(request,response); &#125; @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; this.doGet(request, response); &#125;&#125; (2)修改RequestDemo6中的方法 12345678910111213141516171819/** * 请求转发 */@WebServlet(&quot;/req6&quot;)public class RequestDemo6 extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; System.out.println(&quot;demo6...&quot;); //获取数据 Object msg = request.getAttribute(&quot;msg&quot;); System.out.println(msg); &#125; @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; this.doGet(request, response); &#125;&#125; (3)启动测试 访问http://localhost:8080/request-demo/req5,就可以在控制台看到如下内容: 此时就可以实现在转发多个资源之间共享数据。 请求转发的特点 浏览器地址栏路径不发生变化 虽然后台从/req5转发到/req6,但是浏览器的地址一直是/req5,未发生变化 只能转发到当前服务器的内部资源 不能从一个服务器通过转发访问另一台服务器 一次请求，可以在转发资源间使用request共享数据 虽然后台从/req5转发到/req6，但是这个只有一次请求 3，Response对象 前面讲解完Request对象，接下来我们回到刚开始的那张图: Request:使用request对象来获取请求数据 Response:使用response对象来设置响应数据 Reponse的继承体系和Request的继承体系也非常相似: 介绍完Response的相关体系结构后，接下来对于Response我们需要学习如下内容: Response设置响应数据的功能介绍 Response完成重定向 Response响应字符数据 Response响应字节数据 3.1 Response设置响应数据功能介绍 HTTP响应数据总共分为三部分内容，分别是响应行、响应头、响应体，对于这三部分内容的数据，respone对象都提供了哪些方法来进行设置? 响应行 对于响应头，比较常用的就是设置响应状态码: 1void setStatus(int sc); 响应头 设置响应头键值对： 1void setHeader(String name,String value); 响应体 对于响应体，是通过字符、字节输出流的方式往浏览器写， 获取字符输出流: 1PrintWriter getWriter(); 获取字节输出流 1ServletOutputStream getOutputStream(); 介绍完这些方法后，后面我们会通过案例把这些方法都用一用，首先先来完成下重定向的功能开发。 3.2 Respones请求重定向 Response重定向(redirect):一种资源跳转方式。 (1)浏览器发送请求给服务器，服务器中对应的资源A接收到请求 (2)资源A现在无法处理该请求，就会给浏览器响应一个302的状态码+location的一个访问资源B的路径 (3)浏览器接收到响应状态码为302就会重新发送请求到location对应的访问地址去访问资源B (4)资源B接收到请求后进行处理并最终给浏览器响应结果，这整个过程就叫重定向 重定向的实现方式: 12resp.setStatus(302);resp.setHeader(&quot;location&quot;,&quot;资源B的访问路径&quot;); 具体如何来使用，我们先来看下需求: 针对上述需求，具体的实现步骤为: 1.创建一个ResponseDemo1类，接收/resp1的请求，在doGet方法中打印resp1.... 2.创建一个ResponseDemo2类，接收/resp2的请求，在doGet方法中打印resp2.... 3.在ResponseDemo1的方法中使用 ​ response.setStatus(302); ​ response.setHeader(“Location”,“/request-demo/resp2”) 来给前端响应结果数据 4.启动测试 (1)创建ResponseDemo1类 123456789101112@WebServlet(&quot;/resp1&quot;)public class ResponseDemo1 extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; System.out.println(&quot;resp1....&quot;); &#125; @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; this.doGet(request, response); &#125;&#125; (2)创建ResponseDemo2类 123456789101112@WebServlet(&quot;/resp2&quot;)public class ResponseDemo2 extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; System.out.println(&quot;resp2....&quot;); &#125; @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; this.doGet(request, response); &#125;&#125; (3)在ResponseDemo1的doGet方法中给前端响应数据 1234567891011121314151617@WebServlet(&quot;/resp1&quot;)public class ResponseDemo1 extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; System.out.println(&quot;resp1....&quot;); //重定向 //1.设置响应状态码 302 response.setStatus(302); //2. 设置响应头 Location response.setHeader(&quot;Location&quot;,&quot;/request-demo/resp2&quot;); &#125; @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; this.doGet(request, response); &#125;&#125; (4)启动测试 访问http://localhost:8080/request-demo/resp1,就可以在控制台看到如下内容: 说明/resp1和/resp2都被访问到了。到这重定向就已经完成了。 虽然功能已经实现，但是从设置重定向的两行代码来看，会发现除了重定向的地址不一样，其他的内容都是一模一样，所以request对象给我们提供了简化的编写方式为: 1resposne.sendRedirect(&quot;/request-demo/resp2&quot;) 所以第3步中的代码就可以简化为： 1234567891011121314@WebServlet(&quot;/resp1&quot;)public class ResponseDemo1 extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; System.out.println(&quot;resp1....&quot;); //重定向 resposne.sendRedirect(&quot;/request-demo/resp2&quot;)； &#125; @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; this.doGet(request, response); &#125;&#125; 重定向的特点 浏览器地址栏路径发送变化 当进行重定向访问的时候，由于是由浏览器发送的两次请求，所以地址会发生变化 可以重定向到任何位置的资源(服务内容、外部均可) 因为第一次响应结果中包含了浏览器下次要跳转的路径，所以这个路径是可以任意位置资源。 两次请求，不能在多个资源使用request共享数据 因为浏览器发送了两次请求，是两个不同的request对象，就无法通过request对象进行共享数据 介绍完请求重定向和请求转发以后，接下来需要把这两个放在一块对比下: 以后到底用哪个，还是需要根据具体的业务来决定。 3.3 路径问题 问题1：转发的时候路径上没有加/request-demo而重定向加了，那么到底什么时候需要加，什么时候不需要加呢? 其实判断的依据很简单，只需要记住下面的规则即可: 浏览器使用:需要加虚拟目录(项目访问路径) 服务端使用:不需要加虚拟目录 对于转发来说，因为是在服务端进行的，所以不需要加虚拟目录 对于重定向来说，路径最终是由浏览器来发送请求，就需要添加虚拟目录。 掌握了这个规则，接下来就通过一些练习来强化下知识的学习: &lt;a href='路劲'&gt; &lt;form action='路径'&gt; req.getRequestDispatcher(“路径”) resp.sendRedirect(“路径”) 答案: 12341.超链接，从浏览器发送，需要加2.表单，从浏览器发送，需要加3.转发，是从服务器内部跳转，不需要加4.重定向，是由浏览器进行跳转，需要加。 问题2：在重定向的代码中，/request-demo是固定编码的，如果后期通过Tomcat插件配置了项目的访问路径，那么所有需要重定向的地方都需要重新修改，该如何优化? 答案也比较简单，我们可以在代码中动态去获取项目访问的虚拟目录，具体如何获取，我们可以借助前面咱们所学习的request对象中的getContextPath()方法，修改后的代码如下: 1234567891011121314151617@WebServlet(&quot;/resp1&quot;)public class ResponseDemo1 extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; System.out.println(&quot;resp1....&quot;); //简化方式完成重定向 //动态获取虚拟目录 String contextPath = request.getContextPath(); response.sendRedirect(contextPath+&quot;/resp2&quot;); &#125; @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; this.doGet(request, response); &#125;&#125; 重新启动访问测试，功能依然能够实现，此时就可以动态获取项目访问的虚拟路径，从而降低代码的耦合度。 3.4 Response响应字符数据 要想将字符数据写回到浏览器，我们需要两个步骤: 通过Response对象获取字符输出流： PrintWriter writer = resp.getWriter(); 通过字符输出流写数据: writer.write(“aaa”); 接下来，我们实现通过些案例把响应字符数据给实际应用下: 返回一个简单的字符串aaa 1234567891011121314151617/** * 响应字符数据：设置字符数据的响应体 */@WebServlet(&quot;/resp3&quot;)public class ResponseDemo3 extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; response.setContentType(&quot;text/html;charset=utf-8&quot;); //1. 获取字符输出流 PrintWriter writer = response.getWriter(); writer.write(&quot;aaa&quot;); &#125; @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; this.doGet(request, response); &#125;&#125; 返回一串html字符串，并且能被浏览器解析 1234PrintWriter writer = response.getWriter();//content-type，告诉浏览器返回的数据类型是HTML类型数据，这样浏览器才会解析HTML标签response.setHeader(&quot;content-type&quot;,&quot;text/html&quot;);writer.write(&quot;&lt;h1&gt;aaa&lt;/h1&gt;&quot;); ==注意:==一次请求响应结束后，response对象就会被销毁掉，所以不要手动关闭流。 返回一个中文的字符串你好，需要注意设置响应数据的编码为utf-8 123//设置响应的数据格式及数据的编码response.setContentType(&quot;text/html;charset=utf-8&quot;);writer.write(&quot;你好&quot;); 3.3 Response响应字节数据 要想将字节数据写回到浏览器，我们需要两个步骤: 通过Response对象获取字节输出流：ServletOutputStream outputStream = resp.getOutputStream(); 通过字节输出流写数据: outputStream.write(字节数据); 接下来，我们实现通过些案例把响应字符数据给实际应用下: 返回一个图片文件到浏览器 12345678910111213141516171819202122232425/** * 响应字节数据：设置字节数据的响应体 */@WebServlet(&quot;/resp4&quot;)public class ResponseDemo4 extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; //1. 读取文件 FileInputStream fis = new FileInputStream(&quot;d://a.jpg&quot;); //2. 获取response字节输出流 ServletOutputStream os = response.getOutputStream(); //3. 完成流的copy byte[] buff = new byte[1024]; int len = 0; while ((len = fis.read(buff))!= -1)&#123; os.write(buff,0,len); &#125; fis.close(); &#125; @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; this.doGet(request, response); &#125;&#125; 上述代码中，对于流的copy的代码还是比较复杂的，所以我们可以使用别人提供好的方法来简化代码的开发，具体的步骤是: (1)pom.xml添加依赖 12345&lt;dependency&gt; &lt;groupId&gt;commons-io&lt;/groupId&gt; &lt;artifactId&gt;commons-io&lt;/artifactId&gt; &lt;version&gt;2.6&lt;/version&gt;&lt;/dependency&gt; (2)调用工具类方法 123//fis:输入流//os:输出流IOUtils.copy(fis,os); 优化后的代码: 123456789101112131415161718192021/** * 响应字节数据：设置字节数据的响应体 */@WebServlet(&quot;/resp4&quot;)public class ResponseDemo4 extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; //1. 读取文件 FileInputStream fis = new FileInputStream(&quot;d://a.jpg&quot;); //2. 获取response字节输出流 ServletOutputStream os = response.getOutputStream(); //3. 完成流的copy IOUtils.copy(fis,os); fis.close(); &#125; @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; this.doGet(request, response); &#125;&#125; 4，用户注册登录案例 接下来我们通过两个比较常见的案例，一个是注册，一个是登录来对今天学习的内容进行一个实战演练，首先来实现用户登录。 4.1 用户登录 4.1.1 需求分析 用户在登录页面输入用户名和密码，提交请求给LoginServlet 在LoginServlet中接收请求和数据[用户名和密码] 在LoginServlt中通过Mybatis实现调用UserMapper来根据用户名和密码查询数据库表 将查询的结果封装到User对象中进行返回 在LoginServlet中判断返回的User对象是否为null 如果为nul，说明根据用户名和密码没有查询到用户，则登录失败，返回&quot;登录失败&quot;数据给前端 如果不为null,则说明用户存在并且密码正确，则登录成功，返回&quot;登录成功&quot;数据给前端 4.1.2 环境准备 复制资料中的静态页面到项目的webapp目录下 参考资料\\1. 登陆注册案例\\1. 静态页面,拷贝完效果如下: 创建db1数据库，创建tb_user表，创建User实体类 2.1 将资料\\1. 登陆注册案例\\2. MyBatis环境\\tb_user.sql中的sql语句执行下: 2.2 将资料\\1. 登陆注册案例\\2. MyBatis环境\\User.java拷贝到com.itheima.pojo 在项目的pom.xml导入Mybatis和Mysql驱动坐标 1234567891011&lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.5.5&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.34&lt;/version&gt;&lt;/dependency&gt; 创建mybatis-config.xml核心配置文件，UserMapper.xml映射文件,UserMapper接口 4.1 将资料\\1. 登陆注册案例\\2. MyBatis环境\\mybatis-config.xml拷贝到resources目录下 12345678910111213141516171819202122232425262728293031&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt; &lt;!--起别名--&gt; &lt;typeAliases&gt; &lt;package name=&quot;com.itheima.pojo&quot;/&gt; &lt;/typeAliases&gt; &lt;environments default=&quot;development&quot;&gt; &lt;environment id=&quot;development&quot;&gt; &lt;transactionManager type=&quot;JDBC&quot;/&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;property name=&quot;driver&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt; &lt;!-- useSSL:关闭SSL安全连接 性能更高 useServerPrepStmts:开启预编译功能 &amp;amp; 等同于 &amp; ,xml配置文件中不能直接写 &amp;符号 --&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql:///db1?useSSL=false&amp;amp;useServerPrepStmts=true&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;1234&quot;/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;mappers&gt; &lt;!--扫描mapper--&gt; &lt;package name=&quot;com.itheima.mapper&quot;/&gt; &lt;/mappers&gt;&lt;/configuration&gt; 4.2 在com.itheima.mapper包下创建UserMapper接口 123public interface UserMapper &#123;&#125; 4.3 将资料\\1. 登陆注册案例\\2. MyBatis环境\\UserMapper.xml拷贝到resources目录下 注意：在resources下创建UserMapper.xml的目录时，要使用/分割 至此我们所需要的环境就都已经准备好了，具体该如何实现? 4.1.3 代码实现 在UserMapper接口中提供一个根据用户名和密码查询用户对象的方法 12345678/** * 根据用户名和密码查询用户对象 * @param username * @param password * @return */ @Select(&quot;select * from tb_user where username = #&#123;username&#125; and password = #&#123;password&#125;&quot;) User select(@Param(&quot;username&quot;) String username,@Param(&quot;password&quot;) String password); 说明 @Param注解的作用:用于传递参数,是方法的参数可以与SQL中的字段名相对应。 修改loign.html 123456789101112131415161718192021222324252627&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;login&lt;/title&gt; &lt;link href=&quot;css/login.css&quot; rel=&quot;stylesheet&quot;&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;loginDiv&quot;&gt; &lt;form action=&quot;/request-demo/loginServlet&quot; method=&quot;post&quot; id=&quot;form&quot;&gt; &lt;h1 id=&quot;loginMsg&quot;&gt;LOGIN IN&lt;/h1&gt; &lt;p&gt;Username:&lt;input id=&quot;username&quot; name=&quot;username&quot; type=&quot;text&quot;&gt;&lt;/p&gt; &lt;p&gt;Password:&lt;input id=&quot;password&quot; name=&quot;password&quot; type=&quot;password&quot;&gt;&lt;/p&gt; &lt;div id=&quot;subDiv&quot;&gt; &lt;input type=&quot;submit&quot; class=&quot;button&quot; value=&quot;login up&quot;&gt; &lt;input type=&quot;reset&quot; class=&quot;button&quot; value=&quot;reset&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;a href=&quot;register.html&quot;&gt;没有账号？点击注册&lt;/a&gt; &lt;/div&gt; &lt;/form&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 编写LoginServlet 1234567891011121314151617181920212223242526272829303132333435363738394041@WebServlet(&quot;/loginServlet&quot;)public class LoginServlet extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; //1. 接收用户名和密码 String username = request.getParameter(&quot;username&quot;); String password = request.getParameter(&quot;password&quot;); //2. 调用MyBatis完成查询 //2.1 获取SqlSessionFactory对象 String resource = &quot;mybatis-config.xml&quot;; InputStream inputStream = Resources.getResourceAsStream(resource); SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); //2.2 获取SqlSession对象 SqlSession sqlSession = sqlSessionFactory.openSession(); //2.3 获取Mapper UserMapper userMapper = sqlSession.getMapper(UserMapper.class); //2.4 调用方法 User user = userMapper.select(username, password); //2.5 释放资源 sqlSession.close(); //获取字符输出流，并设置content type response.setContentType(&quot;text/html;charset=utf-8&quot;); PrintWriter writer = response.getWriter(); //3. 判断user释放为null if(user != null)&#123; // 登陆成功 writer.write(&quot;登陆成功&quot;); &#125;else &#123; // 登陆失败 writer.write(&quot;登陆失败&quot;); &#125; &#125; @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; this.doGet(request, response); &#125;&#125; 启动服务器测试 4.1 如果用户名和密码输入错误，则 4.2 如果用户名和密码输入正确，则 至此用户的登录功能就已经完成了~ 4.2 用户注册 4.2.1 需求分析 用户在注册页面输入用户名和密码，提交请求给RegisterServlet 在RegisterServlet中接收请求和数据[用户名和密码] 在RegisterServlet中通过Mybatis实现调用UserMapper来根据用户名查询数据库表 将查询的结果封装到User对象中进行返回 在RegisterServlet中判断返回的User对象是否为null 如果为nul，说明根据用户名可用，则调用UserMapper来实现添加用户 如果不为null,则说明用户不可以，返回&quot;用户名已存在&quot;数据给前端 4.2.2 代码编写 编写UserMapper提供根据用户名查询用户数据方法和添加用户方法 1234567891011121314/*** 根据用户名查询用户对象* @param username* @return*/@Select(&quot;select * from tb_user where username = #&#123;username&#125;&quot;)User selectByUsername(String username);/*** 添加用户* @param user*/@Insert(&quot;insert into tb_user values(null,#&#123;username&#125;,#&#123;password&#125;)&quot;)void add(User user); 修改register.html 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;欢迎注册&lt;/title&gt; &lt;link href=&quot;css/register.css&quot; rel=&quot;stylesheet&quot;&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;form-div&quot;&gt; &lt;div class=&quot;reg-content&quot;&gt; &lt;h1&gt;欢迎注册&lt;/h1&gt; &lt;span&gt;已有帐号？&lt;/span&gt; &lt;a href=&quot;login.html&quot;&gt;登录&lt;/a&gt; &lt;/div&gt; &lt;form id=&quot;reg-form&quot; action=&quot;/request-demo/registerServlet&quot; method=&quot;post&quot;&gt; &lt;table&gt; &lt;tr&gt; &lt;td&gt;用户名&lt;/td&gt; &lt;td class=&quot;inputs&quot;&gt; &lt;input name=&quot;username&quot; type=&quot;text&quot; id=&quot;username&quot;&gt; &lt;br&gt; &lt;span id=&quot;username_err&quot; class=&quot;err_msg&quot; style=&quot;display: none&quot;&gt;用户名不太受欢迎&lt;/span&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;密码&lt;/td&gt; &lt;td class=&quot;inputs&quot;&gt; &lt;input name=&quot;password&quot; type=&quot;password&quot; id=&quot;password&quot;&gt; &lt;br&gt; &lt;span id=&quot;password_err&quot; class=&quot;err_msg&quot; style=&quot;display: none&quot;&gt;密码格式有误&lt;/span&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;div class=&quot;buttons&quot;&gt; &lt;input value=&quot;注 册&quot; type=&quot;submit&quot; id=&quot;reg_btn&quot;&gt; &lt;/div&gt; &lt;br class=&quot;clear&quot;&gt; &lt;/form&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 创建RegisterServlet类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748@WebServlet(&quot;/registerServlet&quot;)public class RegisterServlet extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; //1. 接收用户数据 String username = request.getParameter(&quot;username&quot;); String password = request.getParameter(&quot;password&quot;); //封装用户对象 User user = new User(); user.setUsername(username); user.setPassword(password); //2. 调用mapper 根据用户名查询用户对象 //2.1 获取SqlSessionFactory对象 String resource = &quot;mybatis-config.xml&quot;; InputStream inputStream = Resources.getResourceAsStream(resource); SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); //2.2 获取SqlSession对象 SqlSession sqlSession = sqlSessionFactory.openSession(); //2.3 获取Mapper UserMapper userMapper = sqlSession.getMapper(UserMapper.class); //2.4 调用方法 User u = userMapper.selectByUsername(username); //3. 判断用户对象释放为null if( u == null)&#123; // 用户名不存在，添加用户 userMapper.add(user); // 提交事务 sqlSession.commit(); // 释放资源 sqlSession.close(); &#125;else &#123; // 用户名存在，给出提示信息 response.setContentType(&quot;text/html;charset=utf-8&quot;); response.getWriter().write(&quot;用户名已存在&quot;); &#125; &#125; @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; this.doGet(request, response); &#125;&#125; 启动服务器进行测试 4.1 如果测试成功，则在数据库中就能查看到新注册的数据 4.2 如果用户已经存在，则在页面上展示 用户名已存在 的提示信息 4.3 SqlSessionFactory工具类抽取 上面两个功能已经实现，但是在写Servlet的时候，因为需要使用Mybatis来完成数据库的操作，所以对于Mybatis的基础操作就出现了些重复代码，如下 1234String resource = &quot;mybatis-config.xml&quot;;InputStream inputStream = Resources.getResourceAsStream(resource);SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); 有了这些重复代码就会造成一些问题: 重复代码不利于后期的维护 SqlSessionFactory工厂类进行重复创建 就相当于每次买手机都需要重新创建一个手机生产工厂来给你制造一个手机一样，资源消耗非常大但性能却非常低。所以这么做是不允许的。 那如何来优化呢？ 代码重复可以抽取工具类 对指定代码只需要执行一次可以使用静态代码块 有了这两个方向后，代码具体该如何编写? 1234567891011121314151617181920public class SqlSessionFactoryUtils &#123; private static SqlSessionFactory sqlSessionFactory; static &#123; //静态代码块会随着类的加载而自动执行，且只执行一次 try &#123; String resource = &quot;mybatis-config.xml&quot;; InputStream inputStream = Resources.getResourceAsStream(resource); sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; public static SqlSessionFactory getSqlSessionFactory()&#123; return sqlSessionFactory; &#125;&#125; 工具类抽取以后，以后在对Mybatis的SqlSession进行操作的时候，就可以直接使用 1SqlSessionFactory sqlSessionFactory =SqlSessionFactoryUtils.getSqlSessionFactory(); 这样就可以很好的解决上面所说的代码重复和重复创建工厂导致性能低的问题了。 来源：it 黑马 JavaWeb 教程","categories":[{"name":"Java","slug":"Java","permalink":"http://littlewuuu.com/categories/Java/"}],"tags":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://littlewuuu.com/tags/JavaWeb/"}]},{"title":"Vue&ElementUI","slug":"黑马/13-VUE&Element&综合案例","date":"2022-08-21T22:00:00.000Z","updated":"2022-12-01T15:44:55.805Z","comments":true,"path":"2022/08/22/黑马/13-VUE&Element&综合案例/","link":"","permalink":"http://littlewuuu.com/2022/08/22/%E9%BB%91%E9%A9%AC/13-VUE&Element&%E7%BB%BC%E5%90%88%E6%A1%88%E4%BE%8B/","excerpt":"","text":"VUE&amp;Element 今日目标： 能够使用VUE中常用指令和插值表达式 能够使用VUE生命周期函数 mounted 能够进行简单的 Element 页面修改 能够完成查询所有功能 能够完成添加功能 1，VUE 1.1 概述 接下来我们学习一款前端的框架，就是 VUE。 Vue 是一套前端框架，免除原生JavaScript中的DOM操作，简化书写。 我们之前也学习过后端的框架 Mybatis ，Mybatis 是用来简化 jdbc 代码编写的；而 VUE 是前端的框架，是用来简化 JavaScript 代码编写的。前一天我们做了一个综合性的案例，里面进行了大量的DOM操作，如下 学习了 VUE 后，这部分代码我们就不需要再写了。那么 VUE 是如何简化 DOM 书写呢？ ==基于MVVM(Model-View-ViewModel)思想，实现数据的双向绑定，将编程的关注点放在数据上。==之前我们是将关注点放在了 DOM 操作上；而要了解 MVVM 思想，必须先聊聊 MVC 思想，如下图就是 MVC 思想图解 C 就是咱们 js 代码，M 就是数据，而 V 是页面上展示的内容，如下图是我们之前写的代码 MVC 思想是没法进行双向绑定的。双向绑定是指当数据模型数据发生变化时，页面展示的会随之发生变化，而如果表单数据发生变化，绑定的模型数据也随之发生变化。接下来我们聊聊 MVVM 思想，如下图是三个组件图解 图中的 Model 就是我们的数据，View 是视图，也就是页面标签，用户可以通过浏览器看到的内容；Model 和 View 是通过 ViewModel 对象进行双向绑定的，而 ViewModel 对象是 Vue 提供的。接下来让大家看一下双向绑定的效果，下图是提前准备的代码，输入框绑定了 username 模型数据，而在页面上也使用 &#123;&#123;&#125;&#125; 绑定了 username 模型数据 通过浏览器打开该页面可以看到如下页面 当我们在输入框中输入内容，而输入框后面随之实时的展示我们输入的内容，这就是双向绑定的效果。 1.2 快速入门 Vue 使用起来是比较简单的，总共分为如下三步： 新建 HTML 页面，引入 Vue.js文件 1&lt;script src=&quot;js/vue.js&quot;&gt;&lt;/script&gt; 在JS代码区域，创建Vue核心对象，进行数据绑定 12345678new Vue(&#123; el: &quot;#app&quot;, data() &#123; return &#123; username: &quot;&quot; &#125; &#125;&#125;); 创建 Vue 对象时，需要传递一个 js 对象，而该对象中需要如下属性： el ： 用来指定哪儿些标签受 Vue 管理。 该属性取值 #app 中的 app 需要是受管理的标签的id属性值 data ：用来定义数据模型 methods ：用来定义函数。这个我们在后面就会用到 编写视图 1234&lt;div id=&quot;app&quot;&gt; &lt;input name=&quot;username&quot; v-model=&quot;username&quot; &gt; &#123;&#123;username&#125;&#125;&lt;/div&gt; &#123;&#123;&#125;&#125; 是 Vue 中定义的 插值表达式 ，在里面写数据模型，到时候会将该模型的数据值展示在这个位置。 整体代码如下： 123456789101112131415161718192021222324252627282930313233&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;app&quot;&gt; &lt;input v-model=&quot;username&quot;&gt; &lt;!--插值表达式--&gt; &#123;&#123;username&#125;&#125;&lt;/div&gt;&lt;script src=&quot;js/vue.js&quot;&gt;&lt;/script&gt;&lt;script&gt; //1. 创建Vue核心对象 new Vue(&#123; el:&quot;#app&quot;, data()&#123; // data() 是 ECMAScript 6 版本的新的写法 return &#123; username:&quot;&quot; &#125; &#125; /*data: function () &#123; return &#123; username:&quot;&quot; &#125; &#125;*/ &#125;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 1.3 Vue 指令 **指令：**HTML 标签上带有 v- 前缀的特殊属性，不同指令具有不同含义。例如：v-if，v-for… 常用的指令有： 指令 作用 v-bind 为HTML标签绑定属性值，如设置 href , css样式等 v-model 在表单元素上创建双向数据绑定，用户输入框 v-on 为HTML标签绑定事件 v-if 条件性的渲染某元素，判定为true时渲染,否则不渲染 v-else v-else-if v-show 根据条件展示某元素，区别在于切换的是display属性的值 v-for 列表渲染，遍历容器的元素或者对象的属性 接下来我们挨个学习这些指令 1.3.1 v-bind &amp; v-model 指令 v-bind 该指令可以给标签原有属性绑定模型数据。这样模型数据发生变化，标签属性值也随之发生变化 例如： 1&lt;a v-bind:href=&quot;url&quot;&gt;百度一下&lt;/a&gt; 上面的 v-bind:&quot; 可以简化写成 : ，如下： 1234&lt;!-- v-bind 可以省略--&gt;&lt;a :href=&quot;url&quot;&gt;百度一下&lt;/a&gt; v-model 该指令可以给表单项标签绑定模型数据。这样就能实现双向绑定效果。例如： 1&lt;input name=&quot;username&quot; v-model=&quot;username&quot;&gt; 代码演示： 12345678910111213141516171819202122232425262728&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;app&quot;&gt; &lt;a v-bind:href=&quot;url&quot;&gt;点击一下&lt;/a&gt; &lt;a :href=&quot;url&quot;&gt;点击一下&lt;/a&gt; &lt;input v-model=&quot;url&quot;&gt;&lt;/div&gt;&lt;script src=&quot;js/vue.js&quot;&gt;&lt;/script&gt;&lt;script&gt; //1. 创建Vue核心对象 new Vue(&#123; el:&quot;#app&quot;, data()&#123; return &#123; username:&quot;&quot;, url:&quot;https://www.baidu.com&quot; &#125; &#125; &#125;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 通过浏览器打开上面页面，并且使用检查查看超链接的路径，该路径会根据输入框输入的路径变化而变化，这是因为超链接和输入框绑定的是同一个模型数据 1.3.2 v-on 指令 我们在页面定义一个按钮，并给该按钮使用 v-on 指令绑定单击事件，html代码如下 1&lt;input type=&quot;button&quot; value=&quot;一个按钮&quot; v-on:click=&quot;show()&quot;&gt; 而使用 v-on 时还可以使用简化的写法，将 v-on: 替换成 @，html代码如下 1&lt;input type=&quot;button&quot; value=&quot;一个按钮&quot; @click=&quot;show()&quot;&gt; 上面代码绑定的 show() 需要在 Vue 对象中的 methods 属性中定义出来 12345678new Vue(&#123; el: &quot;#app&quot;, methods: &#123; show()&#123; alert(&quot;我被点了&quot;); &#125; &#125;&#125;); 注意：v-on: 后面的事件名称是之前原生事件属性名去掉on。 例如： 单击事件 ： 事件属性名是 onclick，而在vue中使用是 v-on:click 失去焦点事件：事件属性名是 onblur，而在vue中使用时 v-on:blur 整体页面代码如下： 123456789101112131415161718192021222324252627282930&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;button&quot; value=&quot;一个按钮&quot; v-on:click=&quot;show()&quot;&gt;&lt;br&gt; &lt;input type=&quot;button&quot; value=&quot;一个按钮&quot; @click=&quot;show()&quot;&gt;&lt;/div&gt;&lt;script src=&quot;js/vue.js&quot;&gt;&lt;/script&gt;&lt;script&gt; //1. 创建Vue核心对象 new Vue(&#123; el:&quot;#app&quot;, data()&#123; return &#123; username:&quot;&quot;, &#125; &#125;, methods:&#123; show()&#123; alert(&quot;我被点了...&quot;); &#125; &#125; &#125;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 1.3.3 条件判断指令 接下来通过代码演示一下。在 Vue中定义一个 count 的数据模型，如下 123456789//1. 创建Vue核心对象new Vue(&#123; el:&quot;#app&quot;, data()&#123; return &#123; count:3 &#125; &#125;&#125;); 现在要实现，当 count 模型的数据是3时，在页面上展示 div1 内容；当 count 模型的数据是4时，在页面上展示 div2 内容；count 模型数据是其他值时，在页面上展示 div3。这里为了动态改变模型数据 count 的值，再定义一个输入框绑定 count 模型数据。html 代码如下： 1234567&lt;div id=&quot;app&quot;&gt; &lt;div v-if=&quot;count == 3&quot;&gt;div1&lt;/div&gt; &lt;div v-else-if=&quot;count == 4&quot;&gt;div2&lt;/div&gt; &lt;div v-else&gt;div3&lt;/div&gt; &lt;hr&gt; &lt;input v-model=&quot;count&quot;&gt;&lt;/div&gt; 整体页面代码如下： 1234567891011121314151617181920212223242526272829&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;app&quot;&gt; &lt;div v-if=&quot;count == 3&quot;&gt;div1&lt;/div&gt; &lt;div v-else-if=&quot;count == 4&quot;&gt;div2&lt;/div&gt; &lt;div v-else&gt;div3&lt;/div&gt; &lt;hr&gt; &lt;input v-model=&quot;count&quot;&gt;&lt;/div&gt;&lt;script src=&quot;js/vue.js&quot;&gt;&lt;/script&gt;&lt;script&gt; //1. 创建Vue核心对象 new Vue(&#123; el:&quot;#app&quot;, data()&#123; return &#123; count:3 &#125; &#125; &#125;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 通过浏览器打开页面并在输入框输入不同的值，效果如下 然后我们在看看 v-show 指令的效果，如果模型数据 count 的值是3时，展示 div v-show 内容，否则不展示，html页面代码如下 123&lt;div v-show=&quot;count == 3&quot;&gt;div v-show&lt;/div&gt;&lt;br&gt;&lt;input v-model=&quot;count&quot;&gt; 浏览器打开效果如下： 通过上面的演示，发现 v-show 和 v-if 效果一样，那它们到底有什么区别呢？我们根据浏览器的检查功能查看源代码 通过上图可以看出 v-show 不展示的原理是给对应的标签添加 display css属性，并将该属性值设置为 none ，这样就达到了隐藏的效果。而 v-if 指令是条件不满足时根本就不会渲染。 1.3.4 v-for 指令 这个指令看到名字就知道是用来遍历的，该指令使用的格式如下： 123&lt;标签 v-for=&quot;变量名 in 集合模型数据&quot;&gt; &#123;&#123;变量名&#125;&#125;&lt;/标签&gt; 注意：需要循环那个标签，v-for 指令就写在那个标签上。 如果在页面需要使用到集合模型数据的索引，就需要使用如下格式： 1234&lt;标签 v-for=&quot;(变量名,索引变量) in 集合模型数据&quot;&gt; &lt;!--索引变量是从0开始，所以要表示序号的话，需要手动的加1--&gt; &#123;&#123;索引变量 + 1&#125;&#125; &#123;&#123;变量名&#125;&#125;&lt;/标签&gt; 代码演示： 123456789101112131415161718192021222324252627282930313233&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;app&quot;&gt; &lt;div v-for=&quot;addr in addrs&quot;&gt; &#123;&#123;addr&#125;&#125; &lt;br&gt; &lt;/div&gt; &lt;hr&gt; &lt;div v-for=&quot;(addr,i) in addrs&quot;&gt; &#123;&#123;i+1&#125;&#125;--&#123;&#123;addr&#125;&#125; &lt;br&gt; &lt;/div&gt;&lt;/div&gt;&lt;script src=&quot;js/vue.js&quot;&gt;&lt;/script&gt;&lt;script&gt; //1. 创建Vue核心对象 new Vue(&#123; el:&quot;#app&quot;, data()&#123; return &#123; addrs:[&quot;北京&quot;,&quot;上海&quot;,&quot;西安&quot;] &#125; &#125; &#125;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 通过浏览器打开效果如下 1.4 生命周期 生命周期的八个阶段：每触发一个生命周期事件，会自动执行一个生命周期方法，这些生命周期方法也被称为钩子方法。 下图是 Vue 官网提供的从创建 Vue 到效果 Vue 对象的整个过程及各个阶段对应的钩子函数 看到上面的图，大家无需过多的关注这张图。这些钩子方法我们只关注 mounted 就行了。 mounted：挂载完成，Vue初始化成功，HTML页面渲染成功。而以后我们会在该方法中发送异步请求，加载数据。 1.5 案例 1.5.1 需求 使用 Vue 简化我们在前一天ajax学完后做的品牌列表数据查询和添加功能 此案例只是使用 Vue 对前端代码进行优化，后端代码无需修改。 1.5.2 查询所有功能 在 brand.html 页面引入 vue 的js文件 1&lt;script src=&quot;js/vue.js&quot;&gt;&lt;/script&gt; 创建 Vue 对象 在 Vue 对象中定义模型数据 在钩子函数中发送异步请求，并将响应的数据赋值给数据模型 123456789101112131415161718new Vue(&#123; el: &quot;#app&quot;, data()&#123; return&#123; brands:[] &#125; &#125;, mounted()&#123; // 页面加载完成后，发送异步请求，查询数据 var _this = this; axios(&#123; method:&quot;get&quot;, url:&quot;http://localhost:8080/brand-demo/selectAllServlet&quot; &#125;).then(function (resp) &#123; _this.brands = resp.data; &#125;) &#125;&#125;) 修改视图 定义 &lt;div id=&quot;app&quot;&gt;&lt;/div&gt; ，指定该 div 标签受 Vue 管理 将 body 标签中所有的内容拷贝作为上面 div 标签中 删除表格的多余数据行，只留下一个 在表格中的数据行上使用 v-for 指令遍历 123456789&lt;tr v-for=&quot;(brand,i) in brands&quot; align=&quot;center&quot;&gt; &lt;td&gt;&#123;&#123;i + 1&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;brand.brandName&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;brand.companyName&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;brand.ordered&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;brand.description&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;brand.statusStr&#125;&#125;&lt;/td&gt; &lt;td&gt;&lt;a href=&quot;#&quot;&gt;修改&lt;/a&gt; &lt;a href=&quot;#&quot;&gt;删除&lt;/a&gt;&lt;/td&gt;&lt;/tr&gt; 整体页面代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;app&quot;&gt; &lt;a href=&quot;addBrand.html&quot;&gt;&lt;input type=&quot;button&quot; value=&quot;新增&quot;&gt;&lt;/a&gt;&lt;br&gt; &lt;hr&gt; &lt;table id=&quot;brandTable&quot; border=&quot;1&quot; cellspacing=&quot;0&quot; width=&quot;100%&quot;&gt; &lt;tr&gt; &lt;th&gt;序号&lt;/th&gt; &lt;th&gt;品牌名称&lt;/th&gt; &lt;th&gt;企业名称&lt;/th&gt; &lt;th&gt;排序&lt;/th&gt; &lt;th&gt;品牌介绍&lt;/th&gt; &lt;th&gt;状态&lt;/th&gt; &lt;th&gt;操作&lt;/th&gt; &lt;/tr&gt; &lt;!-- 使用v-for遍历tr --&gt; &lt;tr v-for=&quot;(brand,i) in brands&quot; align=&quot;center&quot;&gt; &lt;td&gt;&#123;&#123;i + 1&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;brand.brandName&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;brand.companyName&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;brand.ordered&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;brand.description&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;brand.statusStr&#125;&#125;&lt;/td&gt; &lt;td&gt;&lt;a href=&quot;#&quot;&gt;修改&lt;/a&gt; &lt;a href=&quot;#&quot;&gt;删除&lt;/a&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt;&lt;/div&gt;&lt;script src=&quot;js/axios-0.18.0.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;js/vue.js&quot;&gt;&lt;/script&gt;&lt;script&gt; new Vue(&#123; el: &quot;#app&quot;, data()&#123; return&#123; brands:[] &#125; &#125;, mounted()&#123; // 页面加载完成后，发送异步请求，查询数据 var _this = this; axios(&#123; method:&quot;get&quot;, url:&quot;http://localhost:8080/brand-demo/selectAllServlet&quot; &#125;).then(function (resp) &#123; _this.brands = resp.data; &#125;) &#125; &#125;)&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 1.5.3 添加功能 页面操作效果如下： 整体流程如下 注意：前端代码的关键点在于使用 v-model 指令给标签项绑定模型数据，利用双向绑定特性，在发送异步请求时提交数据。 在 addBrand.html 页面引入 vue 的js文件 1&lt;script src=&quot;js/vue.js&quot;&gt;&lt;/script&gt; 创建 Vue 对象 在 Vue 对象中定义模型数据 brand 定义一个 submitForm() 函数，用于给 提交 按钮提供绑定的函数 在 submitForm() 函数中发送 ajax 请求，并将模型数据 brand 作为参数进行传递 12345678910111213141516171819202122232425new Vue(&#123; el: &quot;#app&quot;, data()&#123; return &#123; brand:&#123;&#125; &#125; &#125;, methods:&#123; submitForm()&#123; // 发送ajax请求，添加 var _this = this; axios(&#123; method:&quot;post&quot;, url:&quot;http://localhost:8080/brand-demo/addServlet&quot;, data:_this.brand &#125;).then(function (resp) &#123; // 判断响应数据是否为 success if(resp.data == &quot;success&quot;)&#123; location.href = &quot;http://localhost:8080/brand-demo/brand.html&quot;; &#125; &#125;) &#125; &#125;&#125;) 修改视图 定义 &lt;div id=&quot;app&quot;&gt;&lt;/div&gt; ，指定该 div 标签受 Vue 管理 将 body 标签中所有的内容拷贝作为上面 div 标签中 给每一个表单项标签绑定模型数据。最后这些数据要被封装到 brand 对象中 1234567891011121314&lt;div id=&quot;app&quot;&gt; &lt;h3&gt;添加品牌&lt;/h3&gt; &lt;form action=&quot;&quot; method=&quot;post&quot;&gt; 品牌名称：&lt;input id=&quot;brandName&quot; v-model=&quot;brand.brandName&quot; name=&quot;brandName&quot;&gt;&lt;br&gt; 企业名称：&lt;input id=&quot;companyName&quot; v-model=&quot;brand.companyName&quot; name=&quot;companyName&quot;&gt;&lt;br&gt; 排序：&lt;input id=&quot;ordered&quot; v-model=&quot;brand.ordered&quot; name=&quot;ordered&quot;&gt;&lt;br&gt; 描述信息：&lt;textarea rows=&quot;5&quot; cols=&quot;20&quot; id=&quot;description&quot; v-model=&quot;brand.description&quot; name=&quot;description&quot;&gt;&lt;/textarea&gt;&lt;br&gt; 状态： &lt;input type=&quot;radio&quot; name=&quot;status&quot; v-model=&quot;brand.status&quot; value=&quot;0&quot;&gt;禁用 &lt;input type=&quot;radio&quot; name=&quot;status&quot; v-model=&quot;brand.status&quot; value=&quot;1&quot;&gt;启用&lt;br&gt; &lt;input type=&quot;button&quot; id=&quot;btn&quot; @click=&quot;submitForm&quot; value=&quot;提交&quot;&gt; &lt;/form&gt;&lt;/div&gt; 整体页面代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;添加品牌&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;app&quot;&gt; &lt;h3&gt;添加品牌&lt;/h3&gt; &lt;form action=&quot;&quot; method=&quot;post&quot;&gt; 品牌名称：&lt;input id=&quot;brandName&quot; v-model=&quot;brand.brandName&quot; name=&quot;brandName&quot;&gt;&lt;br&gt; 企业名称：&lt;input id=&quot;companyName&quot; v-model=&quot;brand.companyName&quot; name=&quot;companyName&quot;&gt;&lt;br&gt; 排序：&lt;input id=&quot;ordered&quot; v-model=&quot;brand.ordered&quot; name=&quot;ordered&quot;&gt;&lt;br&gt; 描述信息：&lt;textarea rows=&quot;5&quot; cols=&quot;20&quot; id=&quot;description&quot; v-model=&quot;brand.description&quot; name=&quot;description&quot;&gt;&lt;/textarea&gt;&lt;br&gt; 状态： &lt;input type=&quot;radio&quot; name=&quot;status&quot; v-model=&quot;brand.status&quot; value=&quot;0&quot;&gt;禁用 &lt;input type=&quot;radio&quot; name=&quot;status&quot; v-model=&quot;brand.status&quot; value=&quot;1&quot;&gt;启用&lt;br&gt; &lt;input type=&quot;button&quot; id=&quot;btn&quot; @click=&quot;submitForm&quot; value=&quot;提交&quot;&gt; &lt;/form&gt;&lt;/div&gt;&lt;script src=&quot;js/axios-0.18.0.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;js/vue.js&quot;&gt;&lt;/script&gt;&lt;script&gt; new Vue(&#123; el: &quot;#app&quot;, data()&#123; return &#123; brand:&#123;&#125; &#125; &#125;, methods:&#123; submitForm()&#123; // 发送ajax请求，添加 var _this = this; axios(&#123; method:&quot;post&quot;, url:&quot;http://localhost:8080/brand-demo/addServlet&quot;, data:_this.brand &#125;).then(function (resp) &#123; // 判断响应数据是否为 success if(resp.data == &quot;success&quot;)&#123; location.href = &quot;http://localhost:8080/brand-demo/brand.html&quot;; &#125; &#125;) &#125; &#125; &#125;)&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 通过上面的优化，前端代码确实简化了不少。但是页面依旧是不怎么好看，那么接下来我们学习 Element，它可以美化页面。 2，Element Element：是饿了么公司前端开发团队提供的一套基于 Vue 的网站组件库，用于快速构建网页。 Element 提供了很多组件（组成网页的部件）供我们使用。例如 超链接、按钮、图片、表格等等~ 如下图左边的是我们编写页面看到的按钮，上图右边的是 Element 提供的页面效果，效果一目了然。 我们学习 Element 其实就是学习怎么从官网拷贝组件到我们自己的页面并进行修改，官网网址是 1https://element.eleme.cn/#/zh-CN 进入官网能看到如下页面 接下来直接点击 组件 ，页面如下 2.1 快速入门 将资源 04-资料\\02-element 下的 element-ui 文件夹直接拷贝到项目的 webapp 下。目录结构如下 创建页面，并在页面引入Element 的css、js文件 和 Vue.js 123&lt;script src=&quot;vue.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;element-ui/lib/index.js&quot;&gt;&lt;/script&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;element-ui/lib/theme-chalk/index.css&quot;&gt; .创建Vue核心对象 Element 是基于 Vue 的，所以使用Element时必须要创建 Vue 对象 12345&lt;script&gt; new Vue(&#123; el:&quot;#app&quot; &#125;)&lt;/script&gt; 官网复制Element组件代码 在左菜单栏找到 Button 按钮 ，然后找到自己喜欢的按钮样式，点击 显示代码 ，在下面就会展示出对应的代码，将这些代码拷贝到我们自己的页面即可。 整体页面代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;app&quot;&gt; &lt;el-row&gt; &lt;el-button&gt;默认按钮&lt;/el-button&gt; &lt;el-button type=&quot;primary&quot;&gt;主要按钮&lt;/el-button&gt; &lt;el-button type=&quot;success&quot;&gt;成功按钮&lt;/el-button&gt; &lt;el-button type=&quot;info&quot;&gt;信息按钮&lt;/el-button&gt; &lt;el-button type=&quot;warning&quot;&gt;警告按钮&lt;/el-button&gt; &lt;el-button type=&quot;danger&quot;&gt;删除&lt;/el-button&gt; &lt;/el-row&gt; &lt;el-row&gt; &lt;el-button plain&gt;朴素按钮&lt;/el-button&gt; &lt;el-button type=&quot;primary&quot; plain&gt;主要按钮&lt;/el-button&gt; &lt;el-button type=&quot;success&quot; plain&gt;成功按钮&lt;/el-button&gt; &lt;el-button type=&quot;info&quot; plain&gt;信息按钮&lt;/el-button&gt; &lt;el-button type=&quot;warning&quot; plain&gt;警告按钮&lt;/el-button&gt; &lt;el-button type=&quot;danger&quot; plain&gt;危险按钮&lt;/el-button&gt; &lt;/el-row&gt; &lt;el-row&gt; &lt;el-button round&gt;圆角按钮&lt;/el-button&gt; &lt;el-button type=&quot;primary&quot; round&gt;主要按钮&lt;/el-button&gt; &lt;el-button type=&quot;success&quot; round&gt;成功按钮&lt;/el-button&gt; &lt;el-button type=&quot;info&quot; round&gt;信息按钮&lt;/el-button&gt; &lt;el-button type=&quot;warning&quot; round&gt;警告按钮&lt;/el-button&gt; &lt;el-button type=&quot;danger&quot; round&gt;危险按钮&lt;/el-button&gt; &lt;/el-row&gt; &lt;el-row&gt; &lt;el-button icon=&quot;el-icon-search&quot; circle&gt;&lt;/el-button&gt; &lt;el-button type=&quot;primary&quot; icon=&quot;el-icon-edit&quot; circle&gt;&lt;/el-button&gt; &lt;el-button type=&quot;success&quot; icon=&quot;el-icon-check&quot; circle&gt;&lt;/el-button&gt; &lt;el-button type=&quot;info&quot; icon=&quot;el-icon-message&quot; circle&gt;&lt;/el-button&gt; &lt;el-button type=&quot;warning&quot; icon=&quot;el-icon-star-off&quot; circle&gt;&lt;/el-button&gt; &lt;el-button type=&quot;danger&quot; icon=&quot;el-icon-delete&quot; circle&gt;&lt;/el-button&gt; &lt;/el-row&gt;&lt;/div&gt;&lt;script src=&quot;js/vue.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;element-ui/lib/index.js&quot;&gt;&lt;/script&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;element-ui/lib/theme-chalk/index.css&quot;&gt;&lt;script&gt; new Vue(&#123; el:&quot;#app&quot; &#125;)&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 2.2 Element 布局 Element 提供了两种布局方式，分别是： Layout 布局 Container 布局容器 2.2.1 Layout 局部 通过基础的 24 分栏，迅速简便地创建布局。也就是默认将一行分为 24 栏，根据页面要求给每一列设置所占的栏数。 在左菜单栏找到 Layout 布局 ，然后找到自己喜欢的按钮样式，点击 显示代码 ，在下面就会展示出对应的代码，显示出的代码中有样式，有html标签。将样式拷贝我们自己页面的 head 标签内，将html标签拷贝到 &lt;div id=&quot;app&quot;&gt;&lt;/div&gt; 标签内。 整体页面代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;style&gt; .el-row &#123; margin-bottom: 20px; &#125; .el-col &#123; border-radius: 4px; &#125; .bg-purple-dark &#123; background: #99a9bf; &#125; .bg-purple &#123; background: #d3dce6; &#125; .bg-purple-light &#123; background: #e5e9f2; &#125; .grid-content &#123; border-radius: 4px; min-height: 36px; &#125; .row-bg &#123; padding: 10px 0; background-color: #f9fafc; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;app&quot;&gt; &lt;el-row&gt; &lt;el-col :span=&quot;24&quot;&gt;&lt;div class=&quot;grid-content bg-purple-dark&quot;&gt;&lt;/div&gt;&lt;/el-col&gt; &lt;/el-row&gt; &lt;el-row&gt; &lt;el-col :span=&quot;12&quot;&gt;&lt;div class=&quot;grid-content bg-purple&quot;&gt;&lt;/div&gt;&lt;/el-col&gt; &lt;el-col :span=&quot;12&quot;&gt;&lt;div class=&quot;grid-content bg-purple-light&quot;&gt;&lt;/div&gt;&lt;/el-col&gt; &lt;/el-row&gt; &lt;el-row&gt; &lt;el-col :span=&quot;8&quot;&gt;&lt;div class=&quot;grid-content bg-purple&quot;&gt;&lt;/div&gt;&lt;/el-col&gt; &lt;el-col :span=&quot;8&quot;&gt;&lt;div class=&quot;grid-content bg-purple-light&quot;&gt;&lt;/div&gt;&lt;/el-col&gt; &lt;el-col :span=&quot;8&quot;&gt;&lt;div class=&quot;grid-content bg-purple&quot;&gt;&lt;/div&gt;&lt;/el-col&gt; &lt;/el-row&gt; &lt;el-row&gt; &lt;el-col :span=&quot;6&quot;&gt;&lt;div class=&quot;grid-content bg-purple&quot;&gt;&lt;/div&gt;&lt;/el-col&gt; &lt;el-col :span=&quot;6&quot;&gt;&lt;div class=&quot;grid-content bg-purple-light&quot;&gt;&lt;/div&gt;&lt;/el-col&gt; &lt;el-col :span=&quot;6&quot;&gt;&lt;div class=&quot;grid-content bg-purple&quot;&gt;&lt;/div&gt;&lt;/el-col&gt; &lt;el-col :span=&quot;6&quot;&gt;&lt;div class=&quot;grid-content bg-purple-light&quot;&gt;&lt;/div&gt;&lt;/el-col&gt; &lt;/el-row&gt; &lt;el-row&gt; &lt;el-col :span=&quot;4&quot;&gt;&lt;div class=&quot;grid-content bg-purple&quot;&gt;&lt;/div&gt;&lt;/el-col&gt; &lt;el-col :span=&quot;4&quot;&gt;&lt;div class=&quot;grid-content bg-purple-light&quot;&gt;&lt;/div&gt;&lt;/el-col&gt; &lt;el-col :span=&quot;4&quot;&gt;&lt;div class=&quot;grid-content bg-purple&quot;&gt;&lt;/div&gt;&lt;/el-col&gt; &lt;el-col :span=&quot;4&quot;&gt;&lt;div class=&quot;grid-content bg-purple-light&quot;&gt;&lt;/div&gt;&lt;/el-col&gt; &lt;el-col :span=&quot;4&quot;&gt;&lt;div class=&quot;grid-content bg-purple&quot;&gt;&lt;/div&gt;&lt;/el-col&gt; &lt;el-col :span=&quot;4&quot;&gt;&lt;div class=&quot;grid-content bg-purple-light&quot;&gt;&lt;/div&gt;&lt;/el-col&gt; &lt;/el-row&gt;&lt;/div&gt;&lt;script src=&quot;js/vue.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;element-ui/lib/index.js&quot;&gt;&lt;/script&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;element-ui/lib/theme-chalk/index.css&quot;&gt;&lt;script&gt; new Vue(&#123; el:&quot;#app&quot; &#125;)&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 现在需要添加一行，要求该行显示8个格子，通过计算每个格子占 3 栏，具体的html 代码如下 12345678910111213&lt;!--添加一行，8个格子 24/8 = 3--&gt;&lt;el-row&gt; &lt;el-col :span=&quot;3&quot;&gt;&lt;div class=&quot;grid-content bg-purple&quot;&gt;&lt;/div&gt;&lt;/el-col&gt; &lt;el-col :span=&quot;3&quot;&gt;&lt;div class=&quot;grid-content bg-purple-light&quot;&gt;&lt;/div&gt;&lt;/el-col&gt; &lt;el-col :span=&quot;3&quot;&gt;&lt;div class=&quot;grid-content bg-purple&quot;&gt;&lt;/div&gt;&lt;/el-col&gt; &lt;el-col :span=&quot;3&quot;&gt;&lt;div class=&quot;grid-content bg-purple-light&quot;&gt;&lt;/div&gt;&lt;/el-col&gt; &lt;el-col :span=&quot;3&quot;&gt;&lt;div class=&quot;grid-content bg-purple&quot;&gt;&lt;/div&gt;&lt;/el-col&gt; &lt;el-col :span=&quot;3&quot;&gt;&lt;div class=&quot;grid-content bg-purple-light&quot;&gt;&lt;/div&gt;&lt;/el-col&gt; &lt;el-col :span=&quot;3&quot;&gt;&lt;div class=&quot;grid-content bg-purple&quot;&gt;&lt;/div&gt;&lt;/el-col&gt; &lt;el-col :span=&quot;3&quot;&gt;&lt;div class=&quot;grid-content bg-purple-light&quot;&gt;&lt;/div&gt;&lt;/el-col&gt;&lt;/el-row&gt; 2.2.2 Container 布局容器 用于布局的容器组件，方便快速搭建页面的基本结构。如下图就是布局容器效果。 如下图是官网提供的 Container 布局容器实例： 该效果代码中包含了样式、页面标签、模型数据。将里面的样式 &lt;style&gt; 拷贝到我们自己页面的 head 标签中；将html标签拷贝到 &lt;div id=&quot;app&quot;&gt;&lt;/div&gt; 标签中，再将数据模型拷贝到 vue 对象的 data() 中。 整体页面代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;style&gt; .el-header &#123; background-color: #B3C0D1; color: #333; line-height: 60px; &#125; .el-aside &#123; color: #333; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;app&quot;&gt; &lt;el-container style=&quot;height: 500px; border: 1px solid #eee&quot;&gt; &lt;el-aside width=&quot;200px&quot; style=&quot;background-color: rgb(238, 241, 246)&quot;&gt; &lt;el-menu :default-openeds=&quot;[&#x27;1&#x27;, &#x27;3&#x27;]&quot;&gt; &lt;el-submenu index=&quot;1&quot;&gt; &lt;template slot=&quot;title&quot;&gt;&lt;i class=&quot;el-icon-message&quot;&gt;&lt;/i&gt;导航一&lt;/template&gt; &lt;el-menu-item-group&gt; &lt;template slot=&quot;title&quot;&gt;分组一&lt;/template&gt; &lt;el-menu-item index=&quot;1-1&quot;&gt;选项1&lt;/el-menu-item&gt; &lt;el-menu-item index=&quot;1-2&quot;&gt;选项2&lt;/el-menu-item&gt; &lt;/el-menu-item-group&gt; &lt;el-menu-item-group title=&quot;分组2&quot;&gt; &lt;el-menu-item index=&quot;1-3&quot;&gt;选项3&lt;/el-menu-item&gt; &lt;/el-menu-item-group&gt; &lt;el-submenu index=&quot;1-4&quot;&gt; &lt;template slot=&quot;title&quot;&gt;选项4&lt;/template&gt; &lt;el-menu-item index=&quot;1-4-1&quot;&gt;选项4-1&lt;/el-menu-item&gt; &lt;/el-submenu&gt; &lt;/el-submenu&gt; &lt;el-submenu index=&quot;2&quot;&gt; &lt;template slot=&quot;title&quot;&gt;&lt;i class=&quot;el-icon-menu&quot;&gt;&lt;/i&gt;导航二&lt;/template&gt; &lt;el-submenu index=&quot;2-1&quot;&gt; &lt;template slot=&quot;title&quot;&gt;选项1&lt;/template&gt; &lt;el-menu-item index=&quot;2-1-1&quot;&gt;选项1-1&lt;/el-menu-item&gt; &lt;/el-submenu&gt; &lt;/el-submenu&gt; &lt;el-submenu index=&quot;3&quot;&gt; &lt;template slot=&quot;title&quot;&gt;&lt;i class=&quot;el-icon-setting&quot;&gt;&lt;/i&gt;导航三&lt;/template&gt; &lt;el-menu-item-group&gt; &lt;template slot=&quot;title&quot;&gt;分组一&lt;/template&gt; &lt;el-menu-item index=&quot;3-1&quot;&gt;选项1&lt;/el-menu-item&gt; &lt;el-menu-item index=&quot;3-2&quot;&gt;选项2&lt;/el-menu-item&gt; &lt;/el-menu-item-group&gt; &lt;el-menu-item-group title=&quot;分组2&quot;&gt; &lt;el-menu-item index=&quot;3-3&quot;&gt;选项3&lt;/el-menu-item&gt; &lt;/el-menu-item-group&gt; &lt;el-submenu index=&quot;3-4&quot;&gt; &lt;template slot=&quot;title&quot;&gt;选项4&lt;/template&gt; &lt;el-menu-item index=&quot;3-4-1&quot;&gt;选项4-1&lt;/el-menu-item&gt; &lt;/el-submenu&gt; &lt;/el-submenu&gt; &lt;/el-menu&gt; &lt;/el-aside&gt; &lt;el-container&gt; &lt;el-header style=&quot;text-align: right; font-size: 12px&quot;&gt; &lt;el-dropdown&gt; &lt;i class=&quot;el-icon-setting&quot; style=&quot;margin-right: 15px&quot;&gt;&lt;/i&gt; &lt;el-dropdown-menu slot=&quot;dropdown&quot;&gt; &lt;el-dropdown-item&gt;查看&lt;/el-dropdown-item&gt; &lt;el-dropdown-item&gt;新增&lt;/el-dropdown-item&gt; &lt;el-dropdown-item&gt;删除&lt;/el-dropdown-item&gt; &lt;/el-dropdown-menu&gt; &lt;/el-dropdown&gt; &lt;span&gt;王小虎&lt;/span&gt; &lt;/el-header&gt; &lt;el-main&gt; &lt;el-table :data=&quot;tableData&quot;&gt; &lt;el-table-column prop=&quot;date&quot; label=&quot;日期&quot; width=&quot;140&quot;&gt; &lt;/el-table-column&gt; &lt;el-table-column prop=&quot;name&quot; label=&quot;姓名&quot; width=&quot;120&quot;&gt; &lt;/el-table-column&gt; &lt;el-table-column prop=&quot;address&quot; label=&quot;地址&quot;&gt; &lt;/el-table-column&gt; &lt;/el-table&gt; &lt;/el-main&gt; &lt;/el-container&gt; &lt;/el-container&gt;&lt;/div&gt;&lt;script src=&quot;js/vue.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;element-ui/lib/index.js&quot;&gt;&lt;/script&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;element-ui/lib/theme-chalk/index.css&quot;&gt;&lt;script&gt; new Vue(&#123; el:&quot;#app&quot;, data() &#123; const item = &#123; date: &#x27;2016-05-02&#x27;, name: &#x27;王小虎&#x27;, address: &#x27;上海市普陀区金沙江路 1518 弄&#x27; &#125;; return &#123; tableData: Array(20).fill(item) &#125; &#125; &#125;)&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 2.3 案例 其他的组件我们通过完成一个页面来学习。 我们要完成如下页面效果 要完成该页面，我们需要先对这个页面进行分析，看页面由哪儿几部分组成，然后到官网进行拷贝并修改。页面总共有如下组成部分 还有一个是当我们点击 新增 按钮，会在页面正中间弹出一个对话框，如下 2.3.1 准备基本页面 12345678910111213141516171819202122&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;app&quot;&gt; &lt;/div&gt;&lt;script src=&quot;js/vue.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;element-ui/lib/index.js&quot;&gt;&lt;/script&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;element-ui/lib/theme-chalk/index.css&quot;&gt;&lt;script&gt; new Vue(&#123; el: &quot;#app&quot; &#125;)&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 2.3.2 完成表格展示 使用 Element 整体的思路就是 拷贝 + 修改。 2.3.2.1 拷贝 在左菜单栏找到 Table 表格并点击，右边主体就会定位到表格这一块，找到我们需要的表格效果（如上图），点击 显示代码 就可以看到这个表格的代码了。 将html标签拷贝到 &lt;div id=&quot;app&quot;&gt;&lt;/div&gt; 中，如下： 将css样式拷贝到我们页面的 head 标签中，如下 将方法和模型数据拷贝到 Vue 对象指定的位置 拷贝完成后通过浏览器打开可以看到表格的效果 表格效果出来了，但是显示的表头和数据并不是我们想要的，所以接下来就需要对页面代码进行修改了。 2.3.2.2 修改 修改表头和数据 下面是对表格代码进行分析的图解。根据下图说明修改自己的列数和列名 修改完页面后，还需要对绑定的模型数据进行修改，下图是对模型数据进行分析的图解 给表格添加操作列 从之前的表格拷贝一列出来并对其进行修改。按钮是从官网的 Button 按钮 组件中拷贝并修改的 给表格添加复选框列和标号列 给表格添加复选框和标号列，效果如下 此效果也是从 Element 官网进行拷贝，先找到对应的表格效果，然后将其对应代码拷贝到我们的代码中，如下是复选框列官网效果图和代码 这里需要注意在 &lt;el-table&gt; 标签上有一个事件 @selection-change=&quot;handleSelectionChange&quot; ，这里绑定的函数也需要从官网拷贝到我们自己的页面代码中，函数代码如下： 从该函数中又发现还需要一个模型数据 multipleSelection ，所以还需要定义出该模型数据 标号列也用同样的方式进行拷贝并修改。 2.3.3 完成搜索表单展示 在 Element 官网找到横排的表单效果，然后拷贝代码并进行修改 点击上面的 显示代码 后，就会展示出对应的代码，下面是对这部分代码进行分析的图解 然后根据我们要的效果修改代码。 2.3.4 完成批量删除和新增按钮展示 从 Element 官网找具有着色效果的按钮，并将代码拷贝到我们自己的页面上 2.3.5 完成对话框展示 在 Element 官网找对话框，如下： 下面对官网提供的代码进行分析 上图分析出来的模型数据需要在 Vue 对象中进行定义。 2.3.6 完成分页条展示 在 Element 官网找到 Pagination 分页 ，在页面主体部分找到我们需要的效果，如下 点击 显示代码 ，找到 完整功能 对应的代码，接下来对该代码进行分析 上面代码属性说明： page-size ：每页显示的条目数 page-sizes ： 每页显示个数选择器的选项设置。 :page-sizes=&quot;[100,200,300,400]&quot; 对应的页面效果如下： currentPage ：当前页码。我们点击那个页码，此属性值就是几。 total ：总记录数。用来设置总的数据条目数，该属性设置后， Element 会自动计算出需分多少页并给我们展示对应的页码。 事件说明： size-change ：pageSize 改变时会触发。也就是当我们改变了每页显示的条目数后，该事件会触发。 current-change ：currentPage 改变时会触发。也就是当我们点击了其他的页码后，该事件会触发。 2.3.7 完整页面代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;style&gt; .el-table .warning-row &#123; background: oldlace; &#125; .el-table .success-row &#123; background: #f0f9eb; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;app&quot;&gt; &lt;!--搜索表单--&gt; &lt;el-form :inline=&quot;true&quot; :model=&quot;brand&quot; class=&quot;demo-form-inline&quot;&gt; &lt;el-form-item label=&quot;当前状态&quot;&gt; &lt;el-select v-model=&quot;brand.status&quot; placeholder=&quot;当前状态&quot;&gt; &lt;el-option label=&quot;启用&quot; value=&quot;1&quot;&gt;&lt;/el-option&gt; &lt;el-option label=&quot;禁用&quot; value=&quot;0&quot;&gt;&lt;/el-option&gt; &lt;/el-select&gt; &lt;/el-form-item&gt; &lt;el-form-item label=&quot;企业名称&quot;&gt; &lt;el-input v-model=&quot;brand.companyName&quot; placeholder=&quot;企业名称&quot;&gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;el-form-item label=&quot;品牌名称&quot;&gt; &lt;el-input v-model=&quot;brand.brandName&quot; placeholder=&quot;品牌名称&quot;&gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;el-form-item&gt; &lt;el-button type=&quot;primary&quot; @click=&quot;onSubmit&quot;&gt;查询&lt;/el-button&gt; &lt;/el-form-item&gt; &lt;/el-form&gt; &lt;!--按钮--&gt; &lt;el-row&gt; &lt;el-button type=&quot;danger&quot; plain&gt;批量删除&lt;/el-button&gt; &lt;el-button type=&quot;primary&quot; plain @click=&quot;dialogVisible = true&quot;&gt;新增&lt;/el-button&gt; &lt;/el-row&gt; &lt;!--添加数据对话框表单--&gt; &lt;el-dialog title=&quot;编辑品牌&quot; :visible.sync=&quot;dialogVisible&quot; width=&quot;30%&quot;&gt; &lt;el-form ref=&quot;form&quot; :model=&quot;brand&quot; label-width=&quot;80px&quot;&gt; &lt;el-form-item label=&quot;品牌名称&quot;&gt; &lt;el-input v-model=&quot;brand.brandName&quot;&gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;el-form-item label=&quot;企业名称&quot;&gt; &lt;el-input v-model=&quot;brand.companyName&quot;&gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;el-form-item label=&quot;排序&quot;&gt; &lt;el-input v-model=&quot;brand.ordered&quot;&gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;el-form-item label=&quot;备注&quot;&gt; &lt;el-input type=&quot;textarea&quot; v-model=&quot;brand.description&quot;&gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;el-form-item label=&quot;状态&quot;&gt; &lt;el-switch v-model=&quot;brand.status&quot; active-value=&quot;1&quot; inactive-value=&quot;0&quot; &gt;&lt;/el-switch&gt; &lt;/el-form-item&gt; &lt;el-form-item&gt; &lt;el-button type=&quot;primary&quot; @click=&quot;addBrand&quot;&gt;提交&lt;/el-button&gt; &lt;el-button @click=&quot;dialogVisible = false&quot;&gt;取消&lt;/el-button&gt; &lt;/el-form-item&gt; &lt;/el-form&gt; &lt;/el-dialog&gt; &lt;!--表格--&gt; &lt;template&gt; &lt;el-table :data=&quot;tableData&quot; style=&quot;width: 100%&quot; :row-class-name=&quot;tableRowClassName&quot; @selection-change=&quot;handleSelectionChange&quot;&gt; &lt;el-table-column type=&quot;selection&quot; width=&quot;55&quot;&gt; &lt;/el-table-column&gt; &lt;el-table-column type=&quot;index&quot; width=&quot;50&quot;&gt; &lt;/el-table-column&gt; &lt;el-table-column prop=&quot;brandName&quot; label=&quot;品牌名称&quot; align=&quot;center&quot;&gt; &lt;/el-table-column&gt; &lt;el-table-column prop=&quot;companyName&quot; label=&quot;企业名称&quot; align=&quot;center&quot;&gt; &lt;/el-table-column&gt; &lt;el-table-column prop=&quot;ordered&quot; align=&quot;center&quot; label=&quot;排序&quot;&gt; &lt;/el-table-column&gt; &lt;el-table-column prop=&quot;status&quot; align=&quot;center&quot; label=&quot;当前状态&quot;&gt; &lt;/el-table-column&gt; &lt;el-table-column align=&quot;center&quot; label=&quot;操作&quot;&gt; &lt;el-row&gt; &lt;el-button type=&quot;primary&quot;&gt;修改&lt;/el-button&gt; &lt;el-button type=&quot;danger&quot;&gt;删除&lt;/el-button&gt; &lt;/el-row&gt; &lt;/el-table-column&gt; &lt;/el-table&gt; &lt;/template&gt; &lt;!--分页工具条--&gt; &lt;el-pagination @size-change=&quot;handleSizeChange&quot; @current-change=&quot;handleCurrentChange&quot; :current-page=&quot;currentPage&quot; :page-sizes=&quot;[5, 10, 15, 20]&quot; :page-size=&quot;5&quot; layout=&quot;total, sizes, prev, pager, next, jumper&quot; :total=&quot;400&quot;&gt; &lt;/el-pagination&gt;&lt;/div&gt;&lt;script src=&quot;js/vue.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;element-ui/lib/index.js&quot;&gt;&lt;/script&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;element-ui/lib/theme-chalk/index.css&quot;&gt;&lt;script&gt; new Vue(&#123; el: &quot;#app&quot;, methods: &#123; tableRowClassName(&#123;row, rowIndex&#125;) &#123; if (rowIndex === 1) &#123; return &#x27;warning-row&#x27;; &#125; else if (rowIndex === 3) &#123; return &#x27;success-row&#x27;; &#125; return &#x27;&#x27;; &#125;, // 复选框选中后执行的方法 handleSelectionChange(val) &#123; this.multipleSelection = val; console.log(this.multipleSelection) &#125;, // 查询方法 onSubmit() &#123; console.log(this.brand); &#125;, // 添加数据 addBrand()&#123; console.log(this.brand); &#125;, //分页 handleSizeChange(val) &#123; console.log(`每页 $&#123;val&#125; 条`); &#125;, handleCurrentChange(val) &#123; console.log(`当前页: $&#123;val&#125;`); &#125; &#125;, data() &#123; return &#123; // 当前页码 currentPage: 4, // 添加数据对话框是否展示的标记 dialogVisible: false, // 品牌模型数据 brand: &#123; status: &#x27;&#x27;, brandName: &#x27;&#x27;, companyName: &#x27;&#x27;, id:&quot;&quot;, ordered:&quot;&quot;, description:&quot;&quot; &#125;, // 复选框选中数据集合 multipleSelection: [], // 表格数据 tableData: [&#123; brandName: &#x27;华为&#x27;, companyName: &#x27;华为科技有限公司&#x27;, ordered: &#x27;100&#x27;, status: &quot;1&quot; &#125;, &#123; brandName: &#x27;华为&#x27;, companyName: &#x27;华为科技有限公司&#x27;, ordered: &#x27;100&#x27;, status: &quot;1&quot; &#125;, &#123; brandName: &#x27;华为&#x27;, companyName: &#x27;华为科技有限公司&#x27;, ordered: &#x27;100&#x27;, status: &quot;1&quot; &#125;, &#123; brandName: &#x27;华为&#x27;, companyName: &#x27;华为科技有限公司&#x27;, ordered: &#x27;100&#x27;, status: &quot;1&quot; &#125;] &#125; &#125; &#125;)&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 3，综合案例 3.1 功能介绍 以上是我们在综合案例要实现的功能。对数据的除了对数据的增删改查功能外，还有一些复杂的功能，如 批量删除、分页查询、条件查询 等功能 批量删除 功能：每条数据前都有复选框，当我选中多条数据并点击 批量删除 按钮后，会发送请求到后端并删除数据库中指定的多条数据。 分页查询 功能：当数据库中有很多数据时，我们不可能将所有的数据展示在一页里，这个时候就需要分页展示数据。 条件查询 功能：数据库量大的时候，我们就需要精确的查询一些想看到的数据，这个时候就需要通过条件查询。 这里的 修改品牌 和 删除品牌 功能在课程上不做讲解，留作同学来下的练习。 3.2 环境准备 环境准备我们主要完成以下两件事即可 将资料的 brand-case 模块导入到 idea中 执行资料中提供的 tb_brand.sql脚本 3.2.1 工程准备 将 04-资料\\01-初始工程 中的 brand-case 工程导入到我们自己的 idea 中。工程结构如下： 3.2.2 创建表 下面是创建表的语句 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768-- 删除tb_brand表drop table if exists tb_brand;-- 创建tb_brand表create table tb_brand ( -- id 主键 id int primary key auto_increment, -- 品牌名称 brand_name varchar(20), -- 企业名称 company_name varchar(20), -- 排序字段 ordered int, -- 描述信息 description varchar(100), -- 状态：0：禁用 1：启用 status int);-- 添加数据insert into tb_brand (brand_name, company_name, ordered, description, status)values (&#x27;华为&#x27;, &#x27;华为技术有限公司&#x27;, 100, &#x27;万物互联&#x27;, 1), (&#x27;小米&#x27;, &#x27;小米科技有限公司&#x27;, 50, &#x27;are you ok&#x27;, 1), (&#x27;格力&#x27;, &#x27;格力电器股份有限公司&#x27;, 30, &#x27;让世界爱上中国造&#x27;, 1), (&#x27;阿里巴巴&#x27;, &#x27;阿里巴巴集团控股有限公司&#x27;, 10, &#x27;买买买&#x27;, 1), (&#x27;腾讯&#x27;, &#x27;腾讯计算机系统有限公司&#x27;, 50, &#x27;玩玩玩&#x27;, 0), (&#x27;百度&#x27;, &#x27;百度在线网络技术公司&#x27;, 5, &#x27;搜搜搜&#x27;, 0), (&#x27;京东&#x27;, &#x27;北京京东世纪贸易有限公司&#x27;, 40, &#x27;就是快&#x27;, 1), (&#x27;小米&#x27;, &#x27;小米科技有限公司&#x27;, 50, &#x27;are you ok&#x27;, 1), (&#x27;三只松鼠&#x27;, &#x27;三只松鼠股份有限公司&#x27;, 5, &#x27;好吃不上火&#x27;, 0), (&#x27;华为&#x27;, &#x27;华为技术有限公司&#x27;, 100, &#x27;万物互联&#x27;, 1), (&#x27;小米&#x27;, &#x27;小米科技有限公司&#x27;, 50, &#x27;are you ok&#x27;, 1), (&#x27;格力&#x27;, &#x27;格力电器股份有限公司&#x27;, 30, &#x27;让世界爱上中国造&#x27;, 1), (&#x27;阿里巴巴&#x27;, &#x27;阿里巴巴集团控股有限公司&#x27;, 10, &#x27;买买买&#x27;, 1), (&#x27;腾讯&#x27;, &#x27;腾讯计算机系统有限公司&#x27;, 50, &#x27;玩玩玩&#x27;, 0), (&#x27;百度&#x27;, &#x27;百度在线网络技术公司&#x27;, 5, &#x27;搜搜搜&#x27;, 0), (&#x27;京东&#x27;, &#x27;北京京东世纪贸易有限公司&#x27;, 40, &#x27;就是快&#x27;, 1), (&#x27;华为&#x27;, &#x27;华为技术有限公司&#x27;, 100, &#x27;万物互联&#x27;, 1), (&#x27;小米&#x27;, &#x27;小米科技有限公司&#x27;, 50, &#x27;are you ok&#x27;, 1), (&#x27;格力&#x27;, &#x27;格力电器股份有限公司&#x27;, 30, &#x27;让世界爱上中国造&#x27;, 1), (&#x27;阿里巴巴&#x27;, &#x27;阿里巴巴集团控股有限公司&#x27;, 10, &#x27;买买买&#x27;, 1), (&#x27;腾讯&#x27;, &#x27;腾讯计算机系统有限公司&#x27;, 50, &#x27;玩玩玩&#x27;, 0), (&#x27;百度&#x27;, &#x27;百度在线网络技术公司&#x27;, 5, &#x27;搜搜搜&#x27;, 0), (&#x27;京东&#x27;, &#x27;北京京东世纪贸易有限公司&#x27;, 40, &#x27;就是快&#x27;, 1), (&#x27;小米&#x27;, &#x27;小米科技有限公司&#x27;, 50, &#x27;are you ok&#x27;, 1), (&#x27;三只松鼠&#x27;, &#x27;三只松鼠股份有限公司&#x27;, 5, &#x27;好吃不上火&#x27;, 0), (&#x27;华为&#x27;, &#x27;华为技术有限公司&#x27;, 100, &#x27;万物互联&#x27;, 1), (&#x27;小米&#x27;, &#x27;小米科技有限公司&#x27;, 50, &#x27;are you ok&#x27;, 1), (&#x27;格力&#x27;, &#x27;格力电器股份有限公司&#x27;, 30, &#x27;让世界爱上中国造&#x27;, 1), (&#x27;阿里巴巴&#x27;, &#x27;阿里巴巴集团控股有限公司&#x27;, 10, &#x27;买买买&#x27;, 1), (&#x27;腾讯&#x27;, &#x27;腾讯计算机系统有限公司&#x27;, 50, &#x27;玩玩玩&#x27;, 0), (&#x27;百度&#x27;, &#x27;百度在线网络技术公司&#x27;, 5, &#x27;搜搜搜&#x27;, 0), (&#x27;京东&#x27;, &#x27;北京京东世纪贸易有限公司&#x27;, 40, &#x27;就是快&#x27;, 1), (&#x27;华为&#x27;, &#x27;华为技术有限公司&#x27;, 100, &#x27;万物互联&#x27;, 1), (&#x27;小米&#x27;, &#x27;小米科技有限公司&#x27;, 50, &#x27;are you ok&#x27;, 1), (&#x27;格力&#x27;, &#x27;格力电器股份有限公司&#x27;, 30, &#x27;让世界爱上中国造&#x27;, 1), (&#x27;阿里巴巴&#x27;, &#x27;阿里巴巴集团控股有限公司&#x27;, 10, &#x27;买买买&#x27;, 1), (&#x27;腾讯&#x27;, &#x27;腾讯计算机系统有限公司&#x27;, 50, &#x27;玩玩玩&#x27;, 0), (&#x27;百度&#x27;, &#x27;百度在线网络技术公司&#x27;, 5, &#x27;搜搜搜&#x27;, 0), (&#x27;京东&#x27;, &#x27;北京京东世纪贸易有限公司&#x27;, 40, &#x27;就是快&#x27;, 1), (&#x27;小米&#x27;, &#x27;小米科技有限公司&#x27;, 50, &#x27;are you ok&#x27;, 1), (&#x27;三只松鼠&#x27;, &#x27;三只松鼠股份有限公司&#x27;, 5, &#x27;好吃不上火&#x27;, 0), (&#x27;华为&#x27;, &#x27;华为技术有限公司&#x27;, 100, &#x27;万物互联&#x27;, 1), (&#x27;小米&#x27;, &#x27;小米科技有限公司&#x27;, 50, &#x27;are you ok&#x27;, 1), (&#x27;格力&#x27;, &#x27;格力电器股份有限公司&#x27;, 30, &#x27;让世界爱上中国造&#x27;, 1), (&#x27;阿里巴巴&#x27;, &#x27;阿里巴巴集团控股有限公司&#x27;, 10, &#x27;买买买&#x27;, 1), (&#x27;腾讯&#x27;, &#x27;腾讯计算机系统有限公司&#x27;, 50, &#x27;玩玩玩&#x27;, 0), (&#x27;百度&#x27;, &#x27;百度在线网络技术公司&#x27;, 5, &#x27;搜搜搜&#x27;, 0), (&#x27;京东&#x27;, &#x27;北京京东世纪贸易有限公司&#x27;, 40, &#x27;就是快&#x27;, 1); 3.3 查询所有功能 如上图所示是查询所有品牌数据在页面展示的效果。要实现这个功能，要先搞明白如下问题： 什么时候发送异步请求？ 页面加载完毕后就需要在页面上看到所有的品牌数据。所以在 mounted() 这个构造函数中写发送异步请求的代码。 请求需要携带参数吗？ 查询所有功能不需要携带什么参数。 响应的数据格式是什么样？ 后端是需要将 List&lt;Brand&gt; 对象转换为 JSON 格式的数据并响应回给浏览器。响应数据格式如下： 整体流程如下 我们先实现后端程序，然后再实现前端程序。 3.3.1 后端实现 3.3.1.1 dao方法实现 在 com.itheima.mapper.BrandMapper 接口中定义抽象方法，并使用 @Select 注解编写 sql 语句 123456/** * 查询所有 * @return */@Select(&quot;select * from tb_brand&quot;)List&lt;Brand&gt; selectAll(); 由于表中有些字段名和实体类中的属性名没有对应，所以需要在 com/itheima/mapper/BrandMapper.xml 映射配置文件中定义结果映射 ，使用resultMap 标签。映射配置文件内容如下： 1234567891011&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.itheima.mapper.BrandMapper&quot;&gt; &lt;resultMap id=&quot;brandResultMap&quot; type=&quot;brand&quot;&gt; &lt;result property=&quot;brandName&quot; column=&quot;brand_name&quot; /&gt; &lt;result property=&quot;companyName&quot; column=&quot;company_name&quot; /&gt; &lt;/resultMap&gt;&lt;/mapper&gt; 定义完结果映射关系后，在接口 selectAll() 方法上引用该结构映射。使用 @ResultMap(&quot;brandResultMap&quot;) 注解 完整接口的 selectAll() 方法如下： 1234567/** * 查询所有 * @return */@Select(&quot;select * from tb_brand&quot;)@ResultMap(&quot;brandResultMap&quot;)List&lt;Brand&gt; selectAll(); 3.3.1.2 service方法实现 在 com.itheima.service 包下创建 BrandService 接口，在该接口中定义查询所有的抽象方法 12345678public interface BrandService &#123; /** * 查询所有 * @return */ List&lt;Brand&gt; selectAll();&#125; 并在 com.itheima.service 下再创建 impl 包；impl 表示是放 service 层接口的实现类的包。 在该包下创建名为 BrandServiceImpl 类 123456public class BrandServiceImpl implements BrandService &#123; @Override public List&lt;Brand&gt; selectAll() &#123; &#125;&#125; 此处为什么要给 service 定义接口呢？因为service定义了接口后，在 servlet 中就可以使用多态的形式创建Service实现类的对象，如下： 这里使用多态是因为方便我们后期解除 Servlet 和 service 的耦合。从上面的代码我们可以看到 SelectAllServlet 类和 BrandServiceImpl 类之间是耦合在一起的，如果后期 BrandService 有其它更好的实现类（例如叫 BrandServiceImpl），那就需要修改 SelectAllServlet 类中的代码。后面我们学习了 Spring 框架后就可以解除 SelectAllServlet 类和红色框括起来的代码耦合。而现在咱们还做不到解除耦合，在这里只需要理解为什么定义接口即可。 BrandServiceImpl 类代码如下： 1234567891011121314151617181920public class BrandServiceImpl implements BrandService &#123; //1. 创建SqlSessionFactory 工厂对象 SqlSessionFactory factory = SqlSessionFactoryUtils.getSqlSessionFactory(); @Override public List&lt;Brand&gt; selectAll() &#123; //2. 获取SqlSession对象 SqlSession sqlSession = factory.openSession(); //3. 获取BrandMapper BrandMapper mapper = sqlSession.getMapper(BrandMapper.class); //4. 调用方法 List&lt;Brand&gt; brands = mapper.selectAll(); //5. 释放资源 sqlSession.close(); return brands; &#125;&#125; 3.3.1.3 servlet实现 在 com.itheima.web.servlet 包下定义名为 SelectAllServlet 的查询所有的 servlet。该 servlet 逻辑如下： 调用service的 selectAll() 方法查询所有的品牌数据，并接口返回结果 将返回的结果转换为 json 数据 响应 json 数据 代码如下： 123456789101112131415161718192021@WebServlet(&quot;/selectAllServlet&quot;)public class SelectAllServlet extends HttpServlet &#123; private BrandService brandService = new BrandServiceImpl(); @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; //1. 调用service查询 List&lt;Brand&gt; brands = brandService.selectAll(); //2. 转为JSON String jsonString = JSON.toJSONString(brands); //3. 写数据 response.setContentType(&quot;text/json;charset=utf-8&quot;); //告知浏览器响应的数据是什么， 告知浏览器使用什么字符集进行解码 response.getWriter().write(jsonString); &#125; @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; this.doGet(request, response); &#125;&#125; 3.3.1.4 测试后端程序 在浏览器输入访问 servlet 的资源路径 http://localhost:8080/brand-case/selectAllServlet ，如果没有报错，并能看到如下信息表明后端程序没有问题 3.3.2 前端实现 前端需要在页面加载完毕后发送 ajax 请求，所以发送请求的逻辑应该放在 mounted() 钩子函数中。而响应回来的数据需要赋值给表格绑定的数据模型，从下图可以看出表格绑定的数据模型是 tableData 前端代码如下： 1234567891011mounted()&#123; //当页面加载完成后，发送异步请求，获取数据 var _this = this; axios(&#123; method:&quot;get&quot;, url:&quot;http://localhost:8080/brand-case/selectAllServlet&quot; &#125;).then(function (resp) &#123; _this.tableData = resp.data; &#125;)&#125; 3.4 添加功能 上图是添加数据的对话框，当点击 提交 按钮后就需要将数据提交到后端，并将数据保存到数据库中。下图是整体的流程： 页面发送请求时，需要将输入框输入的内容提交给后端程序，而这里是以 json 格式进行传递的。而具体的数据格式如下： 注意：由于是添加数据，所以上述json数据中id是没有值的。 3.4.1 后端实现 3.4.1.1 dao方法实现 在 BrandMapper 接口中定义 add() 添加方法，并使用 @Insert 注解编写sql语句 123456/** * 添加数据 * @param brand */@Insert(&quot;insert into tb_brand values(null,#&#123;brandName&#125;,#&#123;companyName&#125;,#&#123;ordered&#125;,#&#123;description&#125;,#&#123;status&#125;)&quot;)void add(Brand brand); 3.4.1.2 service方法实现 在 BrandService 接口中定义 add() 添加数据的业务逻辑方法 12345/** * 添加数据 * @param brand */void add(Brand brand); 在 BrandServiceImpl 类中重写 add() 方法，并进行业务逻辑实现 1234567891011121314@Overridepublic void add(Brand brand) &#123; //2. 获取SqlSession对象 SqlSession sqlSession = factory.openSession(); //3. 获取BrandMapper BrandMapper mapper = sqlSession.getMapper(BrandMapper.class); //4. 调用方法 mapper.add(brand); sqlSession.commit();//提交事务 //5. 释放资源 sqlSession.close();&#125; 注意：增删改操作一定要提交事务。 3.4.1.3 servlet实现 在 com.itheima.web.servlet 包写定义名为 AddServlet 的 Servlet。该 Servlet 的逻辑如下： 接收页面提交的数据。页面到时候提交的数据是 json 格式的数据，所以此处需要使用输入流读取数据 将接收到的数据转换为 Brand 对象 调用 service 的 add() 方法进行添加的业务逻辑处理 给浏览器响应添加成功的标识，这里直接给浏览器响应 success 字符串表示成功 servlet 代码实现如下： 123456789101112131415161718192021222324@WebServlet(&quot;/addServlet&quot;)public class AddServlet extends HttpServlet &#123; private BrandService brandService = new BrandServiceImpl(); @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; //1. 接收品牌数据 BufferedReader br = request.getReader(); String params = br.readLine();//json字符串 //转为Brand对象 Brand brand = JSON.parseObject(params, Brand.class); //2. 调用service添加 brandService.add(brand); //3. 响应成功的标识 response.getWriter().write(&quot;success&quot;); &#125; @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; this.doGet(request, response); &#125;&#125; 3.4.2 前端实现 上图左边是页面效果，里面的 提交 按钮可以通过上图右边看出绑定了一个 单击事件，而该事件绑定的是 addBrand 函数，所以添加数据功能的逻辑代码应该写在 addBrand() 函数中。在此方法中需要发送异步请求并将表单中输入的数据作为参数进行传递。如下 12345678910111213// 添加数据addBrand() &#123; var _this = this; // 发送ajax请求，添加数据 axios(&#123; method:&quot;post&quot;, url:&quot;http://localhost:8080/brand-case/addServlet&quot;, data:_this.brand &#125;).then(function (resp) &#123; //响应数据的处理逻辑 &#125;)&#125; 在 then 函数中的匿名函数是成功后的回调函数，而 resp.data 就可以获取到响应回来的数据，如果值是 success 表示数据添加成功。成功后我们需要做一下逻辑处理： 关闭新增对话框窗口 如下图所示是添加数据的对话框代码，从代码中可以看到此对话框绑定了 dialogVisible 数据模型，只需要将该数据模型的值设置为 false，就可以关闭新增对话框窗口了。 重新查询数据 数据添加成功与否，用户只要能在页面上查看到数据说明添加成功。而此处需要重新发送异步请求获取所有的品牌数据，而这段代码在 查询所有 功能中已经实现，所以我们可以将此功能代码进行抽取，抽取到一个 selectAll() 函数中 1234567891011// 查询所有数据selectAll()&#123; var _this = this; axios(&#123; method:&quot;get&quot;, url:&quot;http://localhost:8080/brand-case/selectAllServlet&quot; &#125;).then(function (resp) &#123; _this.tableData = resp.data; &#125;)&#125; 那么就需要将 mounted() 钩子函数中代码改进为 1234mounted()&#123; //当页面加载完成后，发送异步请求，获取数据 this.selectAll();&#125; 同时在新增响应的回调中调用 selectAll() 进行数据的重新查询。 弹出消息给用户提示添加成功 上图左边就是 elementUI 官网提供的成功提示代码，而上图右边是具体的效果。 注意：上面的this需要的是表示 VUE 对象的this。 综上所述，前端代码如下： 123456789101112131415161718192021222324// 添加数据addBrand() &#123; var _this = this; // 发送ajax请求，添加数据 axios(&#123; method:&quot;post&quot;, url:&quot;http://localhost:8080/brand-case/addServlet&quot;, data:_this.brand &#125;).then(function (resp) &#123; if(resp.data == &quot;success&quot;)&#123; //添加成功 //关闭窗口 _this.dialogVisible = false; // 重新查询数据 _this.selectAll(); // 弹出消息提示 _this.$message(&#123; message: &#x27;恭喜你，添加成功&#x27;, type: &#x27;success&#x27; &#125;); &#125; &#125;)&#125; 来源：it 黑马 JavaWeb 教程","categories":[{"name":"Java","slug":"Java","permalink":"http://littlewuuu.com/categories/Java/"}],"tags":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://littlewuuu.com/tags/JavaWeb/"}]},{"title":"JavaScript","slug":"黑马/8-JavaScript","date":"2022-08-21T22:00:00.000Z","updated":"2022-12-01T15:45:10.456Z","comments":true,"path":"2022/08/22/黑马/8-JavaScript/","link":"","permalink":"http://littlewuuu.com/2022/08/22/%E9%BB%91%E9%A9%AC/8-JavaScript/","excerpt":"","text":"JavaScript 今日目标 掌握 JavaScript 的基础语法 掌握 JavaScript 的常用对象（Array、String） 能根据需求灵活运用定时器及通过 js 代码进行页面跳转 能通过DOM 对象对标签进行常规操作 掌握常用的事件 能独立完成表单校验案例 1，JavaScript简介 JavaScript 是一门跨平台、面向对象的脚本语言，而Java语言也是跨平台的、面向对象的语言，只不过Java是编译语言，是需要编译成字节码文件才能运行的；JavaScript是脚本语言，不需要编译，由浏览器直接解析并执行。 JavaScript 是用来控制网页行为的，它能使网页可交互；那么它可以做什么呢？如改变页面内容、修改指定元素的属性值、对表单进行校验等，下面是这些功能的效果展示： 改变页面内容 当我点击上面左图的 点击我 按钮，按钮上面的文本就改为上面右图内容，这就是js 改变页面内容的功能。 修改指定元素的属性值 当我们点击上图的 开灯 按钮，效果就是上面右图效果；当我点击 关灯 按钮，效果就是上面左图效果。其他这个功能中有两张灯泡的图片（使用img标签进行展示），通过修改 img 标签的 src 属性值改变展示的图片来实现。 对表单进行校验 在上面左图的输入框输入用户名，如果输入的用户名是不满足规则的就展示右图(上) 的效果；如果输入的用户名是满足规则的就展示右图(下) 的效果。 JavaScript 和 Java 是完全不同的语言，不论是概念还是设计，只是名字比较像而已。但是基础语法类似，所以我们有java的学习经验，再学习JavaScript 语言就相对比较容易些。 JavaScript（简称：JS） 在 1995 年由 Brendan Eich 发明，并于 1997 年成为一部 ECMA 标准。ECMA 规定了一套标准 就叫 ECMAScript ，所有的客户端校验语言必须遵守这个标准，当然 JavaScript 也遵守了这个标准。ECMAScript 6 (简称ES6) 是最新的 JavaScript 版本（发布于 2015 年)，我们的课程就是基于最新的 ES6 进行讲解。 2，JavaScript引入方式 JavaScript 引入方式就是 HTML 和 JavaScript 的结合方式。JavaScript引入方式有两种： 内部脚本：将 JS代码定义在HTML页面中 外部脚本：将 JS代码定义在外部 JS文件中，然后引入到 HTML页面中 2.1 内部脚本 在 HTML 中，JavaScript 代码必须位于 &lt;script&gt; 与 &lt;/script&gt; 标签之间 代码如下： alert(数据) 是 JavaScript 的一个方法，作用是将参数数据以浏览器弹框的形式输出出来。 12345678910111213&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;script&gt; alert(&quot;hello js1&quot;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 效果如下： 从结果可以看到 js 代码已经执行了。 提示： 在 HTML 文档中可以在任意地方，放置任意数量的标签。如下图 1234567891011121314151617181920&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script&gt; alert(&quot;hello js1&quot;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;script&gt; alert(&quot;hello js1&quot;);&lt;/script&gt; &lt;/body&gt;&lt;/html&gt;&lt;script&gt; alert(&quot;hello js1&quot;);&lt;/script&gt; 一般把脚本置于 元素的底部，可改善显示速度 因为浏览器在加载页面的时候会从上往下进行加载并解析。 我们应该让用户看到页面内容，然后再展示动态的效果。 2.2 外部脚本 第一步：定义外部 js 文件。如定义名为 demo.js的文件 项目结构如下： demo.js 文件内容如下： 1alert(&quot;hello js&quot;); 第二步：在页面中引入外部的js文件 在页面使用 script 标签中使用 src 属性指定 js 文件的 URL 路径。 1234567891011&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;script src=&quot;../js/demo.js&quot;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 注意： 外部 js脚本不能包含 &lt;script&gt; 标签 在js文件中直接写 js 代码即可，不要在 js文件 中写 script 标签 &lt;script&gt; 标签不能自闭合 在页面中引入外部js文件时，不能写成 &lt;script src=&quot;../js/demo.js&quot; /&gt;。 要写在最后面 3，JavaScript基础语法 3.1 书写语法 区分大小写：与 Java 一样，变量名、函数名以及其他一切东西都是区分大小写的 每行结尾的分号可有可无 如果一行上写多个语句时，必须加分号用来区分多个语句。 注释 单行注释：// 注释内容 多行注释：/* 注释内容 */ 注意：JavaScript 没有文档注释 大括号表示代码块 下面语句大家肯定能看懂，和 java 一样 大括号表示代码块。 123if (count == 3) &#123; alert(count); &#125; 3.2 输出语句 js 可以通过以下方式进行内容的输出，只不过不同的语句输出到的位置不同 windows.alert() 写入警告框 document.write() 写入 html 输出 console.log 写入浏览器控制台 使用 window.alert() 写入警告框 12345678910111213&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script&gt; window.alert(&quot;hello js&quot;);//写入警告框&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 上面代码通过浏览器打开，我们可以看到如下图弹框效果 使用 document.write() 写入 HTML 输出 12345678910111213&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script&gt; document.write(&quot;hello js 2~&quot;);//写入html页面&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 上面代码通过浏览器打开，我们可以在页面上看到 document.write(内容) 输出的内容 使用 console.log() 写入浏览器控制台 12345678910111213&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;script&gt; console.log(&quot;hello js 3&quot;);//写入浏览器的控制台&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 上面代码通过浏览器打开，我们可以在不能页面上看到 console.log(内容) 输出的内容，它是输出在控制台了，而怎么在控制台查看输出的内容呢？在浏览器界面按 F12 就可以看到下图的控制台 3.3 变量 3.3.1 使用 var 定义变量 JavaScript 中用 var 关键字（variable 的缩写）来声明变量。格式 var 变量名 = 数据值;。而在JavaScript 是一门弱类型语言，变量==可以存放不同类型的值==；如下在定义变量时赋值为数字数据，还可以将变量的值改为字符串类型的数 12var test = 20;test = &quot;张三&quot;; js 中的变量名命名也有如下规则，和java语言基本都相同 组成字符可以是任何字母、数字、下划线（_）或美元符号（$） 数字不能开头 建议使用驼峰命名 JavaScript 中 var 关键字有点特殊，有以下地方和其他语言不一样 作用域：全局变量 1234&#123; var age = 20;&#125;alert(age); // 在代码块中定义的age 变量，在代码块外边还可以使用 变量可以重复定义 12345&#123; var age = 20; var age = 30;//JavaScript 会用 30 将之前 age 变量的 20 替换掉&#125;alert(age); //打印的结果是 30 3.3.2 使用 let 定义变量 针对如上的问题，==ECMAScript 6 新增了 let 关键字来定义变量。==它的用法类似于 var，但是所声明的变量，只在 let 关键字所在的代码块内有效，且不允许重复声明。 例如： 1234&#123; let age = 20;&#125;alert(age); 运行上面代码，浏览器并没有弹框输出结果，说明这段代码是有问题的。通过 F12 打开开发者模式可以看到如下错误信息 而如果在代码块中定义两个同名的变量，IDEA 开发工具就直接报错了 3.3.3 使用 const 定义常量 ECMAScript 6 新增了 const关键字，用来声明一个只读的常量。一旦声明，常量的值就不能改变。 通过下面的代码看一下常用的特点就可以了 我们可以看到给 PI 这个常量重新赋值时报错了。 3.4 数据类型 JavaScript 中提供了两类数据类型：原始类型 和 引用类型。 使用 typeof 运算符可以获取数据类型 alert(typeof age); 以弹框的形式将 age 变量的数据类型输出 3.4.1 原始数据类型： number：数字（整数、小数、NaN(Not a Number)） 12345var age = 20;var price = 99.8;alert(typeof age); // 结果是 ： numberalert(typeof price);// 结果是 ： number 注意： NaN是一个特殊的number类型的值，后面用到再说 string：字符、字符串，单双引皆可 1234567var ch = &#x27;a&#x27;;var name = &#x27;张三&#x27;; var addr = &quot;北京&quot;;alert(typeof ch); //结果是 stringalert(typeof name); //结果是 stringalert(typeof addr); //结果是 string ==注意：==在 js 中 双引号和单引号都表示字符串类型的数据 boolean：布尔。true，false 12345var flag = true;var flag2 = false;alert(typeof flag); //结果是 booleanalert(typeof flag2); //结果是 boolean null：对象为空 123var obj = null;alert(typeof obj);//结果是 object 为什么打印上面的 obj 变量的数据类型，结果是object；这个官方给出了解释，下面是从官方文档截的图 undefined：当声明的变量未初始化时，该变量的默认值是 undefined 12var a ;alert(typeof a); //结果是 undefined 3.5 运算符 JavaScript 提供了如下的运算符。大部分和 Java语言 都是一样的，不同的是 JS 关系运算符中的 == 和 ===，一会我们只演示这两个的区别，其他运算符将不做演示 一元运算符：++，– 算术运算符：+，-，*，/，% 赋值运算符：=，+=，-=… 关系运算符：&gt;，&lt;，&gt;=，&lt;=，!=，==，===… 逻辑运算符：&amp;&amp;，||，! 三元运算符：条件表达式 ? true_value : false_value 3.5.1 ==和===区别 概述: ==： 判断类型是否一样，如果不一样，则进行类型转换 再去比较其值 ===：js 中的全等于 判断类型是否一样，如果不一样，直接返回false 再去比较其值 代码： 12345var age1 = 20;var age2 = &quot;20&quot;;alert(age1 == age2);// truealert(age1 === age2);// false 3.5.2 类型转换 上述讲解 == 运算符时，发现会进行类型转换，所以接下来我们来详细的讲解一下 JavaScript 中的类型转换。 其他类型转为number string 转换为 number 类型：按照字符串的字面值，转为数字。如果字面值不是数字，则转为NaN 将 string 转换为 number 有两种方式： 使用 + 正号运算符： 12var str = +&quot;20&quot;;alert(str + 1) //21 使用 parseInt() 函数(方法)： 12var str = &quot;20&quot;;alert(parseInt(str) + 1); 建议使用 parseInt() 函数进行转换。 boolean 转换为 number 类型：true 转为1，false转为0 12var flag = +false;alert(flag); // 0 其他类型转为boolean number 类型转换为 boolean 类型：0和NaN转为false，其他的数字转为true string 类型转换为 boolean 类型：空字符串转为false，其他的字符串转为true null类型转换为 boolean 类型是 false undefined 转换为 boolean 类型是 false 代码如下： 123456789// var flag = 3;// var flag = &quot;&quot;;var flag = undefined;if(flag)&#123; alert(&quot;转为true&quot;);&#125;else &#123; alert(&quot;转为false&quot;);&#125; 使用场景： 在 Java 中使用字符串前，一般都会先判断字符串不是null，并且不是空字符才会做其他的一些操作，JavaScript也有类型的操作，代码如下： 12345678var str = &quot;abc&quot;;//健壮性判断if(str != null &amp;&amp; str.length &gt; 0)&#123; alert(&quot;转为true&quot;);&#125;else &#123; alert(&quot;转为false&quot;);&#125; 但是由于 JavaScript 会自动进行类型转换，所以上述的判断可以进行简化，代码如下： 12345678var str = &quot;abc&quot;;//健壮性判断if(str)&#123; alert(&quot;转为true&quot;);&#125;else &#123; alert(&quot;转为false&quot;);&#125; 3.6 流程控制语句 JavaScript 中提供了和 Java 一样的流程控制语句，如下 if switch for while dowhile 3.6.1 if 语句 1234var count = 3;if (count == 3) &#123; alert(count);&#125; 3.6.2 switch 语句 123456789101112131415161718192021222324252627var num = 3;switch (num) &#123; case 1: alert(&quot;星期一&quot;); break; case 2: alert(&quot;星期二&quot;); break; case 3: alert(&quot;星期三&quot;); break; case 4: alert(&quot;星期四&quot;); break; case 5: alert(&quot;星期五&quot;); break; case 6: alert(&quot;星期六&quot;); break; case 7: alert(&quot;星期日&quot;); break; default: alert(&quot;输入的星期有误&quot;); break;&#125; 3.6.3 for 循环语句 12345var sum = 0;for (let i = 1; i &lt;= 100; i++) &#123; //建议for循环小括号中定义的变量使用let，作为局部变量 sum += i;&#125;alert(sum); 3.6.4 while 循环语句 1234567var sum = 0;var i = 1;while (i &lt;= 100) &#123; sum += i; i++;&#125;alert(sum); 3.6.5 dowhile 循环语句 12345678var sum = 0;var i = 1;do &#123; sum += i; i++;&#125;while (i &lt;= 100);alert(sum); 3.7 函数 函数（就是Java中的方法）是被设计为执行特定任务的代码块；JavaScript 函数通过 function 关键词进行定义。 3.7.1 定义格式 函数定义格式有两种： 方式1 123function 函数名(参数1,参数2..)&#123; 要执行的代码&#125; 方式2 123var 函数名 = function (参数列表)&#123; 要执行的代码&#125; 注意： 形式参数不需要类型。因为JavaScript是弱类型语言 123function add(a, b)&#123; return a + b;&#125; 上述函数的参数 a 和 b 不需要定义数据类型，因为在每个参数前加上 var 也没有任何意义。 返回值也不需要定义类型，可以在函数内部直接使用return返回即可 3.7.2 函数调用 函数调用函数： 1函数名称(实际参数列表); eg： 1let result = add(10,20); 注意： JS中，函数调用可以传递任意个数参数 例如 let result = add(1,2,3); 它是将数据 1 传递给了变量a，将数据 2 传递给了变量 b，而数据 3 没有变量接收。 4，JavaScript常用对象 JavaScript 提供了很多对象供使用者来使用。这些对象总共分类三类 基本对象 BOM 对象 DOM对象 DOM 中的对象就比较多了，下图只是截取部分 这小节我们先学习基本对象，而我们先学习 Array 数组对象和 String 字符串对象。 4.1 Array对象 JavaScript Array对象用于定义数组 4.1.1 定义格式 数组的定义格式有两种： 方式1 1var 变量名 = new Array(元素列表); 例如： 1var arr = new Array(1,2,3); //1,2,3 是存储在数组中的数据（元素） 方式2 1var 变量名 = [元素列表]; 例如： 1var arr = [1,2,3]; //1,2,3 是存储在数组中的数据（元素） 注意：Java中的数组静态初始化使用的是{}定义，而 JavaScript 中使用的是 [] 定义 4.1.2 元素访问 访问数组中的元素和 Java 语言的一样，格式如下： 1arr[索引] = 值; 代码演示： 1234567891011 // 方式一var arr = new Array(1,2,3);// alert(arr);// 方式二var arr2 = [1,2,3];//alert(arr2);// 访问arr2[0] = 10;alert(arr2) 4.1.3 特点 JavaScript 中的数组相当于 Java 中集合collection。数组的长度是可以变化的，而 JavaScript 是弱类型，所以可以存储任意的类型的数据。 例如如下代码： 12345// 变长var arr3 = [1,2,3];arr3[10] = 10;alert(arr3[10]); // 10alert(arr3[9]); //undefined 上面代码在定义数组中给了三个元素，又给索引是 10 的位置添加了数据 10，那么 索引3 到 索引9 位置的元素是什么呢？我们之前就介绍了，在 JavaScript 中没有赋值的话，默认就是 undefined。 如果给 arr3 数组添加字符串的数据，也是可以添加成功的 12arr3[5] = &quot;hello&quot;;alert(arr3[5]); // hello 4.1.4 属性 Array 对象提供了很多属性，如下图是官方文档截取的 而我们只讲解 length 属性，该数组可以动态的获取数组的长度。而有这个属性，我们就可以遍历数组了 1234var arr = [1,2,3];for (let i = 0; i &lt; arr.length; i++) &#123; alert(arr[i]);&#125; 4.1.5 方法 Array 对象同样也提供了很多方法，如下图是官方文档截取的 而我们在课堂中只演示 push 函数和 splice 函数。 push 函数：给数组添加元素，也就是在数组的末尾添加元素 参数表示要添加的元素 1234// push:添加方法var arr5 = [1,2,3];arr5.push(10);alert(arr5); //数组的元素是 &#123;1,2,3,10&#125; splice 函数：删除元素 参数1：索引。表示从哪个索引位置删除 参数2：个数。表示删除几个元素 1234// splice:删除元素var arr5 = [1,2,3];arr5.splice(0,1); //从 0 索引位置开始删除，删除一个元素 alert(arr5); // &#123;2,3&#125; 4.2 String对象 String对象的创建方式有两种 方式1： 1var 变量名 = new String(s); 方式2： 1var 变量名 = &quot;数组&quot;; 属性： String对象提供了很多属性，下面给大家列举了一个属性 length ，该属性是用于动态的获取字符串的长度 函数： String对象提供了很多函数（方法），下面给大家列举了两个方法。 String对象还有一个函数 trim() ，该方法在文档中没有体现，但是所有的浏览器都支持；它是用来去掉字符串两端的空格。 代码演示： 12var str4 = &#x27; abc &#x27;;alert(1 + str4 + 1); 上面代码会输出内容 1 abc 1，很明显可以看到 abc 字符串左右两边是有空格的。接下来使用 trim() 函数 12var str4 = &#x27; abc &#x27;;alert(1 + str4.trim() + 1); 输出的内容是 1abc1 。这就是 trim() 函数的作用。 trim() 函数在以后开发中还是比较常用的，例如下图所示是登陆界面 用户在输入用户名和密码时，可能会习惯的输入一些空格，这样在我们后端程序中判断用户名和密码是否正确，结果肯定是失败。所以我们一般都会对用户输入的字符串数据进行去除前后空格的操作。 4.3 自定义对象 在 JavaScript 中自定义对象特别简单，下面就是自定义对象的格式： 1234567var 对象名称 = &#123; 属性名称1:属性值1, 属性名称2:属性值2, ..., 函数名称:function (形参列表)&#123;&#125;, ...&#125;; 调用属性的格式： 1对象名.属性名 调用函数的格式： 1对象名.函数名() 接下来通过代码演示一下，让大家体验一下 JavaScript 中自定义对象 12345678910111213var person = &#123; name : &quot;zhangsan&quot;, age : 23, eat: function ()&#123; alert(&quot;干饭~&quot;); &#125; &#125;;alert(person.name); //zhangsanalert(person.age); //23person.eat(); //干饭~ 5，BOM BOM：Browser Object Model 浏览器对象模型。也就是 JavaScript 将浏览器的各个组成部分封装为对象。 我们要操作浏览器的各个组成部分就可以通过操作 BOM 中的对象来实现。比如：我现在想将浏览器地址栏的地址改为 https://www.itheima.com 就可以通过使用 BOM 中定义的 Location 对象的 href 属性，代码： location.href = &quot;https://itheima.com&quot;; BOM 中包含了如下对象： Window：浏览器窗口对象 Navigator：浏览器对象 Screen：屏幕对象 History：历史记录对象 Location：地址栏对象 下图是 BOM 中的各个对象和浏览器的各个组成部分的对应关系 BOM 中的 Navigator 对象和 Screen 对象基本不会使用，所以我们的课堂只对 Window、History、Location 对象进行讲解。 5.1 Window对象 window 对象是 JavaScript 对浏览器的窗口进行封装的对象。 5.1.1 获取window对象 该对象不需要创建直接使用 window，其中 window. 可以省略。比如我们之前使用的 alert() 函数，其实就是 window 对象的函数，在调用是可以写成如下两种 显式使用 window 对象调用 1window.alert(&quot;abc&quot;); 隐式调用 1alert(&quot;abc&quot;) 5.1.2 window对象属性 window 对象提供了用于获取其他 BOM 组成对象的属性 也就是说，我们想使用 Location 对象的话，就可以使用 window 对象获取；写成 window.location，而 window. 可以省略，简化写成 location 来获取 Location 对象。 5.1.3 window对象函数 window 对象提供了很多函数供我们使用，而很多都不常用；下面给大家列举了一些比较常用的函数 setTimeout(function,毫秒值) : 在一定的时间间隔后执行一个function，只执行一次 setInterval(function,毫秒值) :在一定的时间间隔后执行一个function，循环执行 confirm代码演示： 123456// confirm()，点击确定按钮，返回true，点击取消按钮，返回falsevar flag = confirm(&quot;确认删除？&quot;);if(flag)&#123; //执行删除&#125; 下图是 confirm() 函数的效果。当我们点击 确定 按钮，flag 变量值记录的就是 true ；当我们点击 取消 按钮，flag 变量值记录的就是 false。 而以后我们在页面删除数据时候如下图每一条数据后都有 删除 按钮，有可能是用户的一些误操作，所以对于删除操作需要用户进行再次确认，此时就需要用到 confirm() 函数。 定时器代码演示： 123setTimeout(function ()&#123; alert(&quot;hehe&quot;);&#125;,3000); 当我们打开浏览器，3秒后才会弹框输出 hehe，并且只会弹出一次。 123setInterval(function ()&#123; alert(&quot;hehe&quot;);&#125;,2000); 当我们打开浏览器，每隔2秒都会弹框输出 hehe。 5.1.4 案例 需求：每隔1秒，灯泡切换一次状态 需求说明： 有如下页面效果，实现定时进行开灯、关灯功能 初始页面环境 123456789101112131415161718192021222324&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;JavaScript演示&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;input type=&quot;button&quot; onclick=&quot;on()&quot; value=&quot;开灯&quot;&gt;&lt;img id=&quot;myImage&quot; border=&quot;0&quot; src=&quot;../imgs/off.gif&quot; style=&quot;text-align:center;&quot;&gt;&lt;input type=&quot;button&quot; onclick=&quot;off()&quot; value=&quot;关灯&quot;&gt;&lt;script&gt; function on()&#123; document.getElementById(&#x27;myImage&#x27;).src=&#x27;../imgs/on.gif&#x27;; &#125; function off()&#123; document.getElementById(&#x27;myImage&#x27;).src=&#x27;../imgs/off.gif&#x27; &#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 代码实现： 123456789101112131415161718192021222324252627282930313233343536&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;JavaScript演示&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;input type=&quot;button&quot; onclick=&quot;on()&quot; value=&quot;开灯&quot;&gt;&lt;img id=&quot;myImage&quot; border=&quot;0&quot; src=&quot;../imgs/off.gif&quot; style=&quot;text-align:center;&quot;&gt;&lt;input type=&quot;button&quot; onclick=&quot;off()&quot; value=&quot;关灯&quot;&gt;&lt;script&gt; function on()&#123; document.getElementById(&#x27;myImage&#x27;).src=&#x27;../imgs/on.gif&#x27;; &#125; function off()&#123; document.getElementById(&#x27;myImage&#x27;).src=&#x27;../imgs/off.gif&#x27; &#125; //定义一个变量，用来记录灯的状态，偶数是开灯状态，奇数是关灯状态 var x = 0; //使用循环定时器 setInterval(function ()&#123; if(x % 2 == 0)&#123;//表示是偶数，开灯状态，调用 on() 函数 on(); &#125;else &#123; //表示是奇数，关灯状态，调用 off() 函数 off(); &#125; x ++;//改变变量的值 &#125;,1000);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 5.2 History对象 History 对象是 JavaScript 对历史记录进行封装的对象。 History 对象的获取 使用 window.history获取，其中window. 可以省略 History 对象的函数 这两个函数我们平时在访问其他的一些网站时经常使用对应的效果，如下图 当我们点击向左的箭头，就跳转到前一个访问的页面，这就是 back() 函数的作用；当我们点击向右的箭头，就跳转到下一个访问的页面，这就是 forward() 函数的作用。 5.3 Location对象 Location 对象是 JavaScript 对地址栏封装的对象。可以通过操作该对象，跳转到任意页面。 5.3.1 获取Location对象 使用 window.location获取，其中window. 可以省略 12window.location.方法();location.方法(); 5.3.2 Location对象属性 Location对象提供了很对属性。以后常用的只有一个属性 href 代码演示： 12alert(&quot;要跳转了&quot;);location.href = &quot;https://www.baidu.com&quot;; 在浏览器首先会弹框显示 要跳转了，当我们点击了 确定 就会跳转到 百度 的首页。 5.3.3 案例 需求：3秒跳转到百度首页 分析： 3秒跳转，由此可以确定需要使用到定时器，而只跳转一次，所以使用 setTimeOut() 要进行页面跳转，所以需要用到 location 对象的 href 属性实现 代码实现： 1234document.write(&quot;3秒跳转到首页...&quot;); setTimeout(function ()&#123; location.href = &quot;https://www.baidu.com&quot;&#125;,3000); 6，DOM 6.1 概述 DOM：Document Object Model 文档对象模型。也就是 JavaScript 将 HTML 文档的各个组成部分封装为对象。 DOM 其实我们并不陌生，之前在学习 XML 就接触过，只不过 XML 文档中的标签需要我们写代码解析，而 HTML 文档是浏览器解析。封装的对象分为 Document：整个文档对象 Element：元素对象 Attribute：属性对象 Text：文本对象 Comment：注释对象 如下图，左边是 HTML 文档内容，右边是 DOM 树 作用： JavaScript 通过 DOM， 就能够对 HTML进行操作了 改变 HTML 元素的内容 改变 HTML 元素的样式（CSS） 对 HTML DOM 事件作出反应 添加和删除 HTML 元素 DOM相关概念： DOM 是 W3C（万维网联盟）定义了访问 HTML 和 XML 文档的标准。该标准被分为 3 个不同的部分： 核心 DOM：针对任何结构化文档的标准模型。 XML 和 HTML 通用的标准 Document：整个文档对象 Element：元素对象 Attribute：属性对象 Text：文本对象 Comment：注释对象 XML DOM： 针对 XML 文档的标准模型 HTML DOM： 针对 HTML 文档的标准模型 该标准是在核心 DOM 基础上，对 HTML 中的每个标签都封装成了不同的对象 例如：&lt;img&gt; 标签在浏览器加载到内存中时会被封装成 Image 对象，同时该对象也是 Element 对象。 例如：&lt;input type='button'&gt; 标签在浏览器加载到内存中时会被封装成 Button 对象，同时该对象也是 Element 对象。 6.2 获取 Element对象 HTML 中的 Element 对象可以通过 Document 对象获取，而 Document 对象是通过 window 对象获取。 Document 对象中提供了以下获取 Element 元素对象的函数 getElementById()：根据id属性值获取，返回单个Element对象 getElementsByTagName()：根据标签名称获取，返回Element对象数组 getElementsByName()：根据name属性值获取，返回Element对象数组 getElementsByClassName()：根据class属性值获取，返回Element对象数组 代码演示： 下面有提前准备好的页面： 123456789101112131415161718192021&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;img id=&quot;light&quot; src=&quot;../imgs/off.gif&quot;&gt; &lt;br&gt; &lt;div class=&quot;cls&quot;&gt;传智教育&lt;/div&gt; &lt;br&gt; &lt;div class=&quot;cls&quot;&gt;黑马程序员&lt;/div&gt; &lt;br&gt; &lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot;&gt; 电影 &lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot;&gt; 旅游 &lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot;&gt; 游戏 &lt;br&gt; &lt;script&gt; //在此处书写js代码 &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 根据 id 属性值获取上面的 img 元素对象，返回单个对象 12var img = document.getElementById(&quot;light&quot;);alert(img); 结果如下： 从弹框输出的内容，也可以看出是一个图片元素对象。 根据标签名称获取所有的 div 元素对象 123456var divs = document.getElementsByTagName(&quot;div&quot;);// 返回一个数组，数组中存储的是 div 元素对象// alert(divs.length); //输出 数组的长度//遍历数组for (let i = 0; i &lt; divs.length; i++) &#123; alert(divs[i]);&#125; 获取所有的满足 name = 'hobby' 条件的元素对象 12345//3. getElementsByName：根据name属性值获取，返回Element对象数组var hobbys = document.getElementsByName(&quot;hobby&quot;);for (let i = 0; i &lt; hobbys.length; i++) &#123; alert(hobbys[i]);&#125; 获取所有的满足 class='cls' 条件的元素对象 12345//4. getElementsByClassName：根据class属性值获取，返回Element对象数组var clss = document.getElementsByClassName(&quot;cls&quot;);for (let i = 0; i &lt; clss.length; i++) &#123; alert(clss[i]);&#125; 6.3 HTML Element对象使用 HTML 中的 Element 元素对象有很多，不可能全部记住，以后是根据具体的需求查阅文档使用。 下面我们通过具体的案例给大家演示文档的查询和对象的使用；下面提前给大家准备好的页面 123456789101112131415161718192021&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;img id=&quot;light&quot; src=&quot;../imgs/off.gif&quot;&gt; &lt;br&gt; &lt;div class=&quot;cls&quot;&gt;传智教育&lt;/div&gt; &lt;br&gt; &lt;div class=&quot;cls&quot;&gt;黑马程序员&lt;/div&gt; &lt;br&gt; &lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot;&gt; 电影 &lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot;&gt; 旅游 &lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot;&gt; 游戏 &lt;br&gt; &lt;script&gt; //在此处写js低吗 &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 需求： 点亮灯泡 此案例由于需要改变 img 标签 的图片，所以我们查询文档，下图是查看文档的流程： 代码实现： 1234//1，根据 id=&#x27;light&#x27; 获取 img 元素对象var img = document.getElementById(&quot;light&quot;);//2，修改 img 对象的 src 属性来改变图片img.src = &quot;../imgs/on.gif&quot;; 将所有的 div 标签的标签体内容替换为 呵呵 1234567891011//1，获取所有的 div 元素对象var divs = document.getElementsByTagName(&quot;div&quot;);/* style:设置元素css样式 innerHTML：设置元素内容 *///2，遍历数组，获取到每一个 div 元素对象，并修改元素内容for (let i = 0; i &lt; divs.length; i++) &#123; //divs[i].style.color = &#x27;red&#x27;; divs[i].innerHTML = &quot;呵呵&quot;;&#125; 使所有的复选框呈现被选中的状态 此案例我们需要看 复选框 元素对象有什么属性或者函数是来操作 复选框的选中状态。下图是文档的查看 代码实现： 123456//1，获取所有的 复选框 元素对象var hobbys = document.getElementsByName(&quot;hobby&quot;);//2，遍历数组，通过将 复选框 元素对象的 checked 属性值设置为 true 来改变复选框的选中状态for (let i = 0; i &lt; hobbys.length; i++) &#123; hobbys[i].checked = true;&#125; 7，事件监听 要想知道什么是事件监听，首先先聊聊什么是事件？ HTML 事件是发生在 HTML 元素上的“事情”。比如：页面上的 按钮被点击、鼠标移动到元素之上、按下键盘按键 等都是事件。 事件监听是JavaScript 可以在事件被侦测到时==执行一段逻辑代码。==例如下图当我们点击 开灯 按钮，就需要通过 js 代码实现替换图片 再比如下图输入框，当我们输入了用户名 光标离开 输入框，就需要通过 js 代码对输入的内容进行校验，没通过校验就在输入框后提示 用户名格式有误! 7.1 事件绑定 JavaScript 提供了两种事件绑定方式： 方式一：通过 HTML标签中的事件属性进行绑定 如下面代码，有一个按钮元素，我们是在该标签上定义 事件属性，在事件属性中绑定函数。onclick 就是 单击事件 的事件属性。onclick='on（）' 表示该点击事件绑定了一个名为 on() 的函数 1&lt;input type=&quot;button&quot; onclick=&#x27;on()’&gt; 下面是点击事件绑定的 on() 函数 123function on()&#123; alert(&quot;我被点了&quot;);&#125; 方式二：通过 DOM 元素属性绑定 如下面代码是按钮标签，在该标签上我们并没有使用 事件属性，绑定事件的操作需要在 js 代码中实现 1&lt;input type=&quot;button&quot; id=&quot;btn&quot;&gt; 下面 js 代码是获取了 id='btn' 的元素对象，然后将 onclick 作为该对象的属性，并且绑定匿名函数。该函数是在事件触发后自动执行 123document.getElementById(&quot;btn&quot;).onclick = function ()&#123; alert(&quot;我被点了&quot;);&#125; 代码演示： 12345678910111213141516171819202122&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;!--方式1：在下面input标签上添加 onclick 属性，并绑定 on() 函数--&gt; &lt;input type=&quot;button&quot; value=&quot;点我&quot; onclick=&quot;on()&quot;&gt; &lt;br&gt; &lt;input type=&quot;button&quot; value=&quot;再点我&quot; id=&quot;btn&quot;&gt; &lt;script&gt; function on()&#123; alert(&quot;我被点了&quot;); &#125; //方式2：获取 id=&quot;btn&quot; 元素对象，通过调用 onclick 属性 绑定点击事件 document.getElementById(&quot;btn&quot;).onclick = function ()&#123; alert(&quot;我被点了&quot;); &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 7.2 常见事件 上面案例中使用到了 onclick 事件属性，那都有哪些事件属性供我们使用呢？下面就给大家列举一些比较常用的事件属性 事件属性名 说明 onclick 鼠标单击事件 onblur 元素失去焦点 onfocus 元素获得焦点 onload 某个页面或图像被完成加载 onsubmit 当表单提交时触发该事件 onmouseover 鼠标被移到某元素之上 onmouseout 鼠标从某元素移开 onfocus 获得焦点事件。 如下图，当点击了输入框后，输入框就获得了焦点。而下图示例是当获取焦点后会更改输入框的背景颜色。 onblur 失去焦点事件。 如下图，当点击了输入框后，输入框就获得了焦点；再点击页面其他位置，那输入框就失去焦点了。下图示例是将输入的文本转换为大写。 onmouseout 鼠标移出事件。 onmouseover 鼠标移入事件。 如下图，当鼠标移入到 苹果 图片上时，苹果图片变大；当鼠标移出 苹果图片时，苹果图片变小。 onsubmit 表单提交事件 如下是带有表单的页面 12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;form id=&quot;register&quot; action=&quot;#&quot; &gt; &lt;input type=&quot;text&quot; name=&quot;username&quot; /&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt; &lt;/form&gt; &lt;script&gt; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 如上代码的表单，当我们点击 提交 按钮后，表单就会提交，此处默认使用的是 GET 提交方式，会将提交的数据拼接到 URL 后。现需要通过 js 代码实现阻止表单提交的功能，js 代码实现如下： 获取 form 表单元素对象。 给 form 表单元素对象绑定 onsubmit 事件，并绑定匿名函数。 该匿名函数如果返回的是true，提交表单；如果返回的是false，阻止表单提交。 1234document.getElementById(&quot;register&quot;).onsubmit = function ()&#123; //onsubmit 返回true，则表单会被提交，返回false，则表单不提交 return true;&#125; 8，表单验证案例 8.1 需求 有如下注册页面，对表单进行校验，如果输入的用户名、密码、手机号符合规则，则允许提交；如果不符合规则，则不允许提交。 完成以下需求： 当输入框失去焦点时，验证输入内容是否符合要求 当点击注册按钮时，判断所有输入框的内容是否都符合要求，如果不合符则阻止表单提交 8.2 环境准备 下面是初始页面 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;欢迎注册&lt;/title&gt; &lt;link href=&quot;../css/register.css&quot; rel=&quot;stylesheet&quot;&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;form-div&quot;&gt; &lt;div class=&quot;reg-content&quot;&gt; &lt;h1&gt;欢迎注册&lt;/h1&gt; &lt;span&gt;已有帐号？&lt;/span&gt; &lt;a href=&quot;#&quot;&gt;登录&lt;/a&gt; &lt;/div&gt; &lt;form id=&quot;reg-form&quot; action=&quot;#&quot; method=&quot;get&quot;&gt; &lt;table&gt; &lt;tr&gt; &lt;td&gt;用户名&lt;/td&gt; &lt;td class=&quot;inputs&quot;&gt; &lt;input name=&quot;username&quot; type=&quot;text&quot; id=&quot;username&quot;&gt; &lt;br&gt; &lt;span id=&quot;username_err&quot; class=&quot;err_msg&quot; style=&quot;display: none&quot;&gt;用户名不太受欢迎&lt;/span&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;密码&lt;/td&gt; &lt;td class=&quot;inputs&quot;&gt; &lt;input name=&quot;password&quot; type=&quot;password&quot; id=&quot;password&quot;&gt; &lt;br&gt; &lt;span id=&quot;password_err&quot; class=&quot;err_msg&quot; style=&quot;display: none&quot;&gt;密码格式有误&lt;/span&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;手机号&lt;/td&gt; &lt;td class=&quot;inputs&quot;&gt;&lt;input name=&quot;tel&quot; type=&quot;text&quot; id=&quot;tel&quot;&gt; &lt;br&gt; &lt;span id=&quot;tel_err&quot; class=&quot;err_msg&quot; style=&quot;display: none&quot;&gt;手机号格式有误&lt;/span&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;div class=&quot;buttons&quot;&gt; &lt;input value=&quot;注 册&quot; type=&quot;submit&quot; id=&quot;reg_btn&quot;&gt; &lt;/div&gt; &lt;br class=&quot;clear&quot;&gt; &lt;/form&gt; &lt;/div&gt; &lt;script&gt; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 8.3 验证输入框 此小节完成如下功能： 校验用户名。当用户名输入框失去焦点时，判断输入的内容是否符合 长度是 6-12 位 规则，不符合使 id='username_err' 的span标签显示出来，给出用户提示。 校验密码。当密码输入框失去焦点时，判断输入的内容是否符合 长度是 6-12 位 规则，不符合使 id='password_err' 的span标签显示出来，给出用户提示。 校验手机号。当手机号输入框失去焦点时，判断输入的内容是否符合 长度是 11 位 规则，不符合使 id='tel_err' 的span标签显示出来，给出用户提示。 代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556//1. 验证用户名是否符合规则//1.1 获取用户名的输入框var usernameInput = document.getElementById(&quot;username&quot;);//1.2 绑定onblur事件 失去焦点usernameInput.onblur = function () &#123; //1.3 获取用户输入的用户名 var username = usernameInput.value.trim(); //1.4 判断用户名是否符合规则：长度 6~12 if (username.length &gt;= 6 &amp;&amp; username.length &lt;= 12) &#123; //符合规则 document.getElementById(&quot;username_err&quot;).style.display = &#x27;none&#x27;; &#125; else &#123; //不合符规则 document.getElementById(&quot;username_err&quot;).style.display = &#x27;&#x27;; &#125;&#125;//1. 验证密码是否符合规则//1.1 获取密码的输入框var passwordInput = document.getElementById(&quot;password&quot;);//1.2 绑定onblur事件 失去焦点passwordInput.onblur = function() &#123; //1.3 获取用户输入的密码 var password = passwordInput.value.trim(); //1.4 判断密码是否符合规则：长度 6~12 if (password.length &gt;= 6 &amp;&amp; password.length &lt;= 12) &#123; //符合规则 document.getElementById(&quot;password_err&quot;).style.display = &#x27;none&#x27;; &#125; else &#123; //不合符规则 document.getElementById(&quot;password_err&quot;).style.display = &#x27;&#x27;; &#125;&#125;//1. 验证手机号是否符合规则//1.1 获取手机号的输入框var telInput = document.getElementById(&quot;tel&quot;);//1.2 绑定onblur事件 失去焦点telInput.onblur = function() &#123; //1.3 获取用户输入的手机号 var tel = telInput.value.trim(); //1.4 判断手机号是否符合规则：长度 11 if (tel.length == 11) &#123; //符合规则 document.getElementById(&quot;tel_err&quot;).style.display = &#x27;none&#x27;; &#125; else &#123; //不合符规则 document.getElementById(&quot;tel_err&quot;).style.display = &#x27;&#x27;; &#125;&#125; 8.3 验证表单 当用户点击 注册 按钮时，需要同时对输入的 用户名、密码、手机号 ，如果都符合规则，则提交表单；如果有一个不符合规则，则不允许提交表单。实现该功能需要获取表单元素对象，并绑定 onsubmit 事件 1234567//1. 获取表单对象var regForm = document.getElementById(&quot;reg-form&quot;);//2. 绑定onsubmit 事件regForm.onsubmit = function () &#123; &#125; onsubmit 事件绑定的函数需要对输入的 用户名、密码、手机号 进行校验，这些校验我们之前都已经实现过了，这里我们还需要再校验一次吗？不需要，只需要对之前校验的代码进行改造，把每个校验的代码专门抽象到有名字的函数中，方便调用；并且每个函数都要返回结果来去决定是提交表单还是阻止表单提交，代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768//1. 验证用户名是否符合规则//1.1 获取用户名的输入框var usernameInput = document.getElementById(&quot;username&quot;);//1.2 绑定onblur事件 失去焦点usernameInput.onblur = checkUsername;function checkUsername() &#123; //1.3 获取用户输入的用户名 var username = usernameInput.value.trim(); //1.4 判断用户名是否符合规则：长度 6~12 var flag = username.length &gt;= 6 &amp;&amp; username.length &lt;= 12 || username.length == 0; if (flag) &#123; //符合规则 document.getElementById(&quot;username_err&quot;).style.display = &#x27;none&#x27;; &#125; else &#123; //不合符规则 document.getElementById(&quot;username_err&quot;).style.display = &#x27;&#x27;; &#125; return flag;&#125;//1. 验证密码是否符合规则//1.1 获取密码的输入框var passwordInput = document.getElementById(&quot;password&quot;);//1.2 绑定onblur事件 失去焦点passwordInput.onblur = checkPassword;function checkPassword() &#123; //1.3 获取用户输入的密码 var password = passwordInput.value.trim(); //1.4 判断密码是否符合规则：长度 6~12 var flag = password.length &gt;= 6 &amp;&amp; password.length &lt;= 12|| password.length == 0; if (flag) &#123; //符合规则 document.getElementById(&quot;password_err&quot;).style.display = &#x27;none&#x27;; &#125; else &#123; //不合符规则 document.getElementById(&quot;password_err&quot;).style.display = &#x27;&#x27;; &#125; return flag;&#125;//1. 验证手机号是否符合规则//1.1 获取手机号的输入框var telInput = document.getElementById(&quot;tel&quot;);//1.2 绑定onblur事件 失去焦点telInput.onblur = checkTel;function checkTel() &#123; //1.3 获取用户输入的手机号 var tel = telInput.value.trim(); //1.4 判断手机号是否符合规则：长度 11 var flag = tel.length == 11; if (flag) &#123; //符合规则 document.getElementById(&quot;tel_err&quot;).style.display = &#x27;none&#x27;; &#125; else &#123; //不合符规则 document.getElementById(&quot;tel_err&quot;).style.display = &#x27;&#x27;; &#125; return flag;&#125; 而 onsubmit 绑定的函数需要调用 checkUsername() 函数、checkPassword() 函数、checkTel() 函数。 1234567891011//1. 获取表单对象var regForm = document.getElementById(&quot;reg-form&quot;);//2. 绑定onsubmit 事件regForm.onsubmit = function () &#123; //挨个判断每一个表单项是否都符合要求，如果有一个不合符，则返回false var flag = checkUsername() &amp;&amp; checkPassword() &amp;&amp; checkTel(); return flag;&#125; 9，RegExp对象 RegExp 是正则对象。正则对象是判断指定字符串是否符合规则。 如下图是百度贴吧中的帖子 我们可以通过爬虫技术去爬取该页面源代码，然后获取页面中所有的邮箱，后期我们可以给这些邮箱地址发送推广的邮件。那么问题来了，如何才能知道页面内容中哪些是邮箱地址呢？这里就可以使用正则表达式来匹配邮箱。 在 js 中对正则表达式封装的对象就是正则对象。 9.1 正则对象使用 9.1.1 创建对象 正则对象有两种创建方式： 直接量方式：注意不要加引号 1var reg = /正则表达式/; 创建 RegExp 对象 1var reg = new RegExp(&quot;正则表达式&quot;); 9.1.2 函数 test(str) ：判断指定字符串是否符合规则，返回 true或 false 9.2 正则表达式 从上面创建正则对象的格式中可以看出不管哪种方式都需要正则表达式，那么什么是正则表达式呢？ 正则表达式定义了字符串组成的规则。也就是判断指定的字符串是否符合指定的规则，如果符合返回true，如果不符合返回false。 正则表达式是和语言无关的。很多语言都支持正则表达式，Java语言也支持，只不过正则表达式在不同的语言中的使用方式不同，js 中需要使用正则对象来使用正则表达式。 正则表达式常用的规则如下： ^：表示开始 $：表示结束 [ ]：代表某个范围内的单个字符，比如： [0-9] 单个数字字符 .：代表任意单个字符，除了换行和行结束符 \\w：代表单词字符：字母、数字、下划线()，相当于 [A-Za-z0-9] \\d：代表数字字符： 相当于 [0-9] 量词： +：至少一个 *：零个或多个 ？：零个或一个 {x}：x个 {m,}：至少m个 {m,n}：至少m个，最多n个 代码演示： 12345678// 规则：单词字符，6~12//1,创建正则对象，对正则表达式进行封装var reg = /^\\w&#123;6,12&#125;$/;var str = &quot;abcccc&quot;;//2,判断 str 字符串是否符合 reg 封装的正则表达式的规则var flag = reg.test(str);alert(flag); 9.3 改进表单校验案例 表单校验案例中的规则是我们进行一系列的判断来实现的，现在学习了正则对象后，就可以使用正则对象来改进这个案例。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;欢迎注册&lt;/title&gt; &lt;link href=&quot;../css/register.css&quot; rel=&quot;stylesheet&quot;&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;form-div&quot;&gt; &lt;div class=&quot;reg-content&quot;&gt; &lt;h1&gt;欢迎注册&lt;/h1&gt; &lt;span&gt;已有帐号？&lt;/span&gt; &lt;a href=&quot;#&quot;&gt;登录&lt;/a&gt; &lt;/div&gt; &lt;form id=&quot;reg-form&quot; action=&quot;#&quot; method=&quot;get&quot;&gt; &lt;table&gt; &lt;tr&gt; &lt;td&gt;用户名&lt;/td&gt; &lt;td class=&quot;inputs&quot;&gt; &lt;input name=&quot;username&quot; type=&quot;text&quot; id=&quot;username&quot;&gt; &lt;br&gt; &lt;span id=&quot;username_err&quot; class=&quot;err_msg&quot; style=&quot;display: none&quot;&gt;用户名不太受欢迎&lt;/span&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;密码&lt;/td&gt; &lt;td class=&quot;inputs&quot;&gt; &lt;input name=&quot;password&quot; type=&quot;password&quot; id=&quot;password&quot;&gt; &lt;br&gt; &lt;span id=&quot;password_err&quot; class=&quot;err_msg&quot; style=&quot;display: none&quot;&gt;密码格式有误&lt;/span&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;手机号&lt;/td&gt; &lt;td class=&quot;inputs&quot;&gt;&lt;input name=&quot;tel&quot; type=&quot;text&quot; id=&quot;tel&quot;&gt; &lt;br&gt; &lt;span id=&quot;tel_err&quot; class=&quot;err_msg&quot; style=&quot;display: none&quot;&gt;手机号格式有误&lt;/span&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;div class=&quot;buttons&quot;&gt; &lt;input value=&quot;注 册&quot; type=&quot;submit&quot; id=&quot;reg_btn&quot;&gt; &lt;/div&gt; &lt;br class=&quot;clear&quot;&gt; &lt;/form&gt;&lt;/div&gt;&lt;script&gt; //1. 验证用户名是否符合规则 //1.1 获取用户名的输入框 var usernameInput = document.getElementById(&quot;username&quot;); //1.2 绑定onblur事件 失去焦点 usernameInput.onblur = checkUsername; function checkUsername() &#123; //1.3 获取用户输入的用户名 var username = usernameInput.value.trim(); //1.4 判断用户名是否符合规则：长度 6~12,单词字符组成 var reg = /^\\w&#123;6,12&#125;$/; var flag = reg.test(username); //var flag = username.length &gt;= 6 &amp;&amp; username.length &lt;= 12; if (flag) &#123; //符合规则 document.getElementById(&quot;username_err&quot;).style.display = &#x27;none&#x27;; &#125; else &#123; //不合符规则 document.getElementById(&quot;username_err&quot;).style.display = &#x27;&#x27;; &#125; return flag; &#125; //1. 验证密码是否符合规则 //1.1 获取密码的输入框 var passwordInput = document.getElementById(&quot;password&quot;); //1.2 绑定onblur事件 失去焦点 passwordInput.onblur = checkPassword; function checkPassword() &#123; //1.3 获取用户输入的密码 var password = passwordInput.value.trim(); //1.4 判断密码是否符合规则：长度 6~12 var reg = /^\\w&#123;6,12&#125;$/; var flag = reg.test(password); //var flag = password.length &gt;= 6 &amp;&amp; password.length &lt;= 12; if (flag) &#123; //符合规则 document.getElementById(&quot;password_err&quot;).style.display = &#x27;none&#x27;; &#125; else &#123; //不合符规则 document.getElementById(&quot;password_err&quot;).style.display = &#x27;&#x27;; &#125; return flag; &#125; //1. 验证手机号是否符合规则 //1.1 获取手机号的输入框 var telInput = document.getElementById(&quot;tel&quot;); //1.2 绑定onblur事件 失去焦点 telInput.onblur = checkTel; function checkTel() &#123; //1.3 获取用户输入的手机号 var tel = telInput.value.trim(); //1.4 判断手机号是否符合规则：长度 11，数字组成，第一位是1 //var flag = tel.length == 11; var reg = /^[1]\\d&#123;10&#125;$/; var flag = reg.test(tel); if (flag) &#123; //符合规则 document.getElementById(&quot;tel_err&quot;).style.display = &#x27;none&#x27;; &#125; else &#123; //不合符规则 document.getElementById(&quot;tel_err&quot;).style.display = &#x27;&#x27;; return flag; &#125; //1. 获取表单对象 var regForm = document.getElementById(&quot;reg-form&quot;); //2. 绑定onsubmit 事件 regForm.onsubmit = function () &#123; //挨个判断每一个表单项是否都符合要求，如果有一个不合符，则返回false var flag = checkUsername() &amp;&amp; checkPassword() &amp;&amp; checkTel(); return flag; &#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 来源：it 黑马 JavaWeb 教程","categories":[{"name":"Java","slug":"Java","permalink":"http://littlewuuu.com/categories/Java/"}],"tags":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://littlewuuu.com/tags/JavaWeb/"}]},{"title":"HTML","slug":"黑马/6-HTML","date":"2022-08-21T22:00:00.000Z","updated":"2022-12-01T15:45:15.625Z","comments":true,"path":"2022/08/22/黑马/6-HTML/","link":"","permalink":"http://littlewuuu.com/2022/08/22/%E9%BB%91%E9%A9%AC/6-HTML/","excerpt":"","text":"快速入门 1.新建文本文件，后缀名改为 .html/.htm 2.编写 HTML结构标签 3.在中使用定义标题字体 4.使用标签定义图片 5.保存后，使用浏览器打开该文件 | 标签 | 描述 | | -------------- | ------------------------------------------- | | | &lt;HTML&gt; | 定义 HTML 文档 | | &lt;head&gt; | 定义关于文档的信息 | | &lt;title&gt; | 定义文档的标题 | | &lt;body&gt; | 定义文档的主体 | 基础标签 标签 描述 &lt;h1&gt; ~ &lt;h6&gt; 定义标题，h1最大，h6最小 &lt;font&gt; 定义文本的字体、字体尺寸、字体颜色 &lt;b&gt; 定义粗体文本 &lt;i&gt; 定义斜体文本 &lt;u&gt; 定义文本下划线 &lt;center&gt; 定义文本居中 &lt;p&gt; 定义段落 &lt;br&gt; 定义折行 &lt;hr&gt; 定义水平线 HTML 原代码 显示结果 描述 &amp;lt; &lt; 小于号或显示标记 &amp;gt ; &gt; 大于号或显示标记 &amp;amp; &amp; 可用于显示其它特殊字符 &amp;quot; “ 引号 &amp;reg; ® 已注册 &amp;copy; © 版权 &amp;trade; ™ 商标 &amp;nbsp; 不断行的空白 图片、音频、视频标签 标签 描述 &lt;img&gt; 定义图片 &lt;audio&gt; 定义音频 &lt;video&gt; 定义视频 img：定义图片 src：规定显示图像的 URL height：定义图像的高度 width：定义图像的宽度 audio：定义音频。支持的音频格式：MP3、WAV、OGG src：规定音频的 URL controls：显示播放控件 video：定义视频。支持的音频格式：MP4, WebM、OGG src：规定视频的 URL controls：显示播放控件 超链接标签 标签 描述 &lt;a&gt; 定义超链接，用于链接到另一个资源 href：指定访问资源的URL target：指定打开资源的方式 self:默认值，在当前页面打开 blank：在空白页面打开 列表标签 标签 描述 &lt;ol&gt; 定义有序列表 &lt;ul&gt; 定义无序列表 &lt;li&gt; 定义列表项 type：设置符号的类型 表格标签 标签 描述 &lt;table&gt; 定义表格 &lt;tr&gt; 定义行 &lt;td&gt; 定义单元格 &lt;th&gt; 定义表头单元格 table：设置符号的类型 * table：定义表格 * width：宽度 * border：边框 * cellpadding：定义内容和单元格的距离 * cellspacing：定义单元格之间的距离。如果指定为0，则单元格的线会合为一条、 * bgcolor：背景色 * align：对齐方式 * tr：定义行 * bgcolor：背景色 * align：对齐方式 * td：定义单元格 * colspan：合并列 * rowspan：合并行 * th：定义表头单元格 * &lt;caption&gt;：表格标题 布局标签 标签 描述 &lt;div&gt; 定义 HTML 文档中的一个区域部分，经常与 CSS 一起使用，用来布局网页 &lt;span&gt; 用于组合行内元素。 表单标签 标签 描述 &lt;form&gt; 定义表单 &lt;input&gt; 定义表单项，通过type属性控制输入形式 &lt;label&gt; 为表单项定义标注 &lt;select&gt; 定义下拉列表 &lt;option&gt; 定义下拉列表的列表项 &lt;textarea&gt; 定义文本域 type取值 type 取值 描述 text 默认值。定义单行的输入字段 password 定义密码字段 radio 定义单选按钮 checkbox 定义复选框 file 定义文件上传按钮 hidden 定义隐藏的输入字段 submit 定义提交按钮，提交按钮会把表单数据发送到服务器 reset 定义重置按钮，重置按钮会清除表单中的所有数据 button 定义可点击按钮 来源：it 黑马 JavaWeb 教程","categories":[{"name":"Java","slug":"Java","permalink":"http://littlewuuu.com/categories/Java/"}],"tags":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://littlewuuu.com/tags/JavaWeb/"}]},{"title":"Cookie & Session","slug":"黑马/11-会话技术","date":"2022-08-21T22:00:00.000Z","updated":"2022-12-01T15:45:50.926Z","comments":true,"path":"2022/08/22/黑马/11-会话技术/","link":"","permalink":"http://littlewuuu.com/2022/08/22/%E9%BB%91%E9%A9%AC/11-%E4%BC%9A%E8%AF%9D%E6%8A%80%E6%9C%AF/","excerpt":"","text":"会话技术 今日目标 理解什么是会话跟踪技术 掌握Cookie的使用 掌握Session的使用 完善用户登录注册案例的功能 1，会话跟踪技术的概述 对于会话跟踪这四个词，我们需要拆开来进行解释，首先要理解什么是会话，然后再去理解什么是会话跟踪: 会话:用户打开浏览器，访问web服务器的资源，会话建立，直到有一方断开连接，会话结束。在一次会话中可以包含多次请求和响应。 从浏览器发出请求到服务端响应数据给前端之后，一次会话(在浏览器和服务器之间)就被建立了 会话被建立后，如果浏览器或服务端都没有被关闭，则会话就会持续建立着 浏览器和服务器就可以继续使用该会话进行请求发送和响应，上述的整个过程就被称之为会话。 用实际场景来理解下会话，比如在我们访问京东的时候，当打开浏览器进入京东首页后，浏览器和京东的服务器之间就建立了一次会话，后面的搜索商品,查看商品的详情,加入购物车等都是在这一次会话中完成。 思考:下图中总共建立了几个会话? 每个浏览器都会与服务端建立了一个会话，加起来总共是3个会话。 会话跟踪:一种维护浏览器状态的方法，服务器需要识别多次请求是否来自于同一浏览器，以便在同一次会话的多次请求间共享数据。 服务器会收到多个请求，这多个请求可能来自多个浏览器，如上图中的6个请求来自3个浏览器 服务器需要用来识别请求是否来自同一个浏览器 服务器用来识别浏览器的过程，这个过程就是会话跟踪 服务器识别浏览器后就可以在同一个会话中多次请求之间来共享数据 那么我们又有一个问题需要思考，一个会话中的多次请求为什么要共享数据呢?有了这个数据共享功能后能实现哪些功能呢? 购物车: 加入购物车和去购物车结算是两次请求，但是后面这次请求要想展示前一次请求所添加的商品，就需要用到数据共享。 页面展示用户登录信息:很多网站，登录后访问多个功能发送多次请求后，浏览器上都会有当前登录用户的信息[用户名]，比如百度、京东、码云等。 网站登录页面的记住我功能:当用户登录成功后，勾选记住我按钮后下次再登录的时候，网站就会自动填充用户名和密码，简化用户的登录操作，多次登录就会有多次请求，他们之间也涉及到共享数据 登录页面的验证码功能:生成验证码和输入验证码点击注册这也是两次请求，这两次请求的数据之间要进行对比，相同则允许注册，不同则拒绝注册，该功能的实现也需要在同一次会话中共享数据。 通过这几个例子的讲解，相信大家对会话追踪技术已经有了一定的理解，该技术在实际开发中也非常重要。那么接下来我们就需要去学习下会话跟踪技术，在学习这些技术之前，我们需要思考:为什么现在浏览器和服务器不支持数据共享呢? 浏览器和服务器之间使用的是HTTP请求来进行数据传输 HTTP协议是无状态的，每次浏览器向服务器请求时，服务器都会将该请求视为新的请求 HTTP协议设计成无状态的目的是让每次请求之间相互独立，互不影响 请求与请求之间独立后，就无法实现多次请求之间的数据共享 分析完具体的原因后，那么该如何实现会话跟踪技术呢? 具体的实现方式有: (1)客户端会话跟踪技术：Cookie (2)服务端会话跟踪技术：Session 这两个技术都可以实现会话跟踪，它们之间最大的区别:Cookie是存储在浏览器端而Session是存储在服务器端 具体的学习思路为: CooKie的基本使用、原理、使用细节 Session的基本使用、原理、使用细节 Cookie和Session的综合案例 小结 在这节中，我们主要介绍了下什么是会话和会话跟踪技术，需要注意的是: HTTP协议是无状态的，靠HTTP协议是无法实现会话跟踪 想要实现会话跟踪，就需要用到Cookie和Session 这个Cookie和Session具体该如何使用，接下来就先从Cookie来学起。 2，Cookie 学习Cookie，我们主要解决下面几个问题: 什么是Cookie? Cookie如何来使用? Cookie是如何实现的? Cookie的使用注意事项有哪些? 2.1 Cookie的基本使用 1.概念 Cookie：客户端会话技术，将数据保存到客户端，以后每次请求都携带Cookie数据进行访问。 2.Cookie的工作流程 服务端提供了两个Servlet，分别是ServletA和ServletB 浏览器发送HTTP请求1给服务端，服务端ServletA接收请求并进行业务处理 服务端ServletA在处理的过程中可以创建一个Cookie对象并将name=zs的数据存入Cookie 服务端ServletA在响应数据的时候，会把Cookie对象响应给浏览器 浏览器接收到响应数据，会把Cookie对象中的数据存储在浏览器内存中，此时浏览器和服务端就建立了一次会话 在同一次会话中浏览器再次发送HTTP请求2给服务端ServletB，浏览器会携带Cookie对象中的所有数据 ServletB接收到请求和数据后，就可以获取到存储在Cookie对象中的数据，这样同一个会话中的多次请求之间就实现了数据共享 3.Cookie的基本使用 对于Cookie的使用，我们更关注的应该是后台代码如何操作Cookie，对于Cookie的操作主要分两大类，本别是发送Cookie和获取Cookie,对于上面这两块内容，分别该如何实现呢? 3.1 发送Cookie 创建Cookie对象，并设置数据 1Cookie cookie = new Cookie(&quot;key&quot;,&quot;value&quot;); 发送Cookie到客户端：使用response对象 1response.addCookie(cookie); 介绍完发送Cookie对应的步骤后，接下面通过一个案例来完成Cookie的发送，具体实现步骤为: 需求:在Servlet中生成Cookie对象并存入数据，然后将数据发送给浏览器 1.创建Maven项目,项目名称为cookie-demo，并在pom.xml添加依赖 2.编写Servlet类，名称为AServlet 3.在AServlet中创建Cookie对象，存入数据，发送给前端 4.启动测试，在浏览器查看Cookie对象中的值 (1)创建Maven项目cookie-demo，并在pom.xml添加依赖 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;properties&gt; &lt;maven.compiler.source&gt;8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;8&lt;/maven.compiler.target&gt;&lt;/properties&gt;&lt;dependencies&gt; &lt;!--servlet--&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;3.1.0&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;!--jsp--&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt; &lt;artifactId&gt;jsp-api&lt;/artifactId&gt; &lt;version&gt;2.2&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;!--jstl--&gt; &lt;dependency&gt; &lt;groupId&gt;jstl&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;taglibs&lt;/groupId&gt; &lt;artifactId&gt;standard&lt;/artifactId&gt; &lt;version&gt;1.1.2&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt;&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.tomcat.maven&lt;/groupId&gt; &lt;artifactId&gt;tomcat7-maven-plugin&lt;/artifactId&gt; &lt;version&gt;2.2&lt;/version&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; (2)编写Servlet类，名称为AServlet 123456789101112@WebServlet(&quot;/aServlet&quot;)public class AServlet extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; &#125; @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; this.doGet(request, response); &#125;&#125; (3)在Servlet中创建Cookie对象，存入数据，发送给前端 12345678910111213141516@WebServlet(&quot;/aServlet&quot;)public class AServlet extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; //发送Cookie //1. 创建Cookie对象 Cookie cookie = new Cookie(&quot;username&quot;,&quot;zs&quot;); //2. 发送Cookie，response response.addCookie(cookie); &#125; @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; this.doGet(request, response); &#125;&#125; （4）启动测试，在浏览器查看Cookie对象中的值 访问http://localhost:8080/cookie-demo/aServlet chrome浏览器查看Cookie的值，有两种方式,分布式: 方式一: 方式二:选中打开开发者工具或者 使用快捷键F12 或者 Ctrl+Shift+I 3.2 获取Cookie 获取客户端携带的所有Cookie，使用request对象 1Cookie[] cookies = request.getCookies(); 遍历数组，获取每一个Cookie对象：for 使用Cookie对象方法获取数据 12cookie.getName();cookie.getValue(); 介绍完获取Cookie对应的步骤后，接下面再通过一个案例来完成Cookie的获取，具体实现步骤为: 需求:在Servlet中获取前一个案例存入在Cookie对象中的数据 1.编写一个新Servlet类，名称为BServlet 2.在BServlet中使用request对象获取Cookie数组，遍历数组，从数据中获取指定名称对应的值 3.启动测试，在控制台打印出获取的值 (1)编写一个新Servlet类，名称为BServlet 123456789101112@WebServlet(&quot;/bServlet&quot;)public class BServlet extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; &#125; @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; this.doGet(request, response); &#125;&#125; （2）在BServlet中使用request对象获取Cookie数组，遍历数组，从数据中获取指定名称对应的值 12345678910111213141516171819202122232425@WebServlet(&quot;/bServlet&quot;)public class BServlet extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; //获取Cookie //1. 获取Cookie数组 Cookie[] cookies = request.getCookies(); //2. 遍历数组 for (Cookie cookie : cookies) &#123; //3. 获取数据 String name = cookie.getName(); if(&quot;username&quot;.equals(name))&#123; String value = cookie.getValue(); System.out.println(name+&quot;:&quot;+value); break; &#125; &#125; &#125; @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; this.doGet(request, response); &#125;&#125; （3）启动测试，在控制台打印出获取的值 访问http://localhost:8080/cookie-demo/bServlet 在IDEA控制台就能看到输出的结果: ==思考:==测试的时候 在访问AServlet和BServlet的中间把关闭浏览器,重启浏览器后访问BServlet能否获取到Cookie中的数据? 这个问题，我们会在Cookie的使用细节中讲，大家可以动手先试下。 小结 在这节中，我们主要讲解了Cookie的基本使用,包含两部分内容 发送Cookie: 创建Cookie对象，并设置值:Cookie cookie = new Cookie(“key”,“value”); 发送Cookie到客户端使用的是Reponse对象:response.addCookie(cookie); 获取Cookie: 使用Request对象获取Cookie数组:Cookie[] cookies = request.getCookies(); 遍历数组 获取数组中每个Cookie对象的值:cookie.getName()和cookie.getValue() 介绍完Cookie的基本使用之后，那么Cookie的底层到底是如何实现一次会话两次请求之间的数据共享呢? 2.2 Cookie的原理分析 对于Cookie的实现原理是基于HTTP协议的,其中设计到HTTP协议中的两个请求头信息: 响应头:set-cookie 请求头: cookie 前面的案例中已经能够实现，AServlet给前端发送Cookie,BServlet从request中获取Cookie的功能 对于AServlet响应数据的时候，Tomcat服务器都是基于HTTP协议来响应数据 当Tomcat发现后端要返回的是一个Cookie对象之后，Tomcat就会在响应头中添加一行数据==Set-Cookie:username=zs== 浏览器获取到响应结果后，从响应头中就可以获取到Set-Cookie对应值username=zs,并将数据存储在浏览器的内存中 浏览器再次发送请求给BServlet的时候，浏览器会自动在请求头中添加==Cookie: username=zs==发送给服务端BServlet Request对象会把请求头中cookie对应的值封装成一个个Cookie对象，最终形成一个数组 BServlet通过Request对象获取到Cookie[]后，就可以从中获取自己需要的数据 接下来，使用刚才的案例，把上述结论验证下: (1)访问AServlet对应的地址http://localhost:8080/cookie-demo/aServlet 使用Chrom浏览器打开开发者工具(F12或Crtl+Shift+I)进行查看响应头中的数据 （2）访问BServlet对应的地址`http://localhost:8080/cookie-demo/bServlet 使用Chrom浏览器打开开发者工具(F12或Crtl+Shift+I)进行查看请求头中的数据 2.3 Cookie的使用细节 在这节我们主要讲解两个知识，第一个是Cookie的存活时间，第二个是Cookie如何存储中文，首先来学习下Cookie的存活时间。 2.3.1 Cookie的存活时间 前面让大家思考过一个问题: (1)浏览器发送请求给AServlet,AServlet会响应一个存有usernanme=zs的Cookie对象给浏览器 (2)浏览器接收到响应数据将cookie存入到浏览器内存中 (3)当浏览器再次发送请求给BServlet,BServlet就可以使用Request对象获取到Cookie数据 (4)在发送请求到BServlet之前，如果把浏览器关闭再打开进行访问，BServlet能否获取到Cookie数据? 注意：浏览器关闭再打开不是指打开一个新的选显卡，而且必须是先关闭再打开，顺序不能变。 针对上面这个问题，通过演示，会发现，BServlet中无法再获取到Cookie数据，这是为什么呢? 默认情况下，Cookie存储在浏览器内存中，当浏览器关闭，内存释放，则Cookie被销毁 这个结论就印证了上面的演示效果，但是如果使用这种默认情况下的Cookie,有些需求就无法实现，比如: 上面这个网站的登录页面上有一个记住我的功能，这个功能大家都比较熟悉 第一次输入用户名和密码并勾选记住我然后进行登录 下次再登陆的时候，用户名和密码就会被自动填充，不需要再重新输入登录 比如记住我这个功能需要记住用户名和密码一个星期，那么使用默认情况下的Cookie就会出现问题 因为默认情况，浏览器一关，Cookie就会从浏览器内存中删除，对于记住我功能就无法实现 所以我们现在就遇到一个难题是如何将Cookie持久化存储? Cookie其实已经为我们提供好了对应的API来完成这件事，这个API就是setMaxAge, 设置Cookie存活时间 1setMaxAge(int seconds) 参数值为: 1.正数：将Cookie写入浏览器所在电脑的硬盘，持久化存储。到时间自动删除 2.负数：默认值，Cookie在当前浏览器内存中，当浏览器关闭，则Cookie被销毁 3.零：删除对应Cookie 接下来，咱们就在AServlet中去设置Cookie的存活时间。 12345678910111213141516171819@WebServlet(&quot;/aServlet&quot;)public class AServlet extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; //发送Cookie //1. 创建Cookie对象 Cookie cookie = new Cookie(&quot;username&quot;,&quot;zs&quot;); //设置存活时间 ，1周 7天 cookie.setMaxAge(60*60*24*7); //易阅读，需程序计算 //cookie.setMaxAge(604800); //不易阅读(可以使用注解弥补)，程序少进行一次计算 //2. 发送Cookie，response response.addCookie(cookie); &#125; @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; this.doGet(request, response); &#125;&#125; 修改完代码后，启动测试，访问http://localhost:8080/cookie-demo/aServlet 访问一个AServlet后，把浏览器关闭重启后，再去访问http://localhost:8080/cookie-demo/bServet,能在控制台打印出username:zs,说明Cookie没有随着浏览器关闭而被销毁 通过浏览器查看Cookie的内容，会发现Cookie的相关信息 2.3.2 Cookie存储中文 首先，先来演示一个效果，将之前username=zs的值改成username=张三，把汉字张三存入到Cookie中，看是什么效果: 123456789101112131415161718@WebServlet(&quot;/aServlet&quot;)public class AServlet extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; //发送Cookie String value = &quot;张三&quot;; Cookie cookie = new Cookie(&quot;username&quot;,value); //设置存活时间 ，1周 7天 cookie.setMaxAge(60*60*24*7); //2. 发送Cookie，response response.addCookie(cookie); &#125; @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; this.doGet(request, response); &#125;&#125; 启动访问测试，访问http://localhost:8080/cookie-demo/aServlet会发现浏览器会提示错误信息 通过上面的案例演示，我们得到一个结论: Cookie不能直接存储中文 Cookie不能存储中文，但是如果有这方面的需求，这个时候该如何解决呢? 这个时候，我们可以使用之前学过的一个知识点叫URL编码，所以如果需要存储中文，就需要进行转码，具体的实现思路为: 1.在AServlet中对中文进行URL编码，采用URLEncoder.encode()，将编码后的值存入Cookie中 2.在BServlet中获取Cookie中的值,获取的值为URL编码后的值 3.将获取的值在进行URL解码,采用URLDecoder.decode()，就可以获取到对应的中文值 (1)在AServlet中对中文进行URL编码 12345678910111213141516171819202122@WebServlet(&quot;/aServlet&quot;)public class AServlet extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; //发送Cookie String value = &quot;张三&quot;; //对中文进行URL编码 value = URLEncoder.encode(value, &quot;UTF-8&quot;); System.out.println(&quot;存储数据：&quot;+value); //将编码后的值存入Cookie中 Cookie cookie = new Cookie(&quot;username&quot;,value); //设置存活时间 ，1周 7天 cookie.setMaxAge(60*60*24*7); //2. 发送Cookie，response response.addCookie(cookie); &#125; @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; this.doGet(request, response); &#125;&#125; (2)在BServlet中获取值，并对值进行解码 123456789101112131415161718192021222324252627@WebServlet(&quot;/bServlet&quot;)public class BServlet extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; //获取Cookie //1. 获取Cookie数组 Cookie[] cookies = request.getCookies(); //2. 遍历数组 for (Cookie cookie : cookies) &#123; //3. 获取数据 String name = cookie.getName(); if(&quot;username&quot;.equals(name))&#123; String value = cookie.getValue();//获取的是URL编码后的值 %E5%BC%A0%E4%B8%89 //URL解码 value = URLDecoder.decode(value,&quot;UTF-8&quot;); System.out.println(name+&quot;:&quot;+value);//value解码后为 张三 break; &#125; &#125; &#125; @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; this.doGet(request, response); &#125;&#125; 至此，我们就可以将中文存入Cookie中进行使用。 小结 Cookie的使用细节中，我们讲了Cookie的存活时间和存储中文: 存活时间，需要掌握setMaxAage()API的使用 存储中文，需要掌握URL编码和解码的使用 3，Session Cookie已经能完成一次会话多次请求之间的数据共享，之前我们还提到过Session也可以实现，那么: 什么是Session? Session如何来使用? Session是如何实现的? Session的使用注意事项有哪些? 3.1 Session的基本使用 1.概念 Session：服务端会话跟踪技术：将数据保存到服务端。 Session是存储在服务端而Cookie是存储在客户端 存储在客户端的数据容易被窃取和截获，存在很多不安全的因素 存储在服务端的数据相比于客户端来说就更安全 2.Session的工作流程 在服务端的AServlet获取一个Session对象，把数据存入其中 在服务端的BServlet获取到相同的Session对象，从中取出数据 就可以实现一次会话中多次请求之间的数据共享了 现在最大的问题是如何保证AServlet和BServlet使用的是同一个Session对象(在原理分析会讲解)? 3.Session的基本使用 在JavaEE中提供了HttpSession接口，来实现一次会话的多次请求之间数据共享功能。 具体的使用步骤为: 获取Session对象,使用的是request对象 1HttpSession session = request.getSession(); Session对象提供的功能: 存储数据到 session 域中 1void setAttribute(String name, Object o) 根据 key，获取值 1Object getAttribute(String name) 根据 key，删除该键值对 1void removeAttribute(String name) 介绍完Session相关的API后，接下来通过一个案例来完成对Session的使用，具体实现步骤为: 需求:在一个Servlet中往Session中存入数据，在另一个Servlet中获取Session中存入的数据 1.创建名为SessionDemo1的Servlet类 2.创建名为SessionDemo2的Servlet类 3.在SessionDemo1的方法中:获取Session对象、存储数据 4.在SessionDemo2的方法中:获取Session对象、获取数据 5.启动测试 (1)创建名为SessionDemo1的Servlet类 123456789101112@WebServlet(&quot;/demo1&quot;)public class SessionDemo1 extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; &#125; @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; this.doGet(request, response); &#125;&#125; (2)创建名为SessionDemo2的Servlet类 123456789101112@WebServlet(&quot;/demo2&quot;)public class SessionDemo2 extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; &#125; @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; this.doGet(request, response); &#125;&#125; (3)SessionDemo1:获取Session对象、存储数据 12345678910111213141516@WebServlet(&quot;/demo1&quot;)public class SessionDemo1 extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; //存储到Session中 //1. 获取Session对象 HttpSession session = request.getSession(); //2. 存储数据 session.setAttribute(&quot;username&quot;,&quot;zs&quot;); &#125; @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; this.doGet(request, response); &#125;&#125; (4)SessionDemo2:获取Session对象、获取数据 1234567891011121314151617@WebServlet(&quot;/demo2&quot;)public class SessionDemo2 extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; //获取数据，从session中 //1. 获取Session对象 HttpSession session = request.getSession(); //2. 获取数据 Object username = session.getAttribute(&quot;username&quot;); System.out.println(username); &#125; @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; this.doGet(request, response); &#125;&#125; (5)启动测试， 先访问http://localhost:8080/cookie-demo/demo1,将数据存入Session 在访问http://localhost:8080/cookie-demo/demo2,从Session中获取数据 查看控制台 通过案例的效果，能看到Session是能够在一次会话中两次请求之间共享数据。 小结 至此Session的基本使用就已经完成了，重点要掌握的是: Session的获取 1HttpSession session = request.getSession(); Session常用方法的使用 12void setAttribute(String name, Object o)Object getAttribute(String name) **注意:**Session中可以存储的是一个Object类型的数据，也就是说Session中可以存储任意数据类型。 介绍完Session的基本使用之后，那么Session的底层到底是如何实现一次会话两次请求之间的数据共享呢? 3.2 Session的原理分析 Session是基于Cookie实现的 这句话其实不太能详细的说明Session的底层实现，接下来，咱们一步步来分析下Session的具体实现原理: (1)前提条件 Session要想实现一次会话多次请求之间的数据共享，就必须要保证多次请求获取Session的对象是同一个。 那么它们是一个对象么？要验证这个结论也很简单，只需要在上面案例中的两个Servlet中分别打印下Session对象 SessionDemo1 1234567891011121314151617@WebServlet(&quot;/demo1&quot;)public class SessionDemo1 extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; //存储到Session中 //1. 获取Session对象 HttpSession session = request.getSession(); System.out.println(session); //2. 存储数据 session.setAttribute(&quot;username&quot;,&quot;zs&quot;); &#125; @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; this.doGet(request, response); &#125;&#125; SessionDemo2 123456789101112131415161718@WebServlet(&quot;/demo2&quot;)public class SessionDemo2 extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; //获取数据，从session中 //1. 获取Session对象 HttpSession session = request.getSession(); System.out.println(session); //2. 获取数据 Object username = session.getAttribute(&quot;username&quot;); System.out.println(username); &#125; @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; this.doGet(request, response); &#125;&#125; 启动测试，分别访问 http://localhost:8080/cookie-demo/demo1 http://localhost:8080/cookie-demo/demo2 通过打印可以得到如下结论: 两个Servlet类中获取的Session对象是同一个 把demo1和demo2请求刷新多次，控制台最终打印的结果都是同一个 那么问题又来了，如果新开一个浏览器，访问demo1或者demo2,打印在控制台的Session还是同一个对象么? 注意:在一台电脑上演示的时候，如果是相同的浏览器必须要把浏览器全部关掉重新打开，才算新开的一个浏览器。 当然也可以使用不同的浏览器进行测试，就不需要把之前的浏览器全部关闭。 测试的结果：如果是不同浏览器或者重新打开浏览器后，打印的Session就不一样了。 所以Session实现的也是一次会话中的多次请求之间的数据共享。每次会话的session有一个 ID 那么最主要的问题就来了，Session是如何保证在一次会话中获取的Session对象是同一个呢? (1)demo1在第一次获取session对象的时候，session对象会有一个唯一的标识，假如是id:10 (2)demo1在session中存入其他数据并处理完成所有业务后，需要通过Tomcat服务器响应结果给浏览器 (3)Tomcat服务器发现业务处理中使用了session对象，就会把session的唯一标识id:10当做一个cookie，添加Set-Cookie:JESSIONID=10到响应头中，并响应给浏览器 (4)浏览器接收到响应结果后，会把响应头中的coookie数据存储到浏览器的内存中 (5)浏览器在同一会话中访问demo2的时候，会把cookie中的数据按照cookie: JESSIONID=10的格式添加到请求头中并发送给服务器Tomcat (6)demo2获取到请求后，从请求头中就读取cookie中的JSESSIONID值为10，然后就会到服务器内存中寻找id:10的session对象，如果找到了，就直接返回该对象，如果没有则新创建一个session对象 (7)关闭打开浏览器后，因为浏览器的cookie已被销毁，所以就没有JESSIONID的数据，服务端获取到的session就是一个全新的session对象 至此，Session是基于Cookie来实现的这就话，我们就解释完了，接下来通过实例来演示下: (1)使用chrome浏览器访问http://localhost:8080/cookie-demo/demo1,打开开发者模式(F12或Ctrl+Shift+I),查看==响应头(Response Headers)==数据: (2)使用chrome浏览器再次访问http://localhost:8080/cookie-demo/demo2，查看==请求头(Request Headers)==数据: 小结 介绍完Session的原理，我们只需要记住 Session是基于Cookie来实现的 3.3 Session的使用细节 这节我们会主要讲解两个知识，第一个是Session的钝化和活化，第二个是Session的销毁，首先来学习什么是Session的钝化和活化？ 3.3.1 Session钝化与活化 首先需要大家思考的问题是: 服务器重启后，Session中的数据是否还在? 要想回答这个问题，我们可以先看下下面这幅图， (1)服务器端AServlet和BServlet共用的session对象应该是存储在服务器的内存中 (2)服务器重新启动后，内存中的数据应该是已经被释放，对象也应该都销毁了 所以session数据应该也已经不存在了。但是如果session不存在会引发什么问题呢? 举个例子说明下， (1)用户把需要购买的商品添加到购物车，因为要实现同一个会话多次请求数据共享，所以假设把数据存入Session对象中 (2)用户正要付钱的时候接到一个电话，付钱的动作就搁浅了 (3)正在用户打电话的时候，购物网站因为某些原因需要重启 (4)重启后session数据被销毁，购物车中的商品信息也就会随之而消失 (5)用户想再次发起支付，就会出为问题 所以说对于session的数据，我们应该做到就算服务器重启了，也应该能把数据保存下来才对。 分析了这么多，那么Tomcat服务器在重启的时候，session数据到底会不会保存以及是如何保存的，我们可以通过实际案例来演示下: 注意:这里所说的关闭和启动应该要确保是正常的关闭和启动。 那如何才是正常关闭Tomcat服务器呢? 需要使用命令行的方式来启动和停止Tomcat服务器: 启动:进入到项目pom.xml所在目录，执行tomcat7:run 停止:在启动的命令行界面，输入ctrl+c 有了上述两个正常启动和关闭的方式后，接下来的测试流程是: (1)先启动Tomcat服务器 (2)访问http://localhost:8080/cookie-demo/demo1将数据存入session中 (3)正确停止Tomcat服务器 (4)再次重新启动Tomcat服务器 (5)访问http://localhost:8080/cookie-demo/demo2 查看是否能获取到session中的数据 经过测试，会发现只要服务器是正常关闭和启动，session中的数据是可以被保存下来的。 那么Tomcat服务器到底是如何做到的呢? 具体的原因就是:Session的钝化和活化: 钝化：在服务器正常关闭后，Tomcat会自动将Session数据写入硬盘的文件中 钝化的数据路径为:项目目录\\target\\tomcat\\work\\Tomcat\\localhost\\项目名称\\SESSIONS.ser 活化：再次启动服务器后，从文件中加载数据到Session中 数据加载到Session中后，路径中的SESSIONS.ser文件会被删除掉 对于上述的整个过程，大家只需要了解下即可。因为所有的过程都是Tomcat自己完成的，不需要我们参与。 小结 Session的钝化和活化介绍完后，需要我们注意的是: session数据存储在服务端，服务器重启后，session数据会被保存 浏览器被关闭启动后，重新建立的连接就已经是一个全新的会话，获取的session数据也是一个新的对象 session的数据要想共享，浏览器不能关闭，所以session数据不能长期保存数据 cookie是存储在客户端，是可以长期保存 3.3.2 Session销毁 session的销毁会有两种方式: 默认情况下，无操作，30分钟自动销毁 对于这个失效时间，是可以通过配置进行修改的 在项目的web.xml中配置 12345678910&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd&quot; version=&quot;3.1&quot;&gt; &lt;session-config&gt; &lt;session-timeout&gt;100&lt;/session-timeout&gt; &lt;/session-config&gt;&lt;/web-app&gt; 如果没有配置，默认是30分钟，默认值是在Tomcat的web.xml配置文件中写死的 调用Session对象的invalidate()进行销毁 在SessionDemo2类中添加session销毁的方法 12345678910111213141516171819202122@WebServlet(&quot;/demo2&quot;)public class SessionDemo2 extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; //获取数据，从session中 //1. 获取Session对象 HttpSession session = request.getSession(); System.out.println(session); // 销毁 session.invalidate(); //2. 获取数据 Object username = session.getAttribute(&quot;username&quot;); System.out.println(username); &#125; @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; this.doGet(request, response); &#125;&#125; 启动访问测试，先访问demo1将数据存入到session，再次访问demo2从session中获取数据 该销毁方法一般会在用户退出的时候，需要将session销毁掉。 Cookie和Session小结 Cookie 和 Session 都是来完成一次会话内多次请求间数据共享的。 所需两个对象放在一块，就需要思考: Cookie和Session的区别是什么? Cookie和Session的应用场景分别是什么? 区别: 存储位置：Cookie 是将数据存储在客户端，Session 将数据存储在服务端 安全性：Cookie不安全，Session安全 数据大小：Cookie最大3KB，Session无大小限制 存储时间：Cookie可以通过setMaxAge()长期存储，Session默认30分钟 服务器性能：Cookie不占服务器资源，Session占用服务器资源 应用场景: 购物车:使用Cookie来存储 以登录用户的名称展示:使用Session来存储 记住我功能:使用Cookie来存储 验证码:使用session来存储 结论 Cookie是用来保证用户在未登录情况下的身份识别 Session是用来保存用户登录后的数据 介绍完Cookie和Session以后，具体用哪个还是需要根据具体的业务进行具体分析。 4，用户登录注册案例 4.1 需求分析 需求说明： 完成用户登录功能，如果用户勾选“记住用户” ，则下次访问登录页面自动填充用户名密码 完成注册功能，并实现验证码功能 4.2 用户登录功能 需求: 用户登录成功后，跳转到列表页面，并在页面上展示当前登录的用户名称 用户登录失败后，跳转回登录页面，并在页面上展示对应的错误信息 实现流程分析 (1)前端通过表单发送请求和数据给Web层的LoginServlet (2)在LoginServlet中接收请求和数据[用户名和密码] (3)LoginServlet接收到请求和数据后，调用Service层完成根据用户名和密码查询用户对象 (4)在Service层需要编写UserService类，在类中实现login方法，方法中调用Dao层的UserMapper (5)在UserMapper接口中，声明一个根据用户名和密码查询用户信息的方法 (6)Dao层把数据查询出来以后，将返回数据封装到User对象，将对象交给Service层 (7)Service层将数据返回给Web层 (8)Web层获取到User对象后，判断User对象，如果为Null,则将错误信息响应给登录页面，如果不为Null，则跳转到列表页面，并把当前登录用户的信息存入Session携带到列表页面。 具体实现 (1)完成Dao层的代码编写 (1.1)将04-资料\\1. 登录注册案例\\2. MyBatis环境\\UserMapper.java放到com.itheima.mapper`包下: 12345678910111213141516171819202122232425public interface UserMapper &#123; /** * 根据用户名和密码查询用户对象 * @param username * @param password * @return */ @Select(&quot;select * from tb_user where username = #&#123;username&#125; and password = #&#123;password&#125;&quot;) User select(@Param(&quot;username&quot;) String username,@Param(&quot;password&quot;) String password); /** * 根据用户名查询用户对象 * @param username * @return */ @Select(&quot;select * from tb_user where username = #&#123;username&#125;&quot;) User selectByUsername(String username); /** * 添加用户 * @param user */ @Insert(&quot;insert into tb_user values(null,#&#123;username&#125;,#&#123;password&#125;)&quot;) void add(User user);&#125; (1.2)将04-资料\\1. 登录注册案例\\2. MyBatis环境\\User.java放到com.itheima.pojo包下: 123456789101112131415161718192021222324252627282930313233343536373839public class User &#123; private Integer id; private String username; private String password; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; &#125; @Override public String toString() &#123; return &quot;User&#123;&quot; + &quot;id=&quot; + id + &quot;, username=&#x27;&quot; + username + &#x27;\\&#x27;&#x27; + &quot;, password=&#x27;&quot; + password + &#x27;\\&#x27;&#x27; + &#x27;&#125;&#x27;; &#125;&#125; (1.3)将04-资料\\1. 登录注册案例\\2. MyBatis环境\\UserMapper.xml放入到resources/com/itheima/mapper`目录下: 1234567&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.itheima.mapper.UserMapper&quot;&gt;&lt;/mapper&gt; (2)完成Service层的代码编写 (2.1)在com.itheima.service包下，创建UserService类 12345678910111213141516171819202122public class UserService &#123; //1.使用工具类获取SqlSessionFactory SqlSessionFactory factory = SqlSessionFactoryUtils.getSqlSessionFactory(); /** * 登录方法 * @param username * @param password * @return */ public User login(String username,String password)&#123; //2. 获取SqlSession SqlSession sqlSession = factory.openSession(); //3. 获取UserMapper UserMapper mapper = sqlSession.getMapper(UserMapper.class); //4. 调用方法 User user = mapper.select(username, password); //释放资源 sqlSession.close(); return user; &#125;&#125; (3)完成页面和Web层的代码编写 (3.1)将04-资料\\1. 登录注册案例\\1. 静态页面拷贝到项目的webapp目录下: (3.2)将login.html内容修改成login.jsp 123456789101112131415161718192021222324252627&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;login&lt;/title&gt; &lt;link href=&quot;css/login.css&quot; rel=&quot;stylesheet&quot;&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;loginDiv&quot; style=&quot;height: 350px&quot;&gt; &lt;form action=&quot;/brand-demo/loginServlet&quot; method=&quot;post&quot; id=&quot;form&quot;&gt; &lt;h1 id=&quot;loginMsg&quot;&gt;LOGIN IN&lt;/h1&gt; &lt;div id=&quot;errorMsg&quot;&gt;用户名或密码不正确&lt;/div&gt; &lt;p&gt;Username:&lt;input id=&quot;username&quot; name=&quot;username&quot; type=&quot;text&quot;&gt;&lt;/p&gt; &lt;p&gt;Password:&lt;input id=&quot;password&quot; name=&quot;password&quot; type=&quot;password&quot;&gt;&lt;/p&gt; &lt;p&gt;Remember:&lt;input id=&quot;remember&quot; name=&quot;remember&quot; type=&quot;checkbox&quot;&gt;&lt;/p&gt; &lt;div id=&quot;subDiv&quot;&gt; &lt;input type=&quot;submit&quot; class=&quot;button&quot; value=&quot;login up&quot;&gt; &lt;input type=&quot;reset&quot; class=&quot;button&quot; value=&quot;reset&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;a href=&quot;register.html&quot;&gt;没有账号？&lt;/a&gt; &lt;/div&gt; &lt;/form&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; (3.3)创建LoginServlet类 1234567891011121314151617181920212223242526272829303132333435363738@WebServlet(&quot;/loginServlet&quot;)public class LoginServlet extends HttpServlet &#123; private UserService service = new UserService(); @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; //1. 获取用户名和密码 String username = request.getParameter(&quot;username&quot;); String password = request.getParameter(&quot;password&quot;); //2. 调用service查询 User user = service.login(username, password); //3. 判断 if(user != null)&#123; //登录成功，跳转到查询所有的BrandServlet //将登陆成功后的user对象，存储到session HttpSession session = request.getSession(); session.setAttribute(&quot;user&quot;,user); String contextPath = request.getContextPath(); response.sendRedirect(contextPath+&quot;/selectAllServlet&quot;); &#125;else &#123; // 登录失败, // 存储错误信息到request request.setAttribute(&quot;login_msg&quot;,&quot;用户名或密码错误&quot;); // 跳转到login.jsp request.getRequestDispatcher(&quot;/login.jsp&quot;).forward(request,response); &#125; &#125; @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; this.doGet(request, response); &#125;&#125; (3.4)在brand.jsp中标签下添加欢迎当前用户的提示信息: 1&lt;h1&gt;$&#123;user.username&#125;,欢迎您&lt;/h1&gt; (3.5) 修改login.jsp，将错误信息使用EL表达式来获取 12修改前内容:&lt;div id=&quot;errorMsg&quot;&gt;用户名或密码不正确&lt;/div&gt;修改后内容: &lt;div id=&quot;errorMsg&quot;&gt;$&#123;login_msg&#125;&lt;/div&gt; (4)启动，访问测试 (4.1) 进入登录页面，输入错误的用户名或密码 (4.2)输入正确的用户和密码信息 小结 在LoginServlet中，将登录成功的用户数据存入session中，方法在列表页面中获取当前登录用户信息进行展示 在LoginServlet中，将登录失败的错误信息存入到request中，如果存入到session中就会出现这次会话的所有请求都有登录失败的错误信息，这个是不需要的，所以不用存入到session中 4.3 记住我-设置Cookie 需求: 如果用户勾选“记住用户” ，则下次访问登陆页面自动填充用户名密码。这样可以提升用户的体验。 对应上面这个需求，最大的问题就是: 如何自动填充用户名和密码? 实现流程分析 因为记住我功能要实现的效果是，就算用户把浏览器关闭过几天再来访问也能自动填充，所以需要将登陆信息存入一个可以长久保存，并且能够在浏览器关闭重新启动后依然有效的地方，就是我们前面讲的Cookie,所以: 将用户名和密码写入Cookie中，并且持久化存储Cookie,下次访问浏览器会自动携带Cookie 在页面获取Cookie数据后，设置到用户名和密码框中 何时写入Cookie? 用户必须登陆成功后才需要写 用户必须在登录页面勾选了记住我的复选框 (1)前端需要在发送请求和数据的时候，多携带一个用户是否勾选Remember的数据 (2)LoginServlet获取到数据后，调用Service完成用户名和密码的判定 (3)登录成功，并且用户在前端勾选了记住我，需要往Cookie中写入用户名和密码的数据，并设置Cookie存活时间 (4)设置成功后，将数据响应给前端 具体实现 (1)在login.jsp为复选框设置值 123456789101112131415161718192021222324252627&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;login&lt;/title&gt; &lt;link href=&quot;css/login.css&quot; rel=&quot;stylesheet&quot;&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;loginDiv&quot; style=&quot;height: 350px&quot;&gt; &lt;form action=&quot;/brand-demo/loginServlet&quot; method=&quot;post&quot; id=&quot;form&quot;&gt; &lt;h1 id=&quot;loginMsg&quot;&gt;LOGIN IN&lt;/h1&gt; &lt;div id=&quot;errorMsg&quot;&gt;$&#123;login_msg&#125;&lt;/div&gt; &lt;p&gt;Username:&lt;input id=&quot;username&quot; name=&quot;username&quot; type=&quot;text&quot;&gt;&lt;/p&gt; &lt;p&gt;Password:&lt;input id=&quot;password&quot; name=&quot;password&quot; type=&quot;password&quot;&gt;&lt;/p&gt; &lt;p&gt;Remember:&lt;input id=&quot;remember&quot; name=&quot;remember&quot; value=&quot;1&quot; type=&quot;checkbox&quot;&gt;&lt;/p&gt; &lt;div id=&quot;subDiv&quot;&gt; &lt;input type=&quot;submit&quot; class=&quot;button&quot; value=&quot;login up&quot;&gt; &lt;input type=&quot;reset&quot; class=&quot;button&quot; value=&quot;reset&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;a href=&quot;register.html&quot;&gt;没有账号？&lt;/a&gt; &lt;/div&gt; &lt;/form&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; (2)在LoginServlet获取复选框的值并在登录成功后进行设置Cookie 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657@WebServlet(&quot;/loginServlet&quot;)public class LoginServlet extends HttpServlet &#123; private UserService service = new UserService(); @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; //1. 获取用户名和密码 String username = request.getParameter(&quot;username&quot;); String password = request.getParameter(&quot;password&quot;); //获取复选框数据 String remember = request.getParameter(&quot;remember&quot;); //2. 调用service查询 User user = service.login(username, password); //3. 判断 if(user != null)&#123; //登录成功，跳转到查询所有的BrandServlet //判断用户是否勾选记住我，字符串写前面是为了避免出现空指针异常 if(&quot;1&quot;.equals(remember))&#123; //勾选了，发送Cookie //1. 创建Cookie对象 Cookie c_username = new Cookie(&quot;username&quot;,username); Cookie c_password = new Cookie(&quot;password&quot;,password); // 设置Cookie的存活时间 c_username.setMaxAge( 60 * 60 * 24 * 7); c_password.setMaxAge( 60 * 60 * 24 * 7); //2. 发送 response.addCookie(c_username); response.addCookie(c_password); &#125; //将登陆成功后的user对象，存储到session HttpSession session = request.getSession(); session.setAttribute(&quot;user&quot;,user); String contextPath = request.getContextPath(); response.sendRedirect(contextPath+&quot;/selectAllServlet&quot;); &#125;else &#123; // 登录失败, // 存储错误信息到request request.setAttribute(&quot;login_msg&quot;,&quot;用户名或密码错误&quot;); // 跳转到login.jsp request.getRequestDispatcher(&quot;/login.jsp&quot;).forward(request,response); &#125; &#125; @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; this.doGet(request, response); &#125;&#125; (3)启动访问测试， 只有当前用户名和密码输入正确，并且勾选了Remeber的复选框，在响应头中才可以看得cookie的相关数据 4.4 记住我-获取Cookie 需求 登录成功并勾选了Remeber后，后端返回给前端的Cookie数据就已经存储好了，接下来就需要在页面获取Cookie中的数据，并把数据设置到登录页面的用户名和密码框中。 如何在页面直接获取Cookie中的值呢? 实现流程分析 在页面可以使用EL表达式，${cookie.key.value} key:指的是存储在cookie中的键名称 (1)在login.jsp用户名的表单输入框使用value值给表单元素添加默认值，value可以使用$&#123;cookie.username.value&#125; (2)在login.jsp密码的表单输入框使用value值给表单元素添加默认值，value可以使用$&#123;cookie.password.value&#125; 具体实现 (1)修改login.jsp页面 12345678910111213141516171819202122232425262728&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;login&lt;/title&gt; &lt;link href=&quot;css/login.css&quot; rel=&quot;stylesheet&quot;&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;loginDiv&quot; style=&quot;height: 350px&quot;&gt; &lt;form action=&quot;/brand-demo/loginServlet&quot; method=&quot;post&quot; id=&quot;form&quot;&gt; &lt;h1 id=&quot;loginMsg&quot;&gt;LOGIN IN&lt;/h1&gt; &lt;div id=&quot;errorMsg&quot;&gt;$&#123;login_msg&#125;&lt;/div&gt; &lt;p&gt;Username:&lt;input id=&quot;username&quot; name=&quot;username&quot; value=&quot;$&#123;cookie.username.value&#125;&quot; type=&quot;text&quot;&gt;&lt;/p&gt; &lt;p&gt;Password:&lt;input id=&quot;password&quot; name=&quot;password&quot; value=&quot;$&#123;cookie.password.value&#125;&quot; type=&quot;password&quot;&gt;&lt;/p&gt; &lt;p&gt;Remember:&lt;input id=&quot;remember&quot; name=&quot;remember&quot; value=&quot;1&quot; type=&quot;checkbox&quot;&gt;&lt;/p&gt; &lt;div id=&quot;subDiv&quot;&gt; &lt;input type=&quot;submit&quot; class=&quot;button&quot; value=&quot;login up&quot;&gt; &lt;input type=&quot;reset&quot; class=&quot;button&quot; value=&quot;reset&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;a href=&quot;register.html&quot;&gt;没有账号？&lt;/a&gt; &lt;/div&gt; &lt;/form&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 访问测试，重新访问登录页面，就可以看得用户和密码已经被填充。 4.5 用户注册功能 需求 注册功能：保存用户信息到数据库 验证码功能 展示验证码：展示验证码图片，并可以点击切换 校验验证码：验证码填写不正确，则注册失败 实现流程分析 (1)前端通过表单发送请求和数据给Web层的RegisterServlet (2)在RegisterServlet中接收请求和数据[用户名和密码] (3)RegisterServlet接收到请求和数据后，调用Service层完成用户信息的保存 (4)在Service层需要编写UserService类，在类中实现register方法，需要判断用户是否已经存在，如果不存在，则完成用户数据的保存 (5)在UserMapper接口中，声明两个方法，一个是根据用户名查询用户信息方法，另一个是保存用户信息方法 (6)在UserService类中保存成功则返回true，失败则返回false,将数据返回给Web层 (7)Web层获取到结果后，如果返回的是true,则提示注册成功，并转发到登录页面，如果返回false则提示用户名已存在并转发到注册页面 具体实现 (1)Dao层代码参考资料中的内容完成 (2)编写Service层代码 123456789101112131415161718192021222324252627public class UserService &#123; //1.使用工具类获取SqlSessionFactory SqlSessionFactory factory = SqlSessionFactoryUtils.getSqlSessionFactory(); /** * 注册方法 * @return */ public boolean register(User user)&#123; //2. 获取SqlSession SqlSession sqlSession = factory.openSession(); //3. 获取UserMapper UserMapper mapper = sqlSession.getMapper(UserMapper.class); //4. 判断用户名是否存在 User u = mapper.selectByUsername(user.getUsername()); if(u == null)&#123; // 用户名不存在，注册 mapper.add(user); sqlSession.commit(); &#125; sqlSession.close(); return u == null; &#125;&#125; (3)完成页面和Web层的代码编写 (3.1)将register.html内容修改成register.jsp 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;欢迎注册&lt;/title&gt; &lt;link href=&quot;css/register.css&quot; rel=&quot;stylesheet&quot;&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;form-div&quot;&gt; &lt;div class=&quot;reg-content&quot;&gt; &lt;h1&gt;欢迎注册&lt;/h1&gt; &lt;span&gt;已有帐号？&lt;/span&gt; &lt;a href=&quot;login.html&quot;&gt;登录&lt;/a&gt; &lt;/div&gt; &lt;form id=&quot;reg-form&quot; action=&quot;/brand-demo/registerServlet&quot; method=&quot;post&quot;&gt; &lt;table&gt; &lt;tr&gt; &lt;td&gt;用户名&lt;/td&gt; &lt;td class=&quot;inputs&quot;&gt; &lt;input name=&quot;username&quot; type=&quot;text&quot; id=&quot;username&quot;&gt; &lt;br&gt; &lt;span id=&quot;username_err&quot; class=&quot;err_msg&quot; style=&quot;display:none&quot;&gt;用户名不太受欢迎&lt;/span&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;密码&lt;/td&gt; &lt;td class=&quot;inputs&quot;&gt; &lt;input name=&quot;password&quot; type=&quot;password&quot; id=&quot;password&quot;&gt; &lt;br&gt; &lt;span id=&quot;password_err&quot; class=&quot;err_msg&quot; style=&quot;display: none&quot;&gt;密码格式有误&lt;/span&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;验证码&lt;/td&gt; &lt;td class=&quot;inputs&quot;&gt; &lt;input name=&quot;checkCode&quot; type=&quot;text&quot; id=&quot;checkCode&quot;&gt; &lt;img src=&quot;imgs/a.jpg&quot;&gt; &lt;a href=&quot;#&quot; id=&quot;changeImg&quot; &gt;看不清？&lt;/a&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;div class=&quot;buttons&quot;&gt; &lt;input value=&quot;注 册&quot; type=&quot;submit&quot; id=&quot;reg_btn&quot;&gt; &lt;/div&gt; &lt;br class=&quot;clear&quot;&gt; &lt;/form&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; (3.2)编写RegisterServlet 123456789101112131415161718192021222324252627282930313233343536@WebServlet(&quot;/registerServlet&quot;)public class RegisterServlet extends HttpServlet &#123; private UserService service = new UserService(); @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; //1. 获取用户名和密码数据 String username = request.getParameter(&quot;username&quot;); String password = request.getParameter(&quot;password&quot;); User user = new User(); user.setUsername(username); user.setPassword(password); //2. 调用service 注册 boolean flag = service.register(user); //3. 判断注册成功与否 if(flag)&#123; //注册功能，跳转登陆页面 request.setAttribute(&quot;register_msg&quot;,&quot;注册成功，请登录&quot;); request.getRequestDispatcher(&quot;/login.jsp&quot;).forward(request,response); &#125;else &#123; //注册失败，跳转到注册页面 request.setAttribute(&quot;register_msg&quot;,&quot;用户名已存在&quot;); request.getRequestDispatcher(&quot;/register.jsp&quot;).forward(request,response); &#125; &#125; @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; this.doGet(request, response); &#125;&#125; (3.3)需要在页面上展示后台返回的错误信息，需要修改register.jsp 12修改前:&lt;span id=&quot;username_err&quot; class=&quot;err_msg&quot; style=&quot;display:none&quot;&gt;用户名不太受欢迎&lt;/span&gt;修改后:&lt;span id=&quot;username_err&quot; class=&quot;err_msg&quot;&gt;$&#123;register_msg&#125;&lt;/span&gt; (3.4)如果注册成功，需要把成功信息展示在登录页面，所以也需要修改login.jsp 12修改前:&lt;div id=&quot;errorMsg&quot;&gt;$&#123;login_msg&#125;&lt;/div&gt;修改后:&lt;div id=&quot;errorMsg&quot;&gt;$&#123;login_msg&#125; $&#123;register_msg&#125;&lt;/div&gt; (3.5)修改login.jsp，将注册跳转地址修改为register.jsp 12修改前：&lt;a href=&quot;register.html&quot;&gt;没有账号？&lt;/a&gt;修改后: &lt;a href=&quot;register.jsp&quot;&gt;没有账号？&lt;/a&gt; (3.6)启动测试， 如果是注册的用户信息已经存在: 如果注册的用户信息不存在，注册成功: 4.6 验证码-展示 需求分析 展示验证码：展示验证码图片，并可以点击切换 验证码的生成是通过工具类来实现的，具体的工具类参考 04-资料\\1. 登录注册案例\\CheckCodeUtil.java 在该工具类中编写main方法进行测试: 12345678public static void main(String[] args) throws IOException &#123; //生成验证码的图片位置 OutputStream fos = new FileOutputStream(&quot;d://a.jpg&quot;); //checkCode为最终验证码的数据 String checkCode = CheckCodeUtil.outputVerifyImage(100, 50, fos, 4); System.out.println(checkCode);&#125; 生成完验证码以后，我们就可以知晓: 验证码就是使用Java代码生成的一张图片 验证码的作用:防止机器自动注册，攻击服务器 实现流程分析 (1)前端发送请求给CheckCodeServlet (2)CheckCodeServlet接收到请求后，生成验证码图片，将图片用Reponse对象的输出流写回到前端 思考:如何将图片写回到前端浏览器呢? (1)Java中已经有工具类生成验证码图片，测试类中只是把图片生成到磁盘上 (2)生成磁盘的过程中使用的是OutputStream流，如何把这个图片生成在页面呢? (3)前面在将Reponse对象的时候，它有一个方法可以获取其字节输出流，getOutputStream() (4)综上所述，我们可以把写往磁盘的流对象更好成Response的字节流，即可完成图片响应给前端 具体实现 (1)修改Register.jsp页面，将验证码的图片从后台获取 123456789101112131415&lt;tr&gt; &lt;td&gt;验证码&lt;/td&gt; &lt;td class=&quot;inputs&quot;&gt; &lt;input name=&quot;checkCode&quot; type=&quot;text&quot; id=&quot;checkCode&quot;&gt; &lt;img id=&quot;checkCodeImg&quot; src=&quot;/brand-demo/checkCodeServlet&quot;&gt; &lt;a href=&quot;#&quot; id=&quot;changeImg&quot; &gt;看不清？&lt;/a&gt; &lt;/td&gt;&lt;/tr&gt;&lt;script&gt; document.getElementById(&quot;changeImg&quot;).onclick = function () &#123; //路径后面添加时间戳的目的是避免浏览器进行缓存静态资源 document.getElementById(&quot;checkCodeImg&quot;).src = &quot;/brand-demo/checkCodeServlet?&quot;+new Date().getMilliseconds(); &#125;&lt;/script&gt; (2)编写CheckCodeServlet类，用来接收请求生成验证码 1234567891011121314@WebServlet(&quot;/checkCodeServlet&quot;)public class CheckCodeServlet extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; // 生成验证码 ServletOutputStream os = response.getOutputStream(); String checkCode = CheckCodeUtil.outputVerifyImage(100, 50, os, 4); &#125; @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; this.doGet(request, response); &#125;&#125; 4.7验证码-校验 需求 判断程序生成的验证码 和 用户输入的验证码 是否一样，如果不一样，则阻止注册 验证码图片访问和提交注册表单是两次请求，所以要将程序生成的验证码存入Session中 思考:为什么要把验证码数据存入到Session中呢? 生成验证码和校验验证码是两次请求，此处就需要在一个会话的两次请求之间共享数据 验证码属于安全数据类的，所以我们选中Session来存储验证码数据。 实现流程分析 (1)在CheckCodeServlet中生成验证码的时候，将验证码数据存入Session对象 (2)前端将验证码和注册数据提交到后台，交给RegisterServlet类 (3)RegisterServlet类接收到请求和数据后，其中就有验证码，和Session中的验证码进行对比 (4)如果一致，则完成注册，如果不一致，则提示错误信息 具体实现 (1)修改CheckCodeServlet类，将验证码存入Session对象 123456789101112131415161718192021@WebServlet(&quot;/checkCodeServlet&quot;)public class CheckCodeServlet extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; // 生成验证码 ServletOutputStream os = response.getOutputStream(); String checkCode = CheckCodeUtil.outputVerifyImage(100, 50, os, 4); // 存入Session HttpSession session = request.getSession(); session.setAttribute(&quot;checkCodeGen&quot;,checkCode); &#125; @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; this.doGet(request, response); &#125;&#125; (2)在RegisterServlet中，获取页面的和session对象中的验证码，进行对比 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263package com.itheima.web;import com.itheima.pojo.User;import com.itheima.service.UserService;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.*;import java.io.IOException;@WebServlet(&quot;/registerServlet&quot;)public class RegisterServlet extends HttpServlet &#123; private UserService service = new UserService(); @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; //1. 获取用户名和密码数据 String username = request.getParameter(&quot;username&quot;); String password = request.getParameter(&quot;password&quot;); User user = new User(); user.setUsername(username); user.setPassword(password); // 获取用户输入的验证码 String checkCode = request.getParameter(&quot;checkCode&quot;); // 程序生成的验证码，从Session获取 HttpSession session = request.getSession(); String checkCodeGen = (String) session.getAttribute(&quot;checkCodeGen&quot;); // 比对 if(!checkCodeGen.equalsIgnoreCase(checkCode))&#123; request.setAttribute(&quot;register_msg&quot;,&quot;验证码错误&quot;); request.getRequestDispatcher(&quot;/register.jsp&quot;).forward(request,response); // 不允许注册 return; &#125; //2. 调用service 注册 boolean flag = service.register(user); //3. 判断注册成功与否 if(flag)&#123; //注册功能，跳转登陆页面 request.setAttribute(&quot;register_msg&quot;,&quot;注册成功，请登录&quot;); request.getRequestDispatcher(&quot;/login.jsp&quot;).forward(request,response); &#125;else &#123; //注册失败，跳转到注册页面 request.setAttribute(&quot;register_msg&quot;,&quot;用户名已存在&quot;); request.getRequestDispatcher(&quot;/register.jsp&quot;).forward(request,response); &#125; &#125; @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; this.doGet(request, response); &#125;&#125; 至此，用户的注册登录功能就已经完成了。 来源：it 黑马 JavaWeb 教程","categories":[{"name":"Java","slug":"Java","permalink":"http://littlewuuu.com/categories/Java/"}],"tags":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://littlewuuu.com/tags/JavaWeb/"}]},{"title":"HTTP&Tomcat&Servlet","slug":"黑马/9-HTTP&Tomcat&Servlet","date":"2022-08-21T22:00:00.000Z","updated":"2022-12-01T15:45:08.002Z","comments":true,"path":"2022/08/22/黑马/9-HTTP&Tomcat&Servlet/","link":"","permalink":"http://littlewuuu.com/2022/08/22/%E9%BB%91%E9%A9%AC/9-HTTP&Tomcat&Servlet/","excerpt":"","text":"HTTP&amp;Tomcat&amp;Servlet 今日目标： 了解JavaWeb开发的技术栈 理解HTTP协议和HTTP请求与响应数据的格式 掌握Tomcat的使用 掌握在IDEA中使用Tomcat插件 理解Servlet的执行流程和生命周期 掌握Servlet的使用和相关配置 1，Web概述 1.1 Web和JavaWeb的概念 Web是全球广域网，也称为万维网(www)，能够通过浏览器访问的网站。 JavaWeb就是用Java技术来解决相关web互联网领域的技术栈。 1.2 JavaWeb技术栈 了解JavaWeb技术栈之前，有一个很重要的概念要介绍。 1.2.1 B/S架构 什么是B/S架构? B/S 架构：Browser/Server，浏览器/服务器 架构模式，它的特点是，客户端只需要浏览器，应用程序的逻辑和数据都存储在服务器端。浏览器只需要请求服务器，获取Web资源，服务器把Web资源发送给浏览器即可。大家可以通过下面这张图来回想下我们平常的上网过程: 打开浏览器访问百度首页，输入要搜索的内容，点击回车或百度一下，就可以获取和搜索相关的内容 思考下搜索的内容并不在我们自己的点上，那么这些内容从何而来？答案很明显是从百度服务器返回给我们的 日常百度的小细节，逢年过节百度的logo会更换不同的图片，服务端发生变化，客户端不需做任务事情就能获取最新内容 所以说B/S架构的好处:易于维护升级：服务器端升级后，客户端无需任何部署就可以使用到新的版本。 了解了什么是B/S架构后，作为后台开发工程师的我们将来主要关注的是服务端的开发和维护工作。在服务端将来会放很多资源,都有哪些资源呢? 1.2.2 静态资源 静态资源主要包含HTML、CSS、JavaScript、图片等，主要负责页面的展示。 我们之前已经学过前端网页制作三剑客(HTML+CSS+JavaScript),使用这些技术我们就可以制作出效果比较丰富的网页，将来展现给用户。但是由于做出来的这些内容都是静态的，这就会导致所有的人看到的内容将是一模一样。 在日常上网的过程中，我们除了看到这些好看的页面以外，还会碰到很多动态内容，比如我们常见的百度登录效果: 张三登录以后在网页的右上角看到的是 张三，而李四登录以后看到的则是李四。所以不同的用户访问相同的资源看到的内容大多数是不一样的，要想实现这样的效果，光靠静态资源是无法实现的。 1.2.3 动态资源 动态资源主要包含Servlet、JSP等，主要用来负责逻辑处理。 动态资源处理完逻辑后会把得到的结果交给静态资源来进行展示，动态资源和静态资源要结合一起使用。 动态资源虽然可以处理逻辑，但是当用户来登录百度的时候，就需要输入用户名和密码,这个时候我们就又需要解决的一个问题是，用户在注册的时候填入的用户名和密码、以及我们经常会访问到一些数据列表的内容展示(如下图所示)，这些数据都存储在哪里?我们需要的时候又是从哪里来取呢? 1.2.4 数据库 数据库主要负责存储数据。 整个Web的访问过程就如下图所示: (1)浏览器发送一个请求到服务端，去请求所需要的相关资源; (2)资源分为动态资源和静态资源,动态资源可以是使用Java代码按照Servlet和JSP的规范编写的内容; (3)在Java代码可以进行业务处理也可以从数据库中读取数据; (4)拿到数据后，把数据交给HTML页面进行展示,再结合CSS和JavaScript使展示效果更好; (5)服务端将静态资源响应给浏览器; (6)浏览器将这些资源进行解析; (7)解析后将效果展示在浏览器，用户就可以看到最终的结果。 在整个Web的访问过程中，会设计到很多技术，这些技术有已经学习过的，也有还未涉及到的内容，都有哪些还没有涉及到呢? 1.2.5 HTTP协议 HTTP协议:主要定义通信规则 浏览器发送请求给服务器，服务器响应数据给浏览器，这整个过程都需要遵守一定的规则，之前大家学习过TCP、UDP，这些都属于规则，这里我们需要使用的是HTTP协议，这也是一种规则。 1.2.6 Web服务器 Web服务器:负责解析 HTTP 协议，解析请求数据，并发送响应数据 浏览器按照HTTP协议发送请求和数据，后台就需要一个Web服务器软件来根据HTTP协议解析请求和数据，然后把处理结果再按照HTTP协议发送给浏览器 Web服务器软件有很多，我们课程中将学习的是目前最为常用的Tomcat服务器 到这为止，关于JavaWeb中用到的技术栈我们就介绍完了，这里面就只有HTTP协议、Servlet、JSP以及Tomcat这些知识是没有学习过的，所以整个Web核心主要就是来学习这些技术。 1.3 Web核心课程安排 整个Web核心，我们总共有六天的学习内容，分别是: 第一天：HTTP、Tomcat、Servlet 第二天：Request(请求)、Response(响应) 第三天：JSP、会话技术(Cookie、Session) 第四天：Filter(过滤器)、Listener(监听器) 第五天：Ajax、Vue、ElementUI 第六天：综合案例 (1)Request是从客户端向服务端发出的请求对象， (2)Response是从服务端响应给客户端的结果对象， (3)JSP是动态网页技术, (4)会话技术是用来存储客户端和服务端交互所产生的数据， (5)过滤器是用来拦截客户端的请求, (6)监听器是用来监听特定事件, (7)Ajax、Vue、ElementUI都是属于前端技术 这些技术都该如何来使用，我们后面会一个个进行详细的讲解。接下来我们来学习下HTTP、Tomcat和Servlet。 2, HTTP 2.1 简介 HTTP概念 HyperText Transfer Protocol，超文本传输协议，规定了浏览器和服务器之间数据传输的规则。 数据传输的规则指的是请求数据和响应数据需要按照指定的格式进行传输。 如果想知道具体的格式，可以打开浏览器，点击F12打开开发者工具，点击Network来查看某一次请求的请求数据和响应数据具体的格式内容，如下图所示: 注意:在浏览器中如果看不到上述内容，需要清除浏览器的浏览数据。chrome浏览器可以使用ctrl+shift+Del进行清除。 所以学习HTTP主要就是学习请求和响应数据的具体格式内容。 HTTP协议特点 HTTP协议有它自己的一些特点，分别是: 基于TCP协议: 面向连接，安全 TCP是一种面向连接的(建立连接之前是需要经过三次握手)、可靠的、基于字节流的传输层通信协议，在数据传输方面更安全。 基于请求-响应模型的:一次请求对应一次响应 请求和响应是一一对应关系 HTTP协议是无状态协议:对于事物处理没有记忆能力。每次请求-响应都是独立的 无状态指的是客户端发送HTTP请求给服务端之后，服务端根据请求响应数据，响应完后，不会记录任何信息。这种特性有优点也有缺点， 缺点:多次请求间不能共享数据 优点:速度快 请求之间无法共享数据会引发的问题，如: 京东购物，加入购物车和去购物车结算是两次请求， HTTP协议的无状态特性，加入购物车请求响应结束后，并未记录加入购物车是何商品 发起去购物车结算的请求后，因为无法获取哪些商品加入了购物车，会导致此次请求无法正确展示数据 具体使用的时候，我们发现京东是可以正常展示数据的，原因是Java早已考虑到这个问题，并提出了使用会话技术(Cookie、Session)来解决这个问题。具体如何来做，我们后面会详细讲到。刚才提到HTTP协议是规定了请求和响应数据的格式，那具体的格式是什么呢? 2.2 请求数据格式 2.2.1 格式介绍 请求数据总共分为三部分内容，分别是请求行、请求头、请求体 请求行: HTTP请求中的第一行数据，请求行包含三块内容，分别是 GET[请求方式] /[请求URL路径] HTTP/1.1[HTTP协议及版本] 请求方式有七种,最常用的是GET和POST 请求头: 第二行开始，格式为key: value形式 请求头中会包含若干个属性，常见的HTTP请求头有: 12345Host: 表示请求的主机名User-Agent: 浏览器版本,例如Chrome浏览器的标识类似Mozilla/5.0 ...Chrome/79，IE浏览器的标识类似Mozilla/5.0 (Windows NT ...)like Gecko；Accept：表示浏览器能接收的资源类型，如text/*，image/*或者*/*表示所有；Accept-Language：表示浏览器偏好的语言，服务器可以据此返回不同语言的网页；Accept-Encoding：表示浏览器可以支持的压缩类型，例如gzip, deflate等。 这些数据有什么用处? 举例说明:服务端可以根据请求头中的内容来获取客户端的相关信息，有了这些信息服务端就可以处理不同的业务需求，比如: 不同浏览器解析HTML和CSS标签的结果会有不一致，所以就会导致相同的代码在不同的浏览器会出现不同的效果 服务端根据客户端请求头中的数据获取到客户端的浏览器类型，就可以根据不同的浏览器设置不同的代码来达到一致的效果 这就是我们常说的浏览器兼容问题 请求体: POST请求的最后一部分，存储请求参数 如上图红线框的内容就是请求体的内容，请求体和请求头之间是有一个空行隔开。此时浏览器发送的是POST请求，为什么不能使用GET呢?这时就需要回顾GET和POST两个请求之间的区别了: GET请求请求参数在请求行中，没有请求体，POST请求请求参数在请求体中 GET请求请求参数大小有限制，POST没有 小结: 请求数据中包含三部分内容，分别是请求行、请求头和请求体 POST请求数据在请求体中，GET请求数据在请求行上 2.3 响应数据格式 2.3.1 格式介绍 响应数据总共分为三部分内容，分别是响应行、响应头、响应体 响应行：响应数据的第一行,响应行包含三块内容，分别是 HTTP/1.1[HTTP协议及版本] 200[响应状态码] ok[状态码的描述] 响应头：第二行开始，格式为key：value形式 响应头中会包含若干个属性，常见的HTTP响应头有: 1234Content-Type：表示该响应内容的类型，例如text/html，image/jpeg；Content-Length：表示该响应内容的长度（字节数）；Content-Encoding：表示该响应压缩算法，例如gzip；Cache-Control：指示客户端应如何缓存，例如max-age=300表示可以最多缓存300秒 响应体： 最后一部分。存放响应数据 上图中…这部分内容就是响应体，它和响应头之间有一个空行隔开。 2.3.2 响应状态码 分类 说明 1xx 响应中——临时状态码，表示请求已经接受，告诉客户端应该继续请求或者如果它已经完成则忽略它 2xx 成功——表示请求已经被成功接收，处理已完成 3xx 重定向——重定向到其它地方：它让客户端再发起一个请求以完成整个处理。 4xx 客户端错误——处理发生错误，责任在客户端，如：客户端的请求一个不存在的资源，客户端未被授权，禁止访问等 5xx 服务器端错误——处理发生错误，责任在服务端，如：服务端抛出异常，路由出错，HTTP版本不支持等 状态码大全：https://cloud.tencent.com/developer/chapter/13553 常用状态码 状态码 英文描述 解释 200 OK 客户端请求成功，即处理成功，这是我们最想看到的状态码 302 Found 指示所请求的资源已移动到由Location响应头给定的 URL，浏览器会自动重新访问到这个页面 304 Not Modified 告诉客户端，你请求的资源至上次取得后，服务端并未更改，你直接用你本地缓存吧。隐式重定向 400 Bad Request 客户端请求有语法错误，不能被服务器所理解 403 Forbidden 服务器收到请求，但是拒绝提供服务，比如：没有权限访问相关资源 404 Not Found 请求资源不存在，一般是URL输入有误，或者网站资源被删除了 428 Precondition Required 服务器要求有条件的请求，告诉客户端要想访问该资源，必须携带特定的请求头 429 Too Many Requests 太多请求，可以限制客户端请求某个资源的数量，配合 Retry-After(多长时间后可以请求)响应头一起使用 431 Request Header Fields Too Large 请求头太大，服务器不愿意处理请求，因为它的头部字段太大。请求可以在减少请求头域的大小后重新提交。 405 Method Not Allowed 请求方式有误，比如应该用GET请求方式的资源，用了POST 500 Internal Server Error 服务器发生不可预期的错误。服务器出异常了，赶紧看日志去吧 503 Service Unavailable 服务器尚未准备好处理请求，服务器刚刚启动，还未初始化好 511 Network Authentication Required 客户端需要进行身份验证才能获得网络访问权限 2.3.3 自定义服务器 在前面我们导入到IDEA中的http项目中，有一个Server.java类，这里面就是自定义的一个服务器代码，主要使用到的是ServerSocket和Socket 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192package com.itheima;import sun.misc.IOUtils;import java.io.*;import java.net.ServerSocket;import java.net.Socket;import java.nio.charset.StandardCharsets;import java.nio.file.Files;/* 自定义服务器 */public class Server &#123; public static void main(String[] args) throws IOException &#123; ServerSocket ss = new ServerSocket(8080); // 监听指定端口 System.out.println(&quot;server is running...&quot;); while (true)&#123; Socket sock = ss.accept(); System.out.println(&quot;connected from &quot; + sock.getRemoteSocketAddress()); Thread t = new Handler(sock); t.start(); &#125; &#125;&#125;class Handler extends Thread &#123; Socket sock; public Handler(Socket sock) &#123; this.sock = sock; &#125; public void run() &#123; try (InputStream input = this.sock.getInputStream()) &#123; try (OutputStream output = this.sock.getOutputStream()) &#123; handle(input, output); &#125; &#125; catch (Exception e) &#123; try &#123; this.sock.close(); &#125; catch (IOException ioe) &#123; &#125; System.out.println(&quot;client disconnected.&quot;); &#125; &#125; private void handle(InputStream input, OutputStream output) throws IOException &#123; BufferedReader reader = new BufferedReader(new InputStreamReader(input, StandardCharsets.UTF_8)); BufferedWriter writer = new BufferedWriter(new OutputStreamWriter(output, StandardCharsets.UTF_8)); // 读取HTTP请求: boolean requestOk = false; String first = reader.readLine(); if (first.startsWith(&quot;GET / HTTP/1.&quot;)) &#123; requestOk = true; &#125; for (;;) &#123; String header = reader.readLine(); if (header.isEmpty()) &#123; // 读取到空行时, HTTP Header读取完毕 break; &#125; System.out.println(header); &#125; System.out.println(requestOk ? &quot;Response OK&quot; : &quot;Response Error&quot;); if (!requestOk) &#123; // 发送错误响应: writer.write(&quot;HTTP/1.0 404 Not Found\\r\\n&quot;); writer.write(&quot;Content-Length: 0\\r\\n&quot;); writer.write(&quot;\\r\\n&quot;); writer.flush(); &#125; else &#123; // 发送成功响应: //读取html文件，转换为字符串 BufferedReader br = new BufferedReader(new FileReader(&quot;http/html/a.html&quot;)); StringBuilder data = new StringBuilder(); String line = null; while ((line = br.readLine()) != null)&#123; data.append(line); &#125; br.close(); int length = data.toString().getBytes(StandardCharsets.UTF_8).length; writer.write(&quot;HTTP/1.1 200 OK\\r\\n&quot;); writer.write(&quot;Connection: keep-alive\\r\\n&quot;); writer.write(&quot;Content-Type: text/html\\r\\n&quot;); writer.write(&quot;Content-Length: &quot; + length + &quot;\\r\\n&quot;); writer.write(&quot;\\r\\n&quot;); // 空行标识Header和Body的分隔 writer.write(data.toString()); writer.flush(); &#125; &#125;&#125; 上面代码，大家不需要自己写，主要通过上述代码，只需要大家了解到服务器可以使用java完成编写，是可以接受页面发送的请求和响应数据给前端浏览器的，真正用到的Web服务器，我们不会自己写，都是使用目前比较流行的web服务器，比如 Tomcat 小结 响应数据中包含三部分内容，分别是响应行、响应头和响应体 掌握200，404，500这三个响应状态码所代表含义，分布是成功、所访问资源不存在和服务的错误 3, Tomcat 3.1 简介 3.1.1 什么是Web服务器 Web服务器是一个应用程序（软件），对HTTP协议的操作进行封装，使得程序员不必直接对协议进行操作，让Web开发更加便捷。主要功能是&quot;提供网上信息浏览服务&quot;。 Web服务器是安装在服务器端的一款软件，将来我们把自己写的Web项目部署到Web Tomcat服务器软件中，当Web服务器软件启动后，部署在Web服务器软件中的页面就可以直接通过浏览器来访问了。 Web服务器软件使用步骤 准备静态资源 下载安装Web服务器软件 将静态资源部署到Web服务器上 启动Web服务器使用浏览器访问对应的资源 Tomcat就是一款软件，我们主要是以学习如何去使用为主。具体我们会从以下这些方向去学习: 简介: 初步认识下Tomcat 基本使用: 安装、卸载、启动、关闭、配置和项目部署，这些都是对Tomcat的基本操作 IDEA中如何创建Maven Web项目 IDEA中如何使用Tomcat,后面这两个都是我们以后开发经常会用到的方式 首选我们来认识下Tomcat。 Tomcat Tomcat的相关概念: Tomcat是Apache软件基金会一个核心项目，是一个开源免费的轻量级Web服务器，支持Servlet/JSP少量JavaEE规范。 概念中提到了JavaEE规范，那什么又是JavaEE规范呢? JavaEE: Java Enterprise Edition,Java企业版。指Java企业级开发的技术规范总和。包含13项技术规范:JDBC、JNDI、EJB、RMI、JSP、Servlet、XML、JMS、Java IDL、JTS、JTA、JavaMail、JAF。 因为Tomcat支持Servlet/JSP规范，所以Tomcat也被称为Web容器、Servlet容器。Servlet需要依赖Tomcat才能运行。 Tomcat的官网: https://tomcat.apache.org/ 从官网上可以下载对应的版本进行使用。 Tomcat的LOGO 小结 通过这一节的学习，我们需要掌握以下内容: Web服务器的作用 封装HTTP协议操作，简化开发 可以将Web项目部署到服务器中，对外提供网上浏览服务 Tomcat是一个轻量级的Web服务器，支持Servlet/JSP少量JavaEE规范，也称为Web容器，Servlet容器。 3.2 基本使用 Tomcat总共分两部分学习，先来学习Tomcat的基本使用，包括Tomcat的下载、安装、卸载、启动和关闭。 3.2.1 下载 直接从官网下载 大家可以自行下载，也可以直接使用资料中已经下载好的资源， Tomcat的软件程序 资料/2. Tomcat/apache-tomcat-8.5.68-windows-x64.zip Tomcat的源码 资料/2. Tomcat/tomcat源码/apache-tomcat-8.5.68-src.zip 3.2.2 安装 Tomcat是绿色版,直接解压即可 在D盘的software目录下，将apache-tomcat-8.5.68-windows-x64.zip进行解压缩，会得到一个apache-tomcat-8.5.68的目录，Tomcat就已经安装成功。 注意，Tomcat在解压缩的时候，解压所在的目录可以任意，但最好解压到一个不包含中文和空格的目录，因为后期在部署项目的时候，如果路径有中文或者空格可能会导致程序部署失败。 打开apache-tomcat-8.5.68目录就能看到如下目录结构，每个目录中包含的内容需要认识下, bin:目录下有两类文件，一种是以.bat结尾的，是Windows系统的可执行文件，一种是以.sh结尾的，是Linux系统的可执行文件。 webapps:就是以后项目部署的目录 到此，Tomcat的安装就已经完成。 3.2.3 卸载 卸载比较简单，可以直接删除目录即可 3.2.4 启动 Windows : 双击: bin\\startup.bat MacOS: 终端切换到 bin 目录下，执行 ./start.sh ./shutdowm.sh 启动后，通过浏览器访问 http://localhost:8080能看到Apache Tomcat的内容就说明Tomcat已经启动成功。 注意: 启动的过程中，控制台有中文乱码，需要修改conf/logging.prooperties 3.2.5 关闭 关闭有三种方式 直接x掉运行窗口:强制关闭[不建议] bin\\shutdown.bat：正常关闭 ctrl+c： 正常关闭 3.2.6 配置 修改端口 Tomcat默认的端口是8080，要想修改Tomcat启动的端口号，需要修改 conf/server.xml 注: HTTP协议默认端口号为80，如果将Tomcat端口号改为80，则将来访问Tomcat时，将不用输入端口号。 启动时可能出现的错误 Tomcat的端口号取值范围是0-65535之间任意未被占用的端口，如果设置的端口号被占用，启动的时候就会包如下的错误 Tomcat启动的时候，启动窗口一闪而过: 需要检查JAVA_HOME环境变量是否正确配置 3.2.7 部署 Tomcat部署项目： 将项目放置到webapps目录下，即部署完成。 将 资料/2. Tomcat/hello 目录拷贝到Tomcat的webapps目录下 通过浏览器访问http://localhost/hello/a.html，能看到下面的内容就说明项目已经部署成功。 但是呢随着项目的增大，项目中的资源也会越来越多，项目在拷贝的过程中也会越来越费时间，该如何解决呢? 一般JavaWeb项目会被打包称war包，然后将war包放到Webapps目录下，Tomcat会自动解压缩war文件 将 资料/2. Tomcat/haha.war目录拷贝到Tomcat的webapps目录下 Tomcat检测到war包后会自动完成解压缩，在webapps目录下就会多一个haha目录 通过浏览器访问http://localhost/haha/a.html，能看到下面的内容就说明项目已经部署成功。 至此，Tomcat的部署就已经完成了，至于如何获得项目对应的war包，后期我们会借助于IDEA工具来生成。 3.3 Maven创建Web项目 介绍完Tomcat的基本使用后，我们来学习在IDEA中如何创建Maven Web项目，学习这种方式的原因是以后Tomcat中运行的绝大多数都是Web项目，而使用Maven工具能更加简单快捷的把Web项目给创建出来，所以Maven的Web项目具体如何来构建呢? 在真正创建Maven Web项目之前，我们先要知道Web项目长什么样子，具体的结构是什么? 3.3.1 Web项目结构 Web项目的结构分为:开发中的项目和开发完可以部署的Web项目,这两种项目的结构是不一样的，我们一个个来介绍下: Maven Web项目结构: 开发中的项目 开发完成部署的Web项目 开发项目通过执行Maven打包命令package,可以获取到部署的Web项目目录 编译后的Java字节码文件和resources的资源文件，会被放到WEB-INF下的classes目录下 pom.xml中依赖坐标对应的jar包，会被放入WEB-INF下的lib目录下 3.3.2 创建Maven Web项目 介绍完Maven Web的项目结构后，接下来使用Maven来创建Web项目，创建方式有两种:使用骨架和不使用骨架 使用骨架 具体的步骤包含: 1.创建Maven项目 2.选择使用Web项目骨架 3.输入Maven项目坐标创建项目 4.确认Maven相关的配置信息后，完成项目创建 5.删除pom.xml中多余内容 6.补齐Maven Web项目缺失的目录结构 创建Maven项目 选择使用Web项目骨架 输入Maven项目坐标创建项目 确认Maven相关的配置信息后，完成项目创建 删除pom.xml中多余内容，只留下面的这些内容，注意打包方式 jar和war的区别 补齐Maven Web项目缺失的目录结构，默认没有java和resources目录，需要手动完成创建补齐，最终的目录结果如下 不使用骨架 具体的步骤包含: 1.创建Maven项目 2.选择不使用Web项目骨架 3.输入Maven项目坐标创建项目 4.在pom.xml设置打包方式为war 5.补齐Maven Web项目缺失webapp的目录结构 6.补齐Maven Web项目缺失WEB-INF/web.xml的目录结构 创建Maven项目 选择不使用Web项目骨架 输入Maven项目坐标创建项目 在pom.xml设置打包方式为war,默认是不写代表打包方式为jar 补齐Maven Web项目缺失webapp的目录结构 补齐Maven Web项目缺失WEB-INF/web.xml的目录结构 补充完后，最终的项目结构如下: 上述两种方式，创建的web项目，都不是很全，需要手动补充内容，至于最终采用哪种方式来创建Maven Web项目，都是可以的，根据各自的喜好来选择使用即可。 小结 1.掌握Maven Web项目的目录结构 2.掌握使用骨架的方式创建Maven Web项目 3.掌握不使用骨架的方式创建Maven Web项目 3.4 IDEA使用Tomcat Maven Web项目创建成功后，通过Maven的package命令可以将项目打包成war包，将war文件拷贝到Tomcat的webapps目录下，启动Tomcat就可以将项目部署成功，然后通过浏览器进行访问即可。 然而我们在开发的过程中，项目中的内容会经常发生变化，如果按照上面这种方式来部署测试，是非常不方便的 如何在IDEA中能快速使用Tomcat呢? 在IDEA中集成使用Tomcat有两种方式，分别是集成本地Tomcat和Tomcat Maven插件 3.4.1 集成本地Tomcat 目标: 将刚才本地安装好的Tomcat8集成到IDEA中，完成项目部署，具体的实现步骤 打开添加本地Tomcat的面板 指定本地Tomcat的具体路径 修改Tomcat的名称，此步骤可以不改，只是让名字看起来更有意义，HTTP port中的端口也可以进行修改，比如把8080改成80 将开发项目部署项目到Tomcat中 扩展内容： xxx.war和 xxx.war exploded这两种部署项目模式的区别? war模式是将WEB工程打成war包，把war包发布到Tomcat服务器上 war exploded模式是将WEB工程以当前文件夹的位置关系发布到Tomcat服务器上 war模式部署成功后，Tomcat的webapps目录下会有部署的项目内容 war exploded模式部署成功后，Tomcat的webapps目录下没有，而使用的是项目的target目录下的内容进行部署 建议大家都选war模式进行部署，更符合项目部署的实际情况 部署成功后，就可以启动项目，为了能更好的看到启动的效果，可以在webapp目录下添加a.html页面 启动成功后，可以通过浏览器进行访问测试 最终的注意事项 至此，IDEA中集成本地Tomcat进行项目部署的内容我们就介绍完了，整体步骤如下，大家需要按照流程进行部署操作练习。 3.4.2 Tomcat Maven插件 在IDEA中使用本地Tomcat进行项目部署，相对来说步骤比较繁琐，所以我们需要一种更简便的方式来替换它，那就是直接使用Maven中的Tomcat插件来部署项目，具体的实现步骤，只需要两步，分别是: 在pom.xml中添加Tomcat插件 12345678910&lt;build&gt; &lt;plugins&gt; &lt;!--Tomcat插件 --&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.tomcat.maven&lt;/groupId&gt; &lt;artifactId&gt;tomcat7-maven-plugin&lt;/artifactId&gt; &lt;version&gt;2.2&lt;/version&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; 使用Maven Helper插件快速启动项目，选中项目，右键–&gt;Run Maven --&gt; tomcat7:run 注意: 如果选中项目并右键点击后，看不到Run Maven和Debug Maven，这个时候就需要在IDEA中下载Maven Helper插件，具体的操作方式为: File --&gt; Settings --&gt; Plugins --&gt; Maven Helper —&gt; Install,安装完后按照提示重启IDEA，就可以看到了。 Maven Tomcat插件目前只有Tomcat7版本，没有更高的版本可以使用 使用Maven Tomcat插件，要想修改Tomcat的端口和访问路径，可以直接修改pom.xml 1234567891011121314151617181920&lt;build&gt; &lt;plugins&gt; &lt;!--Tomcat插件 --&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.tomcat.maven&lt;/groupId&gt; &lt;artifactId&gt;tomcat7-maven-plugin&lt;/artifactId&gt; &lt;version&gt;2.2&lt;/version&gt; &lt;configuration&gt; &lt;port&gt;80&lt;/port&gt;&lt;!--访问端口号 --&gt; &lt;!--项目访问路径 未配置访问路径: http://localhost:80/tomcat-demo2/a.html 配置/后访问路径: http://localhost:80/a.html 如果配置成 /hello,访问路径会变成什么? 答案: http://localhost:80/hello/a.html --&gt; &lt;path&gt;/&lt;/path&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; 小结 通过这一节的学习，大家要掌握在IDEA中使用Tomcat的两种方式，集成本地Tomcat和使用Maven的Tomcat插件。后者更简单，推荐大家使用，但是如果对于Tomcat的版本有比较高的要求，要在Tomcat7以上，这个时候就只能用前者了。 4， Servlet 4.1 简介 Servlet是JavaWeb最为核心的内容，它是Java提供的一门动态web资源开发技术。 使用Servlet就可以实现，根据不同的登录用户在页面上动态显示不同内容。 Servlet是JavaEE规范之一，其实就是一个接口，将来我们需要定义Servlet类实现Servlet接口，并由web服务器运行Servlet 介绍完Servlet是什么以后，接下来我们就按照快速入门-&gt;执行流程-&gt;生命周期-&gt;体系结构-&gt;urlPattern配置-&gt;XML配置的学习步骤，一步步完成对Servlet的知识学习，首选我们来通过一个入门案例来快速把Servlet用起来。 4.2 快速入门 需求分析: 编写一个Servlet类，并使用IDEA中Tomcat插件进行部署，最终通过浏览器访问所编写的Servlet程序。 具体的实现步骤为: 创建Web项目web-demo，导入Servlet依赖坐标 1234567891011&lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;3.1.0&lt;/version&gt; &lt;!-- 此处为什么需要添加provided标签? provided指的是在编译和测试过程中有效,最后生成的war包时不会加入 因为Tomcat的lib目录中已经有servlet-api这个jar包，如果在生成war包的时候生效就会和Tomcat中的jar包冲突，导致报错 --&gt; &lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt; 创建:定义一个类，实现Servlet接口，并重写接口中所有方法，并在service方法中输入一句话 1234567891011121314151617181920212223242526package com.itheima.web;import javax.servlet.*;import java.io.IOException;public class ServletDemo1 implements Servlet &#123; public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException &#123; System.out.println(&quot;servlet hello world~&quot;); &#125; public void init(ServletConfig servletConfig) throws ServletException &#123; &#125; public ServletConfig getServletConfig() &#123; return null; &#125; public String getServletInfo() &#123; return null; &#125; public void destroy() &#123; &#125;&#125; 配置:在类上使用@WebServlet注解，配置该Servlet的访问路径 1@WebServlet(&quot;/demo1&quot;) 访问:启动Tomcat,浏览器中输入URL地址访问该Servlet 1http://localhost:8080/web-demo/demo1 器访问后，在控制台会打印servlet hello world~ 说明servlet程序已经成功运行。 至此，Servlet的入门案例就已经完成，大家可以按照上面的步骤进行练习了。 4.3 执行流程 Servlet程序已经能正常运行，但是我们需要思考个问题: 我们并没有创建ServletDemo1类的对象，也没有调用对象中的service方法，为什么在控制台就打印了servlet hello world~这句话呢? 要想回答上述问题，我们就需要对Servlet的执行流程进行一个学习。 浏览器发出http://localhost:8080/web-demo/demo1请求，从请求中可以解析出三部分内容，分别是localhost:8080、web-demo、demo1 根据localhost:8080可以找到要访问的Tomcat Web服务器 根据web-demo可以找到部署在Tomcat服务器上的web-demo项目 根据demo1可以找到要访问的是项目中的哪个Servlet类，根据@WebServlet后面的值进行匹配 找到ServletDemo1这个类后，Tomcat Web服务器就会为ServletDemo1这个类创建一个对象，然后调用对象中的service方法 ServletDemo1实现了Servlet接口，所以类中必然会重写service方法供Tomcat Web服务器进行调用 service方法中有ServletRequest和ServletResponse两个参数，ServletRequest封装的是请求数据，ServletResponse封装的是响应数据，后期我们可以通过这两个参数实现前后端的数据交互 小结 介绍完Servlet的执行流程，需要大家掌握两个问题： Servlet由谁创建?Servlet方法由谁调用? Servlet由web服务器创建，Servlet方法由web服务器调用 服务器怎么知道Servlet中一定有service方法? 因为我们自定义的Servlet,必须实现Servlet接口并复写其方法，而Servlet接口中有service方法 4.4 生命周期 介绍完Servlet的执行流程后，我们知道Servlet是由Tomcat Web服务器帮我们创建的。 接下来咱们再来思考一个问题:Tomcat什么时候创建的Servlet对象? 要想回答上述问题，我们就需要对Servlet的生命周期进行一个学习。 生命周期: 对象的生命周期指一个对象从被创建到被销毁的整个过程。 Servlet运行在Servlet容器(web服务器)中，其生命周期由容器来管理，分为4个阶段： 加载和实例化：默认情况下，当Servlet第一次被访问时，由容器创建Servlet对象 123456默认情况，Servlet会在第一次访问被容器创建，但是如果创建Servlet比较耗时的话，那么第一个访问的人等待的时间就比较长，用户的体验就比较差，那么我们能不能把Servlet的创建放到服务器启动的时候来创建，具体如何来配置?@WebServlet(urlPatterns = &quot;/demo1&quot;,loadOnStartup = 1)loadOnstartup的取值有两类情况 （1）负整数:第一次访问时创建Servlet对象 （2）0或正整数:服务器启动时创建Servlet对象，数字越小优先级越高 初始化：在Servlet实例化之后，容器将调用Servlet的init()方法初始化这个对象，完成一些如加载配置文件、创建连接等初始化的工作。该方法只调用一次 请求处理：每次请求Servlet时，Servlet容器都会调用Servlet的==service()==方法对请求进行处理 服务终止：当需要释放内存或者容器关闭时，容器就会调用Servlet实例的==destroy()==方法完成资源的释放。在destroy()方法调用之后，容器会释放这个Servlet实例，该实例随后会被Java的垃圾收集器所回收 通过案例演示下上述的生命周期 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354package com.itheima.web;import javax.servlet.*;import javax.servlet.annotation.WebServlet;import java.io.IOException;/*** Servlet生命周期方法*/@WebServlet(urlPatterns = &quot;/demo2&quot;,loadOnStartup = 1)public class ServletDemo2 implements Servlet &#123; /** * 初始化方法 * 1.调用时机：默认情况下，Servlet被第一次访问时，调用 * * loadOnStartup: 默认为-1，修改为0或者正整数，则会在服务器启动的时候，调用 * 2.调用次数: 1次 * @param config * @throws ServletException */ public void init(ServletConfig config) throws ServletException &#123; System.out.println(&quot;init...&quot;); &#125; /** * 提供服务 * 1.调用时机:每一次Servlet被访问时，调用，就是网址写上 demo2 时 * 2.调用次数: 多次 * @param req * @param res * @throws ServletException * @throws IOException */ public void service(ServletRequest req, ServletResponse res) throws ServletException, IOException &#123; System.out.println(&quot;servlet hello world~&quot;); &#125; /** * 销毁方法 * 1.调用时机：内存释放或者服务器关闭的时候，Servlet对象会被销毁，调用 * 2.调用次数: 1次 */ public void destroy() &#123; System.out.println(&quot;destroy...&quot;); &#125; public ServletConfig getServletConfig() &#123; return null; &#125; public String getServletInfo() &#123; return null; &#125;&#125; 注意:如何才能让Servlet中的destroy方法被执行？ 在Terminal命令行中，先使用mvn tomcat7:run启动，然后再使用ctrl+c关闭tomcat 小结 这节中需要掌握的内容是: Servlet对象在什么时候被创建的? 默认是第一次访问的时候被创建，可以使用@WebServlet(urlPatterns = “/demo2”,loadOnStartup = 1)的loadOnStartup 修改成在服务器启动的时候创建。 Servlet生命周期中涉及到的三个方法，这三个方法是什么?什么时候被调用?调用几次? 涉及到三个方法，分别是 init()、service()、destroy() init方法在Servlet对象被创建的时候执行，只执行1次 service方法在Servlet被访问的时候调用，每访问1次就调用1次 destroy方法在Servlet对象被销毁的时候调用，只执行1次 4.5 方法介绍 Servlet中总共有5个方法，我们已经介绍过其中的三个，剩下的两个方法作用分别是什么？ 我们先来回顾下前面讲的三个方法，分别是: 初始化方法，在Servlet被创建时执行，只执行一次 1void init(ServletConfig config) 提供服务方法， 每次Servlet被访问，都会调用该方法 1void service(ServletRequest req, ServletResponse res) 销毁方法，当Servlet被销毁时，调用该方法。在内存释放或服务器关闭时销毁Servlet 1void destroy() 剩下的两个方法是: 获取Servlet信息 12345String getServletInfo() //该方法用来返回Servlet的相关信息，没有什么太大的用处，一般我们返回一个空字符串即可public String getServletInfo() &#123; return &quot;&quot;;&#125; 获取ServletConfig对象 1ServletConfig getServletConfig() ServletConfig对象，在init方法的参数中有，而Tomcat Web服务器在创建Servlet对象的时候会调用init方法，必定会传入一个ServletConfig对象，我们只需要将服务器传过来的ServletConfig进行返回即可。具体如何操作? 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455package com.itheima.web;import javax.servlet.*;import javax.servlet.annotation.WebServlet;import java.io.IOException;/** * Servlet方法介绍 */@WebServlet(urlPatterns = &quot;/demo3&quot;,loadOnStartup = 1)public class ServletDemo3 implements Servlet &#123; private ServletConfig servletConfig; /** * 初始化方法 * 1.调用时机：默认情况下，Servlet被第一次访问时，调用 * * loadOnStartup: 默认为-1，修改为0或者正整数，则会在服务器启动的时候，调用 * 2.调用次数: 1次 * @param config * @throws ServletException */ public void init(ServletConfig config) throws ServletException &#123; this.servletConfig = config; System.out.println(&quot;init...&quot;); &#125; public ServletConfig getServletConfig() &#123; return servletConfig; &#125; /** * 提供服务 * 1.调用时机:每一次Servlet被访问时，调用 * 2.调用次数: 多次 * @param req * @param res * @throws ServletException * @throws IOException */ public void service(ServletRequest req, ServletResponse res) throws ServletException, IOException &#123; System.out.println(&quot;servlet hello world~&quot;); &#125; /** * 销毁方法 * 1.调用时机：内存释放或者服务器关闭的时候，Servlet对象会被销毁，调用 * 2.调用次数: 1次 */ public void destroy() &#123; System.out.println(&quot;destroy...&quot;); &#125; public String getServletInfo() &#123; return &quot;&quot;; &#125;&#125; getServletInfo()和getServletConfig()这两个方法使用的不是很多，大家了解下。 4.6 体系结构 通过上面的学习，我们知道要想编写一个Servlet就必须要实现Servlet接口，重写接口中的5个方法，虽然已经能完成要求，但是编写起来还是比较麻烦的，因为我们更关注的其实只有service方法，那有没有更简单方式来创建Servlet呢? 要想解决上面的问题，我们需要先对Servlet的体系结构进行下了解: 因为我们将来开发B/S架构的web项目，都是针对HTTP协议，所以我们自定义Servlet,会通过继承HttpServlet 具体的编写格式如下: 12345678910111213@WebServlet(&quot;/demo4&quot;)public class ServletDemo4 extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //TODO GET 请求方式处理逻辑 System.out.println(&quot;get...&quot;); &#125; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //TODO Post 请求方式处理逻辑 System.out.println(&quot;post...&quot;); &#125;&#125; 要想发送一个GET请求，请求该Servlet，只需要通过浏览器发送http://localhost:8080/web-demo/demo4,就能看到doGet方法被执行了 要想发送一个POST请求，请求该Servlet，单单通过浏览器是无法实现的，这个时候就需要编写一个form表单来发送请求，在webapp下创建一个a.html页面，内容如下: 123456789101112&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;form action=&quot;/web-demo/demo4&quot; method=&quot;post&quot;&gt; &lt;input name=&quot;username&quot;/&gt;&lt;input type=&quot;submit&quot;/&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 启动测试，即可看到doPost方法被执行了。 Servlet的简化编写就介绍完了，接着需要思考两个问题: HttpServlet中为什么要根据请求方式的不同，调用不同的方法? 如何调用? 针对问题一，我们需要回顾之前的知识点前端发送GET和POST请求的时候，参数的位置不一致，GET请求参数在请求行中，POST请求参数在请求体中，为了能处理不同的请求方式，我们得在service方法中进行判断，然后写不同的业务处理，这样能实现，但是每个Servlet类中都将有相似的代码，针对这个问题，有什么可以优化的策略么? 1234567891011121314151617181920212223242526272829303132333435363738394041424344package com.itheima.web;import javax.servlet.*;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;@WebServlet(&quot;/demo5&quot;)public class ServletDemo5 implements Servlet &#123; public void init(ServletConfig config) throws ServletException &#123; &#125; public ServletConfig getServletConfig() &#123; return null; &#125; public void service(ServletRequest req, ServletResponse res) throws ServletException, IOException &#123; //如何调用? //获取请求方式，根据不同的请求方式进行不同的业务处理 HttpServletRequest request = (HttpServletRequest)req; //1. 获取请求方式 String method = request.getMethod(); //2. 判断 if(&quot;GET&quot;.equals(method))&#123; // get方式的处理逻辑 &#125;else if(&quot;POST&quot;.equals(method))&#123; // post方式的处理逻辑 &#125; &#125; public String getServletInfo() &#123; return null; &#125; public void destroy() &#123; &#125;&#125; 要解决上述问题，我们可以对Servlet接口进行继承封装，来简化代码开发。 1234567891011121314151617181920212223242526272829303132333435363738394041424344package com.itheima.web;import javax.servlet.*;import javax.servlet.http.HttpServletRequest;import java.io.IOException;public class MyHttpServlet implements Servlet &#123; public void init(ServletConfig config) throws ServletException &#123; &#125; public ServletConfig getServletConfig() &#123; return null; &#125; public void service(ServletRequest req, ServletResponse res) throws ServletException, IOException &#123; HttpServletRequest request = (HttpServletRequest)req; //1. 获取请求方式 String method = request.getMethod(); //2. 判断 if(&quot;GET&quot;.equals(method))&#123; // get方式的处理逻辑 doGet(req,res); &#125;else if(&quot;POST&quot;.equals(method))&#123; // post方式的处理逻辑 doPost(req,res); &#125; &#125; protected void doPost(ServletRequest req, ServletResponse res) &#123; &#125; protected void doGet(ServletRequest req, ServletResponse res) &#123; &#125; public String getServletInfo() &#123; return null; &#125; public void destroy() &#123; &#125;&#125; 有了MyHttpServlet这个类，以后我们再编写Servlet类的时候，只需要继承MyHttpServlet，重写父类中的doGet和doPost方法，就可以用来处理GET和POST请求的业务逻辑。接下来，可以把ServletDemo5代码进行改造 1234567891011121314@WebServlet(&quot;/demo5&quot;)public class ServletDemo5 extends MyHttpServlet &#123; @Override protected void doGet(ServletRequest req, ServletResponse res) &#123; System.out.println(&quot;get...&quot;); &#125; @Override protected void doPost(ServletRequest req, ServletResponse res) &#123; System.out.println(&quot;post...&quot;); &#125;&#125; 将来页面发送的是GET请求，则会进入到doGet方法中进行执行，如果是POST请求，则进入到doPost方法。这样代码在编写的时候就相对来说更加简单快捷。 类似MyHttpServlet这样的类Servlet中已经为我们提供好了，就是HttpServlet,翻开源码，大家可以搜索service()方法，你会发现HttpServlet做的事更多，不仅可以处理GET和POST还可以处理其他五种请求方式。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; String method = req.getMethod(); if (method.equals(METHOD_GET)) &#123; long lastModified = getLastModified(req); if (lastModified == -1) &#123; // servlet doesn&#x27;t support if-modified-since, no reason // to go through further expensive logic doGet(req, resp); &#125; else &#123; long ifModifiedSince = req.getDateHeader(HEADER_IFMODSINCE); if (ifModifiedSince &lt; lastModified) &#123; // If the servlet mod time is later, call doGet() // Round down to the nearest second for a proper compare // A ifModifiedSince of -1 will always be less maybeSetLastModified(resp, lastModified); doGet(req, resp); &#125; else &#123; resp.setStatus(HttpServletResponse.SC_NOT_MODIFIED); &#125; &#125; &#125; else if (method.equals(METHOD_HEAD)) &#123; long lastModified = getLastModified(req); maybeSetLastModified(resp, lastModified); doHead(req, resp); &#125; else if (method.equals(METHOD_POST)) &#123; doPost(req, resp); &#125; else if (method.equals(METHOD_PUT)) &#123; doPut(req, resp); &#125; else if (method.equals(METHOD_DELETE)) &#123; doDelete(req, resp); &#125; else if (method.equals(METHOD_OPTIONS)) &#123; doOptions(req,resp); &#125; else if (method.equals(METHOD_TRACE)) &#123; doTrace(req,resp); &#125; else &#123; // // Note that this means NO servlet supports whatever // method was requested, anywhere on this server. // String errMsg = lStrings.getString(&quot;http.method_not_implemented&quot;); Object[] errArgs = new Object[1]; errArgs[0] = method; errMsg = MessageFormat.format(errMsg, errArgs); resp.sendError(HttpServletResponse.SC_NOT_IMPLEMENTED, errMsg); &#125; &#125; 小结!!! 使用 Servlet 写一个类实现 Servlet接口 的所有方法：重点关注 service 方法 HttpServlet的使用步骤 继承HttpServlet 重写doGet和doPost方法 HttpServlet原理 获取请求方式，并根据不同的请求方式，调用不同的doXxx方法 4.7 urlPattern配置 Servlet类编写好后，要想被访问到，就需要配置其访问路径（urlPattern） 一个Servlet,可以配置多个urlPattern 123456789101112131415161718192021package com.itheima.web;import javax.servlet.ServletRequest;import javax.servlet.ServletResponse;import javax.servlet.annotation.WebServlet;/*** urlPattern: 一个Servlet可以配置多个访问路径*/@WebServlet(urlPatterns = &#123;&quot;/demo7&quot;,&quot;/demo8&quot;&#125;)public class ServletDemo7 extends MyHttpServlet &#123; @Override protected void doGet(ServletRequest req, ServletResponse res) &#123; System.out.println(&quot;demo7 get...&quot;); &#125; @Override protected void doPost(ServletRequest req, ServletResponse res) &#123; &#125;&#125; 在浏览器上输入http://localhost:8080/web-demo/demo7,http://localhost:8080/web-demo/demo8这两个地址都能访问到ServletDemo7的doGet方法。 urlPattern配置规则 精确匹配 12345678910111213141516/** * UrlPattern: * * 精确匹配 */@WebServlet(urlPatterns = &quot;/user/select&quot;)public class ServletDemo8 extends MyHttpServlet &#123; @Override protected void doGet(ServletRequest req, ServletResponse res) &#123; System.out.println(&quot;demo8 get...&quot;); &#125; @Override protected void doPost(ServletRequest req, ServletResponse res) &#123; &#125;&#125; 访问路径http://localhost:8080/web-demo/user/select 目录匹配 12345678910111213141516171819202122package com.itheima.web;import javax.servlet.ServletRequest;import javax.servlet.ServletResponse;import javax.servlet.annotation.WebServlet;/** * UrlPattern: * * 目录匹配: /user/* */@WebServlet(urlPatterns = &quot;/user/*&quot;)public class ServletDemo9 extends MyHttpServlet &#123; @Override protected void doGet(ServletRequest req, ServletResponse res) &#123; System.out.println(&quot;demo9 get...&quot;); &#125; @Override protected void doPost(ServletRequest req, ServletResponse res) &#123; &#125;&#125; 访问路径http://localhost:8080/web-demo/user/任意 思考: 访问路径http://localhost:8080/web-demo/user是否能访问到demo9的doGet方法? 访问路径http://localhost:8080/web-demo/user/a/b是否能访问到demo9的doGet方法? 访问路径http://localhost:8080/web-demo/user/select是否能访问到demo9还是demo8的doGet方法? 答案是: 能、能、demo8，进而我们可以得到的结论是/user/*中的/*代表的是零或多个层级访问目录同时精确匹配优先级要高于目录匹配。 扩展名匹配 12345678910111213141516171819202122package com.itheima.web;import javax.servlet.ServletRequest;import javax.servlet.ServletResponse;import javax.servlet.annotation.WebServlet;/** * UrlPattern: * * 扩展名匹配: *.do */@WebServlet(urlPatterns = &quot;*.do&quot;)public class ServletDemo10 extends MyHttpServlet &#123; @Override protected void doGet(ServletRequest req, ServletResponse res) &#123; System.out.println(&quot;demo10 get...&quot;); &#125; @Override protected void doPost(ServletRequest req, ServletResponse res) &#123; &#125;&#125; 访问路径http://localhost:8080/web-demo/任意.do 注意: 如果路径配置的不是扩展名，那么在路径的前面就必须要加/否则会报错 如果路径配置的是*.do,那么在*.do的前面不能加/,否则会报错 任意匹配 12345678910111213141516171819202122package com.itheima.web;import javax.servlet.ServletRequest;import javax.servlet.ServletResponse;import javax.servlet.annotation.WebServlet;/** * UrlPattern: * * 任意匹配： / */@WebServlet(urlPatterns = &quot;/&quot;)public class ServletDemo11 extends MyHttpServlet &#123; @Override protected void doGet(ServletRequest req, ServletResponse res) &#123; System.out.println(&quot;demo11 get...&quot;); &#125; @Override protected void doPost(ServletRequest req, ServletResponse res) &#123; &#125;&#125; 访问路径http://localhost:8080/demo-web/任意 1234567891011121314151617181920212223package com.itheima.web;import javax.servlet.ServletRequest;import javax.servlet.ServletResponse;import javax.servlet.annotation.WebServlet;/** * UrlPattern: * * 任意匹配： /* */@WebServlet(urlPatterns = &quot;/*&quot;)public class ServletDemo12 extends MyHttpServlet &#123; @Override protected void doGet(ServletRequest req, ServletResponse res) &#123; System.out.println(&quot;demo12 get...&quot;); &#125; @Override protected void doPost(ServletRequest req, ServletResponse res) &#123; &#125;&#125; 访问路径`http://localhost:8080/demo-web/任意 注意:/和/*的区别? 当我们的项目中的Servlet配置了 “/”,会覆盖掉tomcat中的DefaultServlet,当其他的url-pattern都匹配不上时都会走这个Servlet 当我们的项目中配置了&quot;/*&quot;,意味着匹配任意访问路径 DefaultServlet是用来处理静态资源，如果配置了&quot;/&quot;会把默认的覆盖掉，就会引发请求静态资源的时候没有走默认的而是走了自定义的Servlet类，最终导致静态资源不能被访问 小结 urlPattern总共有四种配置方式，分别是精确匹配、目录匹配、扩展名匹配、任意匹配 五种配置的优先级为 精确匹配 &gt; 目录匹配&gt; 扩展名匹配 &gt; /* &gt; / ,无需记，以最终运行结果为准。 4.8 XML配置 前面对应Servlet的配置，我们都使用的是@WebServlet,这个是Servlet从3.0版本后开始支持注解配置，3.0版本前只支持XML配置文件的配置方法。 对于XML的配置步骤有两步: 编写Servlet类 1234567891011121314151617package com.itheima.web;import javax.servlet.ServletRequest;import javax.servlet.ServletResponse;import javax.servlet.annotation.WebServlet;public class ServletDemo13 extends MyHttpServlet &#123; @Override protected void doGet(ServletRequest req, ServletResponse res) &#123; System.out.println(&quot;demo13 get...&quot;); &#125; @Override protected void doPost(ServletRequest req, ServletResponse res) &#123; &#125;&#125; 在web.xml中配置该Servlet 12345678910111213141516171819202122232425262728&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot; version=&quot;4.0&quot;&gt; &lt;!-- Servlet 全类名 --&gt; &lt;servlet&gt; &lt;!-- servlet的名称，名字任意--&gt; &lt;servlet-name&gt;demo13&lt;/servlet-name&gt; &lt;!--servlet的类全名--&gt; &lt;servlet-class&gt;com.itheima.web.ServletDemo13&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;!-- Servlet 访问路径 --&gt; &lt;servlet-mapping&gt; &lt;!-- servlet的名称，要和上面的名称一致--&gt; &lt;servlet-name&gt;demo13&lt;/servlet-name&gt; &lt;!-- servlet的访问路径--&gt; &lt;url-pattern&gt;/demo13&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; 这种配置方式和注解比起来，确认麻烦很多，所以建议大家使用注解来开发。但是大家要认识上面这种配置方式，因为并不是所有的项目都是基于注解开发的。 来源：it 黑马 JavaWeb 教程","categories":[{"name":"Java","slug":"Java","permalink":"http://littlewuuu.com/categories/Java/"}],"tags":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://littlewuuu.com/tags/JavaWeb/"}]},{"title":"HTML&CSS","slug":"黑马/7-HTML&CSS","date":"2022-08-21T22:00:00.000Z","updated":"2022-12-01T15:45:12.682Z","comments":true,"path":"2022/08/22/黑马/7-HTML&CSS/","link":"","permalink":"http://littlewuuu.com/2022/08/22/%E9%BB%91%E9%A9%AC/7-HTML&CSS/","excerpt":"","text":"HTML&amp;CSS 今日目标： 能够掌握课程中讲解的标签的使用 了解css的使用 1，HTML 1.1 介绍 HTML(HyperText Markup Language)：超文本标记语言： 超文本：超越了文本的限制，比普通文本更强大。除了文字信息，还可以定义图片、音频、视频等内容 如上图看到的页面，我们除了能看到一些文字，同时也有大量的图片展示；有些网页也有视频，音频等。这种展示效果超越了文本展示的限制。 标记语言：由标签构成的语言 之前学习的XML就是标记语言，由一个一个的标签组成，HTML 也是由标签组成 。我们在浏览器页面右键可以查看页面的源代码，如下 可以看到如下内容，就是由一个一个的标签组成的 这些标签不像XML那样可以自定义，==HTML中的标签都是预定义好的，运行在浏览器上并由浏览器解析，==然后展示出对应的效果。例如我们想在浏览器上展示出图片就需要使用预定义的 img 标签；想展示可以点击的链接的效果就可以使用预定义的 a 标签等。 HTML 预定义了很多标签，由于我们是Java工程师、是做后端开发，所以不会每个都学习，页面开发是有专门的前端工程来开发。那为什么我们还要学习呢？在公司中或多或少大家也会涉及到前端开发。 简单的给大家聊一下开发流程： 以后我们是通过Java程序从数据库中查询出来数据，然后交给页面进行展示，这样用户就能通过在浏览器通过页面看到数据。 W3C标准： W3C是万维网联盟，这个组成是用来定义标准的。他们规定了一个网页是由三部分组成，分别是： 结构：对应的是 HTML 语言 表现：对应的是 CSS 语言 行为：对应的是 JavaScript 语言 HTML定义页面的整体结构；CSS是用来美化页面，让页面看起来更加美观；JavaScript可以使网页动起来，比如轮播图也就是多张图片自动的进行切换等效果。 1.2 快速入门 需求：编写如下图效果的页面 要实现这个页面，我们需要从以下三步进行实现 新建文本文件，后缀名改为 .html 页面文件的后缀名是 .html，所以需要该后缀名 编写 HTML 结构标签 HTML 是由一个一个的标签组成的，但是它也用于表示结构的标签 12345678&lt;html&gt; &lt;head&gt; &lt;title&gt; &lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt;&lt;/html&gt; html标签是根标签，下面有 head 标签和 body 标签这两个子标签。而 head 标签的 title 子标签是用来定义页面标题名称的，它定义的内容会展示在浏览器的标题位置，如下图红框标记 body 标签的内容会被展示在内容区中，如下图红框标记 在中定义文字 代码如下： 12345678&lt;html&gt; &lt;head&gt; &lt;title&gt;html 快速入门&lt;/title&gt; &lt;/head&gt; &lt;body&gt; 乾坤未定，你我皆是黑马~ &lt;/body&gt;&lt;/html&gt; 同学们在访问其他网站页面时会看到字体颜色是五颜六色的，我们可以该字体颜色吗？当然可以了 font 标签就可以使用，该标签有一个 color 属性可以设置字体颜色，如： 就是将文字设置成了红颜色。那么我们只需要将需要变成红色的文字放在标签体部分就可以了，如下： 12345678&lt;html&gt; &lt;head&gt; &lt;title&gt;html 快速入门&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;font color=&#x27;red&#x27;&gt;乾坤未定，你我皆是黑马~&lt;/font&gt; &lt;/body&gt;&lt;/html&gt; 总结： HTML 文件以.htm或.html为扩展名 HTML 结构标签 HTML 标签不区分大小写 如上案例中的 font 写成 Font 也是一样可以展示出对应的效果的。 HTML 标签属性值 单双引皆可 如上案例中的color属性值使用双引号也是可以的。 HTML 语法松散 比如 font 标签不加结束标签也是可以展示出效果的。但是建议同学们在写的时候还是不要这样做，严格按照要求去写。 1.3 基础标签 基础标签就是一些和文字相关的标签，如下： 接下来我们挨个进行讲解 1.3.1 标题标签 创建模块 在 Idea 中创建模块，而我们现在不需要写java代码，所以 src 目录就可以删除掉。在模块下创建一个html文件夹，该我们今天的所以的页面文件所部放在该文件夹下。模块目录如下 创建页面文件 选中 html 文件夹右键创建页面文件（01-基础标签.html） 创建好后 idea 会自动加上结构标签，如下 我们只需要在 body 标签中书写标签。 书写标题标签 标题标签中 h1最大，h6最小。 123456&lt;h1&gt;我是标题 h1&lt;/h1&gt;&lt;h2&gt;我是标题 h2&lt;/h2&gt;&lt;h3&gt;我是标题 h3&lt;/h3&gt;&lt;h4&gt;我是标题 h4&lt;/h4&gt;&lt;h5&gt;我是标题 h5&lt;/h5&gt;&lt;h6&gt;我是标题 h6&lt;/h6&gt; 通过浏览器查看效果 idea 提供了快捷的打开方式，如下图 浏览器展示效果如下： 1.3.2 hr标签 hr 标签在浏览器中呈现出 横线 的效果。 在页面文件中书写 hr 标签 1&lt;hr&gt; 效果如下： 1.3.3 字体标签 font：字体标签 face 属性：用来设置字体。如 “楷体”、&quot;宋体&quot;等 color 属性：设置文字颜色。颜色有三种表示方式 英文单词：red,pink,blue… 这种方式表示的颜色特别有限，所以一般不用。 rgb(值1,值2,值3)：值的取值范围：0~255 此种方式也就是三原色（红绿蓝）设置方式。 例如： rgb(255,0,0)。 这种书写起来比较麻烦，一般不用。 #值1值2值3：值的范围：00~FF 这种方式是rgb方式的简化写法，以后基本都用此方式。 值1表示红色的范围，值2表示绿色的范围，值3表示蓝色范围。例如： #ff0000 size 属性：设置文字大小 代码演示： 1&lt;font face=&quot;楷体&quot; size=&quot;5&quot; color=&quot;#ff0000&quot;&gt;传智教育&lt;/font&gt; 效果如下： 注意： font 标签已经不建议使用了，以后如果要改变文字字体，大小，颜色可以使用 CSS 进行设置。 1.3.4 换行标签 在页面文件中书写如下内容 123刚察草原绿草如茵，沙柳河水流淌入湖。藏族牧民索南才让家中，茶几上摆着馓子、麻花和水果，炉子上刚煮开的奶茶香气四溢……6月8日下午，习近平总书记来到青海省海北藏族自治州刚察县沙柳河镇果洛藏贡麻村，走进牧民索南才让家中，看望慰问藏族群众。 在浏览器展示的效果如下： 我们可以看到并没有换行。如果要实现换行效果，需要使用 换行标签（br标签）。 修改页面文件内容如下： 123刚察草原绿草如茵，沙柳河水流淌入湖。藏族牧民索南才让家中，茶几上摆着馓子、麻花和水果，炉子上刚煮开的奶茶香气四溢……&lt;br&gt;6月8日下午，习近平总书记来到青海省海北藏族自治州刚察县沙柳河镇果洛藏贡麻村，走进牧民索南才让家中，看望慰问藏族群众。 浏览器打开效果如下： 现在就有换行效果了。 1.3.5 段落标签 上面文字展示的效果还是不太好，我们想让每一段上下都加空行。此时就需要使用段落标签（p标签） 在页面文件中书写如下内容： 123456&lt;p&gt;刚察草原绿草如茵，沙柳河水流淌入湖。藏族牧民索南才让家中，茶几上摆着馓子、麻花和水果，炉子上刚煮开的奶茶香气四溢……&lt;/p&gt;&lt;p&gt;6月8日下午，习近平总书记来到青海省海北藏族自治州刚察县沙柳河镇果洛藏贡麻村，走进牧民索南才让家中，看望慰问藏族群众。&lt;/p&gt; 在浏览器展示的效果如下： 这种效果就会比之前的效果好一些，呈现出段落的效果。 1.3.6 加粗、斜体、下划线标签 b：加粗标签 i：斜体标签 u：下划线标签，在文字的下方有一条横线 代码如下： 123&lt;b&gt;沙柳河水流淌&lt;/b&gt;&lt;br&gt;&lt;i&gt;沙柳河水流淌&lt;/i&gt;&lt;br&gt;&lt;u&gt;沙柳河水流淌&lt;/u&gt;&lt;br&gt; 在浏览器展示的效果如下： 1.3.7 居中标签 center ：文本居中 代码如下： 1234&lt;hr&gt;&lt;center&gt; &lt;b&gt;沙柳河水流淌&lt;/b&gt;&lt;/center&gt; 在浏览器效果如下： 1.3.8 案例 实现如下图所示页面效果： 此案例同学们自己实现，用我们学过的基础标签。 注意：在上图页面中版权所有里有特殊字符，需要使用转义字符。有如下转义字符： 1.4 图片、音频、视频标签 img：定义图片 src：规定显示图像的 URL（统一资源定位符） height：定义图像的高度 width：定义图像的宽度 audio：定义音频。支持的音频格式：MP3、WAV、OGG src：规定音频的 URL controls：显示播放控件 video：定义视频。支持的音频格式：MP4, WebM、OGG src：规定视频的 URL controls：显示播放控件 尺寸单位： height属性和width属性有两种设置方式： 像素：单位是px 百分比。占父标签的百分比。例如宽度设置为 50%，意思就是占它的父标签宽度的一般（50%） 资源路径： 图片，音频，视频标签都有src属性，而src是用来指定对应的图片，音频，视频文件的路径。此处的图片，音频，视频就称为资源。资源路径有如下两种设置方式： 绝对路径：完整路径 这里的绝对路径是网络中的绝对路径。 格式为： 协议://ip地址:端口号/资源名称。 如： 1&lt;img src=&quot;https://th.bing.com/th/id/R33674725d9ae34f86e3835ae30b20afe?rik=Pb3C9e5%2b%2b3a9Vw&amp;riu=http%3a%2f%2fwww.desktx.com%2fd%2ffile%2fwallpaper%2fscenery%2f20180626%2f4c8157d07c14a30fd76f9bc110b1314e.jpg&amp;ehk=9tpmnrrRNi0eBGq3CnhwvuU8PPmKuy1Yma0zL%2ba14T0%3d&amp;risl=&amp;pid=ImgRaw&quot; width=&quot;300&quot; height=&quot;400&quot;&gt; 这里src属性的值就是网络中的绝对路径。 相对路径：相对位置关系 找页面和其他资源的相对路径。 ./ 表示当前路径 …/ 表示上一级路径 …/…/ 表示上两级路径 如模块目录结构如下： 在 01-基础标签.html 里的标签中找不同的图片，路径写法不同 1234&lt;!--在该页面找a.jpg，就需要先回到上一级目录，该级目录有img目录，进入该目录就可以找到 a.jpg图片--&gt;&lt;img src=&quot;../img/a.jpg&quot; width=&quot;300&quot; height=&quot;400&quot;&gt;&lt;!--该页面和aa.jpg 是在同一级下，所以可以直接写 图片的名称，也可以写成 ./aa.jpg--&gt;&lt;img src=&quot;aa.jpg&quot; width=&quot;300&quot; height=&quot;400&quot;&gt; 使用这些标签的代码如下： 123&lt;img src=&quot;../img/a.jpg&quot; width=&quot;300&quot; height=&quot;400&quot;&gt;&lt;audio src=&quot;b.mp3&quot; controls&gt;&lt;/audio&gt;&lt;video src=&quot;c.mp4&quot; controls width=&quot;500&quot; height=&quot;300&quot;&gt;&lt;/video&gt; 在浏览器展示的效果如下： 1.5 超链接标签 在网页中可以看到很多超链接标签，如下 上图红框中的都是超链接，当我们点击这些超链接时会跳转到其他的页面或者资源。而超链接使用的是 a 标签。 a 标签属性： href：指定访问资源的URL target：指定打开资源的方式 _self：默认值，在当前页面打开 _blank：在空白页面打开 代码演示： 12345678910&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;a href=&quot;https://www.itcast.cn&quot; target=&quot;_self&quot;&gt;点我有惊喜&lt;/a&gt;&lt;/body&gt;&lt;/html&gt; 效果图示： 当我们将 target 属性值设置为 _blank，效果图示： 1.6 列表标签 HTML 中列表分为 有序列表 如下图，页面效果中是有标号对每一项进行标记的。 无序列表 如下图，页面效果中没有标号对每一项进行标记，而是使用 点 进行标记。 标签说明： 有序列表中的 type 属性用来指定标记的标号的类型（数字、字母、罗马数字等） 无序列表中的 type 属性用来指定标记的形状 代码演示： 1234567891011121314151617181920&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;ol type=&quot;A&quot;&gt; &lt;li&gt;咖啡&lt;/li&gt; &lt;li&gt;茶&lt;/li&gt; &lt;li&gt;牛奶&lt;/li&gt; &lt;/ol&gt; &lt;ul type=&quot;circle&quot;&gt; &lt;li&gt;咖啡&lt;/li&gt; &lt;li&gt;茶&lt;/li&gt; &lt;li&gt;牛奶&lt;/li&gt; &lt;/ul&gt;&lt;/body&gt;&lt;/html&gt; 1.7 表格标签 如上图就是一个表格，表格可以使用如下标签定义 table ：定义表格 border：规定表格边框的宽度 width ：规定表格的宽度 cellspacing：规定单元格之间的空白 tr ：定义行 align：定义表格行的内容对齐方式 td ：定义单元格 rowspan:规定单元格可横跨的行数 colspan:规定单元格可横跨的列数 th：定义表头单元格 代码演示： 1234567891011121314151617181920212223242526272829303132333435363738&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;table border=&quot;1&quot; cellspacing=&quot;0&quot; width=&quot;500&quot;&gt; &lt;tr&gt; &lt;th&gt;序号&lt;/th&gt; &lt;th&gt;品牌logo&lt;/th&gt; &lt;th&gt;品牌名称&lt;/th&gt; &lt;th&gt;企业名称&lt;/th&gt; &lt;/tr&gt; &lt;tr align=&quot;center&quot;&gt; &lt;td&gt;010&lt;/td&gt; &lt;td&gt;&lt;img src=&quot;../img/三只松鼠.png&quot; width=&quot;60&quot; height=&quot;50&quot;&gt;&lt;/td&gt; &lt;td&gt;三只松鼠&lt;/td&gt; &lt;td&gt;三只松鼠&lt;/td&gt; &lt;/tr&gt; &lt;tr align=&quot;center&quot;&gt; &lt;td&gt;009&lt;/td&gt; &lt;td&gt;&lt;img src=&quot;../img/优衣库.png&quot; width=&quot;60&quot; height=&quot;50&quot;&gt;&lt;/td&gt; &lt;td&gt;优衣库&lt;/td&gt; &lt;td&gt;优衣库&lt;/td&gt; &lt;/tr&gt; &lt;tr align=&quot;center&quot;&gt; &lt;td&gt;008&lt;/td&gt; &lt;td&gt;&lt;img src=&quot;../img/小米.png&quot; width=&quot;60&quot; height=&quot;50&quot;&gt;&lt;/td&gt; &lt;td&gt;小米&lt;/td&gt; &lt;td&gt;小米科技有限公司&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt;&lt;/body&gt;&lt;/html&gt; 1.8 布局标签 这两个标签，一般都是和css结合到一块使用来实现页面的布局。 div标签 在浏览器上会有换行的效果，而 span 标签在浏览器上没有换行效果。 代码演示： 12345678910111213&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt;我是div&lt;/div&gt; &lt;div&gt;我是div&lt;/div&gt; &lt;span&gt;我是span&lt;/span&gt; &lt;span&gt;我是span&lt;/span&gt;&lt;/body&gt;&lt;/html&gt; 浏览器效果如下： 1.9 表单标签 表单标签效果大家其实都不陌生，像登陆页面、注册页面等都是表单。 像这样的表单就是用来采集用户输入的数据，然后将数据发送到服务端，服务端会对数据库进行操作，比如注册就是将数据保存到数据库中，而登陆就是根据用户名和密码进行数据库的查询操作。 表单是很重要的标签，需要大家重点来学习。 1.9.1 表单标签概述 表单：在网页中主要负责数据采集功能，使用标签定义表单 表单项(元素)：不同类型的 input 元素、下拉列表、文本域等 form 是表单标签，它在页面上没有任何展示的效果。需要借助于表单项标签来展示不同的效果。 1.9.2 form标签属性 action：规定当提交表单时向何处发送表单数据，该属性值就是URL 以后会将数据提交到服务端，该属性需要书写服务端的URL。而今天我们可以书写 # ，表示提交到当前页面来看效果。 method ：规定用于发送表单数据的方式 method取值有如下两种： get：默认值。如果不设置method属性则默认就是该值 请求参数会拼接在URL后边 url的长度有限制 4KB post： 浏览器会将数据放到http请求消息体中 请求参数无限制的 1.9.3 代码演示 由于表单标签在页面上没有任何展示的效果，所以在演示的过程是会先使用 input 这个表单项标签展示输入框效果。 代码如下： 12345678910111213&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;form&gt; &lt;input type=&quot;text&quot;&gt; &lt;input type=&quot;submit&quot;&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 浏览器展示效果如下： 从效果可以看到页面有一个输入框，用户可 以在数据框中输入自己想输入的内容，点击提交按钮以后会将数据发送到服务端，当然现在肯定不能实现。现在我们可以将 form 标签的 action 属性值设置为 # ，将其将数据提交到当前页面。还需要注意一点，要想提交数据，input 输入框必须设置 name 属性。代码如下： 12345678910111213&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;form action=&quot;#&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;username&quot;&gt; &lt;input type=&quot;submit&quot;&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 浏览器展示效果如下： 在输入框输入 hehe ，然后点击 提交 按钮，就能看到如下效果 我们可以看到在浏览器的地址栏的URL后拼接了我们提交的数据。username 就是输入框 name 属性值，而 hehe 就是我们在输入框输入的内容。 接下来我们来聊 method 属性，默认是 method = 'get'，所以该取值就会将数据拼接到URL的后面。那我们将 method 属性值设置为 post，浏览器的效果如下： 从上图可以看出数据并没有拼接到 URL 后，那怎么看提交的数据呢？我们可以使用浏览器的开发者工具来查看 按照如上步骤操作能看到如下页面 重新提交数据后，可以看到提交的数据，如下图 1.10 表单项标签 表单项标签有很多，不同的表单项标签有不同的展示效果。表单项标签可以分为以下三个： &lt;input&gt;：表单项，通过type属性控制输入形式 input 标签有个 type 属性。 type 属性的取值不同，展示的效果也不一样 &lt;select&gt;：定义下拉列表，&lt;option&gt; 定义列表项 如下图就是下拉列表的效果： &lt;textarea&gt;：文本域 如下图就是文本域效果。它可以输入多行文本，而 input 数据框只能输入一行文本。 注意： 以上标签项的内容要想提交，必须得定义 name 属性。 每一个标签都有id属性，id属性值是唯一的标识。 单选框、复选框、下拉列表需要使用 value 属性指定提交的值。 代码演示： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;form action=&quot;#&quot; method=&quot;post&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;id&quot; value=&quot;123&quot;&gt; &lt;!-- label 的作用是扩大区域，使用 for 和 Input 标签的 id 使两者关联起来--&gt; &lt;label for=&quot;username&quot;&gt;用户名：&lt;/label&gt; &lt;input type=&quot;text&quot; name=&quot;Username&quot; id=&quot;username&quot;&gt;&lt;br&gt; &lt;label for=&quot;password&quot;&gt;密码：&lt;/label&gt; &lt;input type=&quot;password&quot; name=&quot;password&quot; id=&quot;password&quot;&gt;&lt;br&gt; 性别：name 都是 “gender” 达到互斥效果 value=&quot;1&quot; 和 value=&quot;2&quot; 用于区分两者 &lt;input type=&quot;radio&quot; name=&quot;gender&quot; value=&quot;1&quot; id=&quot;male&quot;&gt; &lt;label for=&quot;male&quot;&gt;男&lt;/label&gt; &lt;input type=&quot;radio&quot; name=&quot;gender&quot; value=&quot;2&quot; id=&quot;female&quot;&gt; &lt;label for=&quot;female&quot;&gt;女&lt;/label&gt; &lt;br&gt; 爱好： &lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; value=&quot;1&quot;&gt; 旅游 &lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; value=&quot;2&quot;&gt; 电影 &lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; value=&quot;3&quot;&gt; 游戏 &lt;br&gt; 头像：file 完成文件上传 &lt;input type=&quot;file&quot;&gt;&lt;br&gt; 城市: &lt;select name=&quot;city&quot;&gt; &lt;option&gt;北京&lt;/option&gt; &lt;option value=&quot;shanghai&quot;&gt;上海&lt;/option&gt; &lt;!--提交的就是 shanghai 而不是 上海--&gt; &lt;option&gt;广州&lt;/option&gt; &lt;/select&gt; &lt;br&gt; 个人描述： &lt;textarea cols=&quot;20&quot; rows=&quot;5&quot; name=&quot;desc&quot;&gt;&lt;/textarea&gt; &lt;br&gt; &lt;br&gt; &lt;input type=&quot;submit&quot; value=&quot;免费注册&quot;&gt; &lt;input type=&quot;reset&quot; value=&quot;重置&quot;&gt; &lt;input type=&quot;button&quot; value=&quot;一个按钮&quot;&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 在浏览器的效果如下： 2，CSS 2.1 概述 ==CSS 是一门语言，用于控制网页表现。==我们之前介绍过W3C标准。W3C标准规定了网页是由以下组成： 结构：HTML 表现：CSS 行为：JavaScript CSS也有一个专业的名字：Cascading Style Sheet（层叠样式表）。 如下面的代码，style 标签中定义的就是css代码。该代码描述了将 div 标签的内容的字体颜色设置为 红色。 123456789101112131415&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;style&gt; div&#123; //所有的 div 标签都应用这个样式 color: red; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt;Hello CSS~&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 在浏览器中的效果如下： 2.2 css 导入方式 css 导入方式其实就是 css 代码和 html 代码的结合方式。CSS 导入 HTML有三种方式： 内联样式：在标签内部使用style属性，属性值是css属性键值对 1&lt;div style=&quot;color: red&quot;&gt;Hello CSS~&lt;/div&gt; 给方式只能作用在这一个标签上，如果其他的标签也想使用同样的样式，那就需要在其他标签上写上相同的样式。复用性太差。 内部样式：定义标签，在标签内部定义css样式 12345&lt;style type=&quot;text/css&quot;&gt; div&#123; color: red; &#125;&lt;/style&gt; 这种方式可以做到在该页面中复用。 外部样式：定义link标签，引入外部的css文件 编写一个css文件。名为：demo.css，内容如下: 123div&#123; color: red;&#125; 在html中引入 css 文件。 1&lt;link rel=&quot;stylesheet&quot; href=&quot;demo.css&quot;&gt; 这种方式可以在多个页面进行复用。其他的页面想使用同样的样式，只需要使用 link 标签引入该css文件。 rel 用来解析 css 标签 代码演示： 项目目录结构如下： 编写页面 02-导入方式.html，内容如下： 1234567891011121314151617181920&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;style&gt; span&#123; //针对所有的&lt;span&gt;标签 color: red; &#125; &lt;/style&gt; &lt;link href=&quot;../css/demo.css&quot; rel=&quot;stylesheet&quot;&gt;&lt;/head&gt;&lt;body&gt; &lt;div style=&quot;color: red&quot;&gt;hello css&lt;/div&gt; &lt;span&gt;hello css &lt;/span&gt; &lt;p&gt;hello css&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 2.3 css 选择器 css 选择器就是选取需设置样式的元素（标签），比如如下css代码： 123div &#123; color:red;&#125; 如上代码中的 div 就是 css 中的选择器。我们只讲下面三种选择器： 元素选择器 格式： 1元素名称&#123;color: red;&#125; 例子： 1div &#123;color:red&#125; /*该代码表示将页面中所有的div标签的内容的颜色设置为红色*/ id选择器 格式： 1#id属性值&#123;color: red;&#125; 例子： html代码如下： 1&lt;div id=&quot;name&quot;&gt;hello css2&lt;/div&gt; css代码如下： 1#name&#123;color: red;&#125;/*该代码表示将页面中所有的id属性值是 name 的标签的内容的颜色设置为红色*/ 类选择器 格式： 1.class属性值&#123;color: red;&#125; 例子： html代码如下： 1&lt;div class=&quot;cls&quot;&gt;hello css3&lt;/div&gt; css代码如下： 1.cls&#123;color: red;&#125; /*该代码表示将页面中所有的class属性值是 cls 的标签的内容的颜色设置为红色*/ 代码演示： 123456789101112131415161718192021222324252627&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;style&gt; //如果定义了多个重复的，那么按照作用范围小的生效 div&#123; color: red; &#125; #name&#123; color: blue; &#125; .cls&#123; color: pink; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt;div1&lt;/div&gt; &lt;div id=&quot;name&quot;&gt;div2&lt;/div&gt; &lt;div class=&quot;cls&quot;&gt;div3&lt;/div&gt; &lt;span class=&quot;cls&quot;&gt;span&lt;/span&gt;&lt;/body&gt;&lt;/html&gt; 2.4 css 属性 css属性我们不作为重点讲解。我们简单的看一下css的文档 css有很多css属性，你要想把它们都学会，需要花费很长的时间。而我们作为java程序员，不需要重点掌握这部分内容。对于网页三剑客中css是对我们要求最低的。给大家简单介绍一下文档怎么查看即可，如下我们看一个 background-color 属性 点击进去后能看到下面界面 上面就列举了该属性的具体的使用，你也可以点击下面的 亲自试一试 看效果。 来源：it 黑马 JavaWeb 教程","categories":[{"name":"Java","slug":"Java","permalink":"http://littlewuuu.com/categories/Java/"}],"tags":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://littlewuuu.com/tags/JavaWeb/"}]},{"title":"MybatisExercise","slug":"黑马/5-MybatisExercise","date":"2022-08-21T22:00:00.000Z","updated":"2022-12-01T15:45:18.635Z","comments":true,"path":"2022/08/22/黑马/5-MybatisExercise/","link":"","permalink":"http://littlewuuu.com/2022/08/22/%E9%BB%91%E9%A9%AC/5-MybatisExercise/","excerpt":"","text":"Mybatis练习 目标 能够使用映射配置文件实现CRUD操作 能够使用注解实现CRUD操作 1，配置文件实现CRUD 如上图所示产品原型，里面包含了品牌数据的 查询 、按条件查询、添加、删除、批量删除、修改 等功能，而这些功能其实就是对数据库表中的数据进行CRUD操作。接下来我们就使用Mybatis完成品牌数据的增删改查操作。以下是我们要完成功能列表： 查询 查询所有数据 查询详情 条件查询 添加 修改 修改全部字段 修改动态字段 删除 删除一个 批量删除 我们先将必要的环境准备一下。 1.1 环境准备 数据库表（tb_brand）及数据准备 1234567891011121314151617181920212223-- 删除tb_brand表drop table if exists tb_brand;-- 创建tb_brand表create table tb_brand( -- id 主键 id int primary key auto_increment, -- 品牌名称 brand_name varchar(20), -- 企业名称 company_name varchar(20), -- 排序字段 ordered int, -- 描述信息 description varchar(100), -- 状态：0：禁用 1：启用 status int);-- 添加数据insert into tb_brand (brand_name, company_name, ordered, description, status)values (&#x27;三只松鼠&#x27;, &#x27;三只松鼠股份有限公司&#x27;, 5, &#x27;好吃不上火&#x27;, 0), (&#x27;华为&#x27;, &#x27;华为技术有限公司&#x27;, 100, &#x27;华为致力于把数字世界带入每个人、每个家庭、每个组织，构建万物互联的智能世界&#x27;, 1), (&#x27;小米&#x27;, &#x27;小米科技有限公司&#x27;, 50, &#x27;are you ok&#x27;, 1); 实体类 Brand 在 com.itheima.pojo 包下创建 Brand 实体类。 12345678910111213141516public class Brand &#123; // id 主键 private Integer id; // 品牌名称 private String brandName; // 企业名称 private String companyName; // 排序字段 private Integer ordered; // 描述信息 private String description; // 状态：0：禁用 1：启用 private Integer status; //省略 setter and getter。自己写时要补全这部分代码&#125; 编写测试用例 测试代码需要在 test/java 目录下创建包及测试用例。项目结构如下： 安装 MyBatisX 插件 MybatisX 是一款基于 IDEA 的快速开发插件，为效率而生。 主要功能 XML映射配置文件 和 接口方法 间相互跳转 根据接口方法生成 statement 安装方式 点击 file ，选择 settings ，就能看到如下图所示界面 注意：安装完毕后需要重启IDEA 插件效果 红色头绳的表示映射配置文件，蓝色头绳的表示mapper接口。在mapper接口点击红色头绳的小鸟图标会自动跳转到对应的映射配置文件，在映射配置文件中点击蓝色头绳的小鸟图标会自动跳转到对应的mapper接口。也可以在mapper接口中定义方法，自动生成映射配置文件中的 statement ，如图所示 1.2 查询所有数据 如上图所示就页面上展示的数据，而这些数据需要从数据库进行查询。接下来我们就来讲查询所有数据功能，而实现该功能我们分以下步骤进行实现： 编写接口方法：Mapper接口 参数：无 查询所有数据功能是不需要根据任何条件进行查询的，所以此方法不需要参数。 结果：List 我们会将查询出来的每一条数据封装成一个 Brand 对象，而多条数据封装多个 Brand 对象，需要将这些对象封装到List集合中返回。 执行方法、测试 1.2.1 编写接口方法 在 com.itheima.mapper 包写创建名为 BrandMapper 的接口。并在该接口中定义 List&lt;Brand&gt; selectAll() 方法。 1234567public interface BrandMapper &#123; /** * 查询所有 */ List&lt;Brand&gt; selectAll();&#125; 1.2.2 编写SQL语句 在 reources 下创建 com/itheima/mapper 目录结构，并在该目录下创建名为 BrandMapper.xml 的映射配置文件 1234567891011&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.itheima.mapper.BrandMapper&quot;&gt; &lt;select id=&quot;selectAll&quot; resultType=&quot;brand&quot;&gt; select * from tb_brand; &lt;/select&gt;&lt;/mapper&gt; 1.2.3 编写测试方法 在 MybatisTest 类中编写测试查询所有的方法 123456789101112131415161718192021@Testpublic void testSelectAll() throws IOException &#123; //1. 获取SqlSessionFactory String resource = &quot;mybatis-config.xml&quot;; InputStream inputStream = Resources.getResourceAsStream(resource); SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); //2. 获取SqlSession对象 SqlSession sqlSession = sqlSessionFactory.openSession(); //3. 获取Mapper接口的代理对象 BrandMapper brandMapper = sqlSession.getMapper(BrandMapper.class); //4. 执行方法 List&lt;Brand&gt; brands = brandMapper.selectAll(); System.out.println(brands); //5. 释放资源 sqlSession.close();&#125; 注意：现在我们感觉测试这部分代码写起来特别麻烦，我们可以先忍忍。以后我们只会写上面的第3步的代码，其他的都不需要我们来完成。 执行测试方法结果如下： 从上面结果我们看到了问题，有些数据封装成功了，而有些数据并没有封装成功。为什么这样呢？ 这个问题可以通过两种方式进行解决： 给字段起别名 使用resultMap定义字段和属性的映射关系 1.2.4 起别名解决上述问题 从上面结果可以看到 brandName 和 companyName 这两个属性的数据没有封装成功，查询 实体类 和 表中的字段 发现，在实体类中属性名是 brandName 和 companyName ，而表中的字段名为 brand_name 和 company_name，如下图所示 。那么我们只需要保持这两部分的名称一致这个问题就迎刃而解。 我们可以在写sql语句时给这两个字段起别名，将别名定义成和属性名一致即可。 12345&lt;select id=&quot;selectAll&quot; resultType=&quot;brand&quot;&gt; select id, brand_name as brandName, company_name as companyName, ordered, description, status from tb_brand;&lt;/select&gt; 而上面的SQL语句中的字段列表书写麻烦，如果表中还有更多的字段，同时其他的功能也需要查询这些字段时就显得我们的代码不够精炼。Mybatis提供了sql 片段可以提高sql的复用性。 SQL片段： 将需要复用的SQL片段抽取到 sql 标签中 123&lt;sql id=&quot;brand_column&quot;&gt; id, brand_name as brandName, company_name as companyName, ordered, description, status&lt;/sql&gt; id属性值是唯一标识，引用时也是通过该值进行引用。 在原sql语句中进行引用 使用 include 标签引用上述的 SQL 片段，而 refid 指定上述 SQL 片段的id值。 12345&lt;select id=&quot;selectAll&quot; resultType=&quot;brand&quot;&gt; select &lt;include refid=&quot;brand_column&quot; /&gt; from tb_brand;&lt;/select&gt; 1.2.5 使用resultMap解决上述问题 起别名 + sql片段的方式可以解决上述问题，但是它也存在问题。如果还有功能只需要查询部分字段，而不是查询所有字段，那么我们就需要再定义一个 SQL 片段，这就显得不是那么灵活。 那么我们也可以使用resultMap来定义字段和属性的映射关系的方式解决上述问题。 在映射配置文件中使用resultMap定义 字段 和 属性 的映射关系 123456789101112&lt;resultMap id=&quot;brandResultMap&quot; type=&quot;brand&quot;&gt; &lt;!-- id：完成主键字段的映射 column：表的列名 property：实体类的属性名 result：完成一般字段的映射 column：表的列名 property：实体类的属性名 --&gt; &lt;result column=&quot;brand_name&quot; property=&quot;brandName&quot;/&gt; &lt;result column=&quot;company_name&quot; property=&quot;companyName&quot;/&gt;&lt;/resultMap&gt; 注意：在上面只需要定义 字段名 和 属性名 不一样的映射，而一样的则不需要专门定义出来。 SQL语句正常编写 1234&lt;select id=&quot;selectAll&quot; resultMap=&quot;brandResultMap&quot;&gt; select * from tb_brand;&lt;/select&gt; 总结两个步骤 定义 标签，里面标注映射关系 在标签中用 resultMap 代替原来的 resultType 1.2.6 小结 实体类属性名 和 数据库表列名 不一致，不能自动封装数据 ==起别名：==在SQL语句中，对不一样的列名起别名，别名和实体类属性名一样 可以定义 片段，提升复用性 ==resultMap：==定义 完成不一致的属性名和列名的映射 而我们最终选择使用 resultMap的方式。查询映射配置文件中查询所有的 statement 书写如下： 12345678910111213141516171819 &lt;resultMap id=&quot;brandResultMap&quot; type=&quot;brand&quot;&gt; &lt;!-- id：完成主键字段的映射 column：表的列名 property：实体类的属性名 result：完成一般字段的映射 column：表的列名 property：实体类的属性名 --&gt; &lt;result column=&quot;brand_name&quot; property=&quot;brandName&quot;/&gt; &lt;result column=&quot;company_name&quot; property=&quot;companyName&quot;/&gt;&lt;/resultMap&gt;&lt;select id=&quot;selectAll&quot; resultMap=&quot;brandResultMap&quot;&gt; select * from tb_brand;&lt;/select&gt; 1.3 查询详情(selectByID) 有些数据的属性比较多，在页面表格中无法全部实现，而只会显示部分，而其他属性数据的查询可以通过 查看详情 来进行查询，如上图所示。 查看详情功能实现步骤： 编写接口方法：Mapper接口 参数：id 查看详情就是查询某一行数据，所以需要根据id进行查询。而id以后是由页面传递过来。 结果：Brand 根据id查询出来的数据只要一条，而将一条数据封装成一个Brand对象即可 编写SQL语句：SQL映射文件 执行方法、进行测试 1.3.1 编写接口方法 在 BrandMapper 接口中定义根据id查询数据的方法 1234/** * 查看详情：根据Id查询 */Brand selectById(int id); 1.3.2 编写SQL语句 在 BrandMapper.xml 映射配置文件中编写 statement，使用 resultMap 而不是使用 resultType 1234&lt;select id=&quot;selectById&quot; resultMap=&quot;brandResultMap&quot;&gt; select * from tb_brand where id = #&#123;id&#125;;&lt;/select&gt; 注意：上述SQL中的 #{id}先这样写，一会我们再详细讲解 1.3.3 编写测试方法 在 test/java 下的 com.itheima.mapper 包下的 MybatisTest类中 定义测试方法 1234567891011121314151617181920212223 @Testpublic void testSelectById() throws IOException &#123; //接收参数，该id以后需要传递过来 int id = 1; //1. 获取SqlSessionFactory String resource = &quot;mybatis-config.xml&quot;; InputStream inputStream = Resources.getResourceAsStream(resource); SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); //2. 获取SqlSession对象 SqlSession sqlSession = sqlSessionFactory.openSession(); //3. 获取Mapper接口的代理对象 BrandMapper brandMapper = sqlSession.getMapper(BrandMapper.class); //4. 执行方法 Brand brand = brandMapper.selectById(id); System.out.println(brand); //5. 释放资源 sqlSession.close();&#125; 执行测试方法结果如下： 1.3.4 参数占位符 查询到的结果很好理解就是id为1的这行数据。而这里我们需要看控制台显示的SQL语句，能看到使用？进行占位。说明我们在映射配置文件中的写的 #&#123;id&#125; 最终会被？进行占位。接下来我们就聊聊映射配置文件中的参数占位符。 mybatis提供了两种参数占位符： #{} ：执行SQL时，会将 #{} 占位符替换为？，将来自动设置参数值。从上述例子可以看出使用#{} 底层使用的是 PreparedStatement ${} : 会存在SQL 注入问题 表名或列名不固定时使用 1234&lt;select id=&quot;selectById&quot; resultMap=&quot;brandResultMap&quot;&gt; select * from tb_brand where id = $&#123;id&#125;;&lt;/select&gt; 重新运行查看结果如下： ==注意：==从上面两个例子可以看出，以后开发我们使用 #{} 参数占位符。 1.3.5 parameterType使用 对于有参数的mapper接口方法，我们在映射配置文件中应该配置 ParameterType 来指定参数类型。只不过该属性都可以省略。如下图： 1234&lt;select id=&quot;selectById&quot; parameterType=&quot;int&quot; resultMap=&quot;brandResultMap&quot;&gt; select * from tb_brand where id = $&#123;id&#125;;&lt;/select&gt; 1.3.6 SQL语句中特殊字段处理 以后肯定会在SQL语句中写一下特殊字符，比如某一个字段大于某个值，如下图 可以看出报错了，因为映射配置文件是xml类型的问题，而 &gt; &lt; 等这些字符在xml中有特殊含义，所以此时我们需要将这些符号进行转义，可以使用以下两种方式进行转义 转义字符 下图的 &amp;lt; 就是 &lt; 的转义字符。 1.4 多条件查询 我们经常会遇到如上图所示的多条件查询，将多条件查询的结果展示在下方的数据列表中。而我们做这个功能需要分析最终的SQL语句应该是什么样，思考两个问题 条件表达式 如何连接 条件字段 企业名称 和 品牌名称 需要进行模糊查询，所以条件应该是： 简单的分析后，我们来看功能实现的步骤： 编写接口方法 参数：所有查询条件 结果：List 在映射配置文件中编写SQL语句 编写测试方法并执行 1.4.1 编写接口方法 在 BrandMapper 接口中定义多条件查询的方法。 而该功能有三个参数，我们就需要考虑定义接口时，参数应该如何定义。Mybatis针对多参数有多种实现 使用 @Param(&quot;参数名称&quot;) 标记每一个参数，在映射配置文件中就需要使用 #&#123;参数名称&#125; 进行占位 1List&lt;Brand&gt; selectByCondition(@Param(&quot;status&quot;) int status, @Param(&quot;companyName&quot;) String companyName,@Param(&quot;brandName&quot;) String brandName); 将多个参数封装成一个 实体对象 ，将该实体对象作为接口的方法参数。该方式要求在映射配置文件的SQL中使用 #&#123;内容&#125; 时，里面的内容必须和实体类属性名保持一致。 1List&lt;Brand&gt; selectByCondition(Brand brand); 将多个参数封装到map集合中，将map集合作为接口的方法参数。该方式要求在映射配置文件的SQL中使用 #&#123;内容&#125; 时，里面的内容必须和map集合中键的名称一致。 1List&lt;Brand&gt; selectByCondition(Map map); 1.4.2 编写SQL语句 在 BrandMapper.xml 映射配置文件中编写 statement，使用 resultMap 而不是使用 resultType 1234567&lt;select id=&quot;selectByCondition&quot; resultMap=&quot;brandResultMap&quot;&gt; select * from tb_brand where status = #&#123;status&#125; and company_name like #&#123;companyName&#125; and brand_name like #&#123;brandName&#125;&lt;/select&gt; 1.4.3 编写测试方法 在 test/java 下的 com.itheima.mapper 包下的 MybatisTest类中 定义测试方法 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950@Testpublic void testSelectByCondition() throws IOException &#123; //接收参数 int status = 1; String companyName = &quot;华为&quot;; String brandName = &quot;华为&quot;; // 处理参数 companyName = &quot;%&quot; + companyName + &quot;%&quot;; brandName = &quot;%&quot; + brandName + &quot;%&quot;; //1. 获取SqlSessionFactory String resource = &quot;mybatis-config.xml&quot;; InputStream inputStream = Resources.getResourceAsStream(resource); SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); //2. 获取SqlSession对象 SqlSession sqlSession = sqlSessionFactory.openSession(); //3. 获取Mapper接口的代理对象 BrandMapper brandMapper = sqlSession.getMapper(BrandMapper.class); //4. 执行方法 //方式一 ：接口方法参数使用 @Param 方式调用的方法 //接口里： public List&lt;Brand&gt; selectByContion(@Param(&quot;status&quot;) int status, @Param(&quot;companyName&quot;) String companyName, @Param(&quot;brandName&quot;) String brandName); //List&lt;Brand&gt; brands = brandMapper.selectByCondition(status, companyName, brandName); //写在接口里的函数 //方式二 ：接口方法参数是 实体类对象 方式调用的方法 //封装对象 /* Brand brand = new Brand(); brand.setStatus(status); brand.setCompanyName(companyName); brand.setBrandName(brandName);*/ //List&lt;Brand&gt; brands = brandMapper.selectByCondition(brand); //方式三 ：接口方法参数是 map集合对象 方式调用的方法 Map map = new HashMap(); map.put(&quot;status&quot; , status); map.put(&quot;companyName&quot;, companyName); map.put(&quot;brandName&quot; , brandName); List&lt;Brand&gt; brands = brandMapper.selectByCondition(map); System.out.println(brands); //5. 释放资源 sqlSession.close();&#125; 1.4.4 动态SQL 上述功能实现存在很大的问题。用户在输入条件时，肯定不会所有的条件都填写，这个时候我们的SQL语句就不能那样写的 例如用户只输入 当前状态 时，SQL语句就是 1select * from tb_brand where status = #&#123;status&#125; 而用户如果只输入企业名称时，SQL语句就是 1select * from tb_brand where company_name like #&#123;companName&#125; 而用户如果输入了 当前状态 和 企业名称 时，SQL语句又不一样 1select * from tb_brand where status = #&#123;status&#125; and company_name like #&#123;companName&#125; 针对上述的需要，Mybatis对动态SQL有很强大的支撑： if where choose (when, otherwise) trim (where, set) foreach 我们先学习 if 标签和 where 标签： if 标签：条件判断 test 属性：逻辑表达式 12345678910111213141516&lt;select id=&quot;selectByCondition&quot; resultMap=&quot;brandResultMap&quot;&gt; select * from tb_brand where &lt;if test=&quot;status != null&quot;&gt; status = #&#123;status&#125; &lt;/if&gt; &lt;if test=&quot;companyName != null and companyName != &#x27;&#x27; &quot;&gt; //companyName 是调用函数的时候传进来的参数 and company_name like #&#123;companyName&#125; &lt;/if&gt; &lt;if test=&quot;brandName != null and brandName != &#x27;&#x27; &quot;&gt; and brand_name like #&#123;brandName&#125; &lt;/if&gt;&lt;/select&gt; 如上的这种SQL语句就会根据传递的参数值进行动态的拼接。如果此时status和companyName有值那么就会值拼接这两个条件。 执行结果如下： 但是它也存在问题，如果此时给的参数值是 1234Map map = new HashMap();// map.put(&quot;status&quot; , status);map.put(&quot;companyName&quot;, companyName);map.put(&quot;brandName&quot; , brandName); 拼接的SQL语句就变成了 1select * from tb_brand where and company_name like ? and brand_name like ? 因为第一个 if 不成立，而上面的语句中 where 关键后直接跟 and 关键字，这就是一条错误的SQL语句。这个就可以使用 where 标签解决 where 标签 作用： 替换where关键字 会动态的去掉第一个条件前的 and 如果所有的参数没有值则不加where关键字 123456789101112131415&lt;select id=&quot;selectByCondition&quot; resultMap=&quot;brandResultMap&quot;&gt; select * from tb_brand &lt;where&gt; &lt;if test=&quot;status != null&quot;&gt; and status = #&#123;status&#125; &lt;/if&gt; &lt;if test=&quot;companyName != null and companyName != &#x27;&#x27; &quot;&gt; and company_name like #&#123;companyName&#125; &lt;/if&gt; &lt;if test=&quot;brandName != null and brandName != &#x27;&#x27; &quot;&gt; and brand_name like #&#123;brandName&#125; &lt;/if&gt; &lt;/where&gt;&lt;/select&gt; 注意：需要给每个条件前都加上 and 关键字。 1.5 单个条件（动态SQL） 如上图所示，在查询时只能选择 品牌名称、当前状态、企业名称 这三个条件中的一个，但是用户到底选择哪儿一个，我们并不能确定。这种就属于单个条件的动态SQL语句。 这种需求需要使用到 choose（when，otherwise）标签 实现， 而 choose 标签类似于Java 中的switch语句。 通过一个案例来使用这些标签 1.5.1 编写接口方法 在 BrandMapper 接口中定义单条件查询的方法。 123456/** * 单条件动态查询 * @param brand * @return */List&lt;Brand&gt; selectByConditionSingle(Brand brand); 1.5.2 编写SQL语句 在 BrandMapper.xml 映射配置文件中编写 statement，使用 resultMap 而不是使用 resultType 1234567891011121314151617&lt;select id=&quot;selectByConditionSingle&quot; resultMap=&quot;brandResultMap&quot;&gt; select * from tb_brand &lt;where&gt; &lt;choose&gt;&lt;!--相当于switch--&gt; &lt;when test=&quot;status != null&quot;&gt;&lt;!--相当于case--&gt; status = #&#123;status&#125; &lt;/when&gt; &lt;when test=&quot;companyName != null and companyName != &#x27;&#x27; &quot;&gt;&lt;!--相当于case--&gt; company_name like #&#123;companyName&#125; &lt;/when&gt; &lt;when test=&quot;brandName != null and brandName != &#x27;&#x27;&quot;&gt;&lt;!--相当于case--&gt; brand_name like #&#123;brandName&#125; &lt;/when&gt; &lt;/choose&gt; &lt;/where&gt;&lt;/select&gt; 1.5.3 编写测试方法 在 test/java 下的 com.itheima.mapper 包下的 MybatisTest类中 定义测试方法 1234567891011121314151617181920212223242526272829303132@Testpublic void testSelectByConditionSingle() throws IOException &#123; //接收参数 int status = 1; String companyName = &quot;华为&quot;; String brandName = &quot;华为&quot;; // 处理参数 companyName = &quot;%&quot; + companyName + &quot;%&quot;; brandName = &quot;%&quot; + brandName + &quot;%&quot;; //封装对象 Brand brand = new Brand(); //brand.setStatus(status); brand.setCompanyName(companyName); //brand.setBrandName(brandName); //1. 获取SqlSessionFactory String resource = &quot;mybatis-config.xml&quot;; InputStream inputStream = Resources.getResourceAsStream(resource); SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); //2. 获取SqlSession对象 SqlSession sqlSession = sqlSessionFactory.openSession(); //3. 获取Mapper接口的代理对象 BrandMapper brandMapper = sqlSession.getMapper(BrandMapper.class); //4. 执行方法 List&lt;Brand&gt; brands = brandMapper.selectByConditionSingle(brand); System.out.println(brands); //5. 释放资源 sqlSession.close();&#125; 执行测试方法结果如下： 1.6 添加数据 如上图是我们平时在添加数据时展示的页面，而我们在该页面输入想要的数据后添加 提交 按钮，就会将这些数据添加到数据库中。接下来我们就来实现添加数据的操作。 编写接口方法 参数：除了id之外的所有的数据。id对应的是表中主键值，而主键我们是 自动增长 生成的。 编写SQL语句 编写测试方法并执行 明确了该功能实现的步骤后，接下来我们进行具体的操作。 1.6.1 编写接口方法 在 BrandMapper 接口中定义添加方法。 1234 /** * 添加 */void add(Brand brand); 1.6.2 编写SQL语句 在 BrandMapper.xml 映射配置文件中编写添加数据的 statement 1234&lt;insert id=&quot;add&quot;&gt; insert into tb_brand (brand_name, company_name, ordered, description, status) values (#&#123;brandName&#125;, #&#123;companyName&#125;, #&#123;ordered&#125;, #&#123;description&#125;, #&#123;status&#125;);&lt;/insert&gt; 1.6.3 编写测试方法 在 test/java 下的 com.itheima.mapper 包下的 MybatisTest类中 定义测试方法 123456789101112131415161718192021222324252627282930313233@Testpublic void testAdd() throws IOException &#123; //接收参数 int status = 1; String companyName = &quot;波导手机&quot;; String brandName = &quot;波导&quot;; String description = &quot;手机中的战斗机&quot;; int ordered = 100; //封装对象 Brand brand = new Brand(); brand.setStatus(status); brand.setCompanyName(companyName); brand.setBrandName(brandName); brand.setDescription(description); brand.setOrdered(ordered); //1. 获取SqlSessionFactory String resource = &quot;mybatis-config.xml&quot;; InputStream inputStream = Resources.getResourceAsStream(resource); SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); //2. 获取SqlSession对象 SqlSession sqlSession = sqlSessionFactory.openSession(); //SqlSession sqlSession = sqlSessionFactory.openSession(true); //设置自动提交事务，这种情况不需要手动提交事务了 //3. 获取Mapper接口的代理对象 BrandMapper brandMapper = sqlSession.getMapper(BrandMapper.class); //4. 执行方法 brandMapper.add(brand); //手动提交事务 sqlSession.commit(); //5. 释放资源 sqlSession.close();&#125; 执行结果如下： 1.6.4 添加-主键返回 在数据添加成功后，有时候需要获取插入数据库数据的主键（主键是自增长）。 比如：添加订单和订单项，如下图就是京东上的订单 订单数据存储在订单表中，订单项存储在订单项表中。 添加订单数据 添加订单项数据，订单项中需要设置所属订单的id 明白了什么时候 主键返回 。接下来我们简单模拟一下，在添加完数据后打印id属性值，能打印出来说明已经获取到了。 我们将上面添加品牌数据的案例中映射配置文件里 statement 进行修改，如下 1234&lt;insert id=&quot;add&quot; useGeneratedKeys=&quot;true&quot; keyProperty=&quot;id&quot;&gt; insert into tb_brand (brand_name, company_name, ordered, description, status) values (#&#123;brandName&#125;, #&#123;companyName&#125;, #&#123;ordered&#125;, #&#123;description&#125;, #&#123;status&#125;);&lt;/insert&gt; 在 insert 标签上添加如下属性： useGeneratedKeys：是够获取自动增长的主键值。true表示获取 keyProperty ：指定将获取到的主键值封装到哪儿个属性里 1.7 修改 动态SQL 如图所示是修改页面，用户在该页面书写需要修改的数据，点击 提交 按钮，就会将数据库中对应的数据进行修改。注意一点，如果哪儿个输入框没有输入内容，我们是将表中数据对应字段值替换为空白还是保留字段之前的值？答案肯定是保留之前的数据，那么 update 操作就不用加入其他的字段。 接下来我们就具体来实现 1.7.1 编写接口方法 在 BrandMapper 接口中定义修改方法。 1234 /** * 修改 */void update(Brand brand); 上述方法参数 Brand 就是封装了需要修改的数据，而id肯定是有数据的，这也是和添加方法的区别。 1.7.2 编写SQL语句 在 BrandMapper.xml 映射配置文件中编写修改数据的 statement。 123456789101112131415161718192021&lt;update id=&quot;update&quot;&gt; update tb_brand &lt;set&gt; &lt;if test=&quot;brandName != null and brandName != &#x27;&#x27;&quot;&gt; brand_name = #&#123;brandName&#125;, &lt;/if&gt; &lt;if test=&quot;companyName != null and companyName != &#x27;&#x27;&quot;&gt; company_name = #&#123;companyName&#125;, &lt;/if&gt; &lt;if test=&quot;ordered != null&quot;&gt; ordered = #&#123;ordered&#125;, &lt;/if&gt; &lt;if test=&quot;description != null and description != &#x27;&#x27;&quot;&gt; description = #&#123;description&#125;, &lt;/if&gt; &lt;if test=&quot;status != null&quot;&gt; status = #&#123;status&#125; &lt;/if&gt; &lt;/set&gt; where id = #&#123;id&#125;;&lt;/update&gt; set 标签可以用于动态包含需要更新的列，忽略其它不更新的列。 如果不使用 会出现两个问题： 没有要更新的属性 SQL：update tb_brand set where id = ？ 最后一个属性不更新 SQL：update tb_brand set description = ？, where id = ？ “,”引起SQL 语法错误 1.7.3 编写测试方法 在 test/java 下的 com.itheima.mapper 包下的 MybatisTest类中 定义测试方法 123456789101112131415161718192021222324252627282930313233343536@Testpublic void testUpdate() throws IOException &#123; //接收参数 int status = 0; String companyName = &quot;波导手机&quot;; String brandName = &quot;波导&quot;; String description = &quot;波导手机,手机中的战斗机&quot;; int ordered = 200; int id = 6; //封装对象 Brand brand = new Brand(); brand.setStatus(status); // brand.setCompanyName(companyName); // brand.setBrandName(brandName); // brand.setDescription(description); // brand.setOrdered(ordered); brand.setId(id); //1. 获取SqlSessionFactory String resource = &quot;mybatis-config.xml&quot;; InputStream inputStream = Resources.getResourceAsStream(resource); SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); //2. 获取SqlSession对象 SqlSession sqlSession = sqlSessionFactory.openSession(); //SqlSession sqlSession = sqlSessionFactory.openSession(true); //3. 获取Mapper接口的代理对象 BrandMapper brandMapper = sqlSession.getMapper(BrandMapper.class); //4. 执行方法 int count = brandMapper.update(brand); System.out.println(count); //提交事务 sqlSession.commit(); //5. 释放资源 sqlSession.close();&#125; 执行测试方法结果如下： 从结果中SQL语句可以看出，只修改了 status 字段值，因为我们给的数据中只给Brand实体对象的 status 属性设置值了。这就是 set 标签的作用。 1.8 删除一行数据 如上图所示，每行数据后面都有一个 删除 按钮，当用户点击了该按钮，就会将改行数据删除掉。那我们就需要思考，这种删除是根据什么进行删除呢？是通过主键id删除，因为id是表中数据的唯一标识。 接下来就来实现该功能。 1.8.1 编写接口方法 在 BrandMapper 接口中定义根据id删除方法。 1234/** * 根据id删除 */void deleteById(int id); 1.8.2 编写SQL语句 在 BrandMapper.xml 映射配置文件中编写删除一行数据的 statement 123&lt;delete id=&quot;deleteById&quot;&gt; delete from tb_brand where id = #&#123;id&#125;;&lt;/delete&gt; 1.8.3 编写测试方法 在 test/java 下的 com.itheima.mapper 包下的 MybatisTest类中 定义测试方法 123456789101112131415161718192021 @Testpublic void testDeleteById() throws IOException &#123; //接收参数 int id = 6; //1. 获取SqlSessionFactory String resource = &quot;mybatis-config.xml&quot;; InputStream inputStream = Resources.getResourceAsStream(resource); SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); //2. 获取SqlSession对象 SqlSession sqlSession = sqlSessionFactory.openSession(); //SqlSession sqlSession = sqlSessionFactory.openSession(true); //3. 获取Mapper接口的代理对象 BrandMapper brandMapper = sqlSession.getMapper(BrandMapper.class); //4. 执行方法 brandMapper.deleteById(id); //提交事务 sqlSession.commit(); //5. 释放资源 sqlSession.close();&#125; 运行过程只要没报错，直接到数据库查询数据是否还存在。 1.9 批量删除 如上图所示，用户可以选择多条数据，然后点击上面的 删除 按钮，就会删除数据库中对应的多行数据。 1.9.1 编写接口方法 在 BrandMapper 接口中定义删除多行数据的方法。 1234/** * 批量删除 */void deleteByIds(int[] ids); 参数是一个数组，数组中存储的是多条数据的id 1.9.2 编写SQL语句 在 BrandMapper.xml 映射配置文件中编写删除多条数据的 statement。 编写SQL时需要遍历数组来拼接SQL语句。Mybatis 提供了 foreach 标签供我们使用 foreach 标签 用来迭代任何可迭代的对象（如数组，集合）。 collection 属性： mybatis会将数组参数，封装为一个Map集合。 默认：(key)array = (value)数组值 使用@Param注解改变map集合的默认key的名称（array） void deleteByIds(@Para(“ids”) int[] ids); 这样把 array 改成了 ids item 属性：本次迭代获取到的元素。 separator 属性：集合项迭代之间的分隔符。foreach 标签不会错误地添加多余的分隔符。也就是最后一次迭代不会加分隔符。 open 属性：该属性值是在拼接SQL语句之前拼接的语句，只会拼接一次 close 属性：该属性值是在拼接SQL语句拼接后拼接的语句，只会拼接一次 12345678&lt;delete id=&quot;deleteByIds&quot;&gt; delete from tb_brand where id in &lt;foreach collection=&quot;array&quot; item=&quot;id&quot; separator=&quot;,&quot; open=&quot;(&quot; close=&quot;)&quot;&gt; #&#123;id&#125; &lt;/foreach&gt; ;&lt;/delete&gt; 假如数组中的id数据是{1,2,3}，那么拼接后的sql语句就是： 1delete from tb_brand where id in (1,2,3); 1.9.3 编写测试方法 在 test/java 下的 com.itheima.mapper 包下的 MybatisTest类中 定义测试方法 123456789101112131415161718192021@Testpublic void testDeleteByIds() throws IOException &#123; //接收参数 int[] ids = &#123;5,7,8&#125;; //1. 获取SqlSessionFactory String resource = &quot;mybatis-config.xml&quot;; InputStream inputStream = Resources.getResourceAsStream(resource); SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); //2. 获取SqlSession对象 SqlSession sqlSession = sqlSessionFactory.openSession(); //SqlSession sqlSession = sqlSessionFactory.openSession(true); //3. 获取Mapper接口的代理对象 BrandMapper brandMapper = sqlSession.getMapper(BrandMapper.class); //4. 执行方法 brandMapper.deleteByIds(ids); //提交事务 sqlSession.commit(); //5. 释放资源 sqlSession.close();&#125; 1.10 Mybatis参数传递 Mybatis 接口方法中可以接收各种各样的参数，如下： 多个参数 单个参数：单个参数又可以是如下类型 POJO 类型 Map 集合类型 Collection 集合类型 List 集合类型 Array 类型 其他类型 1.10.1 多个参数 如下面的代码，就是接收两个参数，而接收多个参数需要使用 @Param 注解，那么为什么要加该注解呢？这个问题要弄明白就必须来研究Mybatis 底层对于这些参数是如何处理的。 1User select(@Param(&quot;username&quot;) String username,@Param(&quot;password&quot;) String password); //@Param(&quot;username&quot;) 要和 SQL 占位符保持一致 #&#123;username&#125; 1234567&lt;select id=&quot;select&quot; resultType=&quot;user&quot;&gt; select * from tb_user where username=#&#123;username&#125; and password=#&#123;password&#125;&lt;/select&gt; 我们在接口方法中定义多个参数，Mybatis 会将这些参数封装成 Map 集合对象，值就是参数值，而键在没有使用 @Param 注解时有以下命名规则：（不推荐） 以 arg 开头 ：第一个参数就叫 arg0，第二个参数就叫 arg1，以此类推。如： map.put(“arg0”，参数值1); map.put(“arg1”，参数值2); 以 param 开头 ： 第一个参数就叫 param1，第二个参数就叫 param2，依次类推。如： map.put(“param1”，参数值1); map.put(“param2”，参数值2); 代码验证： 在 UserMapper 接口中定义如下方法 1User select(String username,String password); 在 UserMapper.xml 映射配置文件中定义SQL 1234567&lt;select id=&quot;select&quot; resultType=&quot;user&quot;&gt; select * from tb_user where username=#&#123;arg0&#125; and password=#&#123;arg1&#125;&lt;/select&gt; 或者 1234567&lt;select id=&quot;select&quot; resultType=&quot;user&quot;&gt; select * from tb_user where username=#&#123;param1&#125; and password=#&#123;param2&#125;&lt;/select&gt; 运行代码结果如下 在映射配合文件的SQL语句中使用用 arg 开头的和 param 书写，代码的可读性会变的特别差，此时可以使用 @Param 注解。 在接口方法参数上使用 @Param 注解，Mybatis 会将 arg 开头的键名替换为对应注解的属性值。 代码验证： 在 UserMapper 接口中定义如下方法，在 username 参数前加上 @Param 注解 1User select(@Param(&quot;username&quot;) String username, String password); Mybatis 在封装 Map 集合时，键名就会变成如下： map.put(“username”，参数值1); map.put(“arg1”，参数值2); map.put(“param1”，参数值1); map.put(“param2”，参数值2); 在 UserMapper.xml 映射配置文件中定义SQL 1234567&lt;select id=&quot;select&quot; resultType=&quot;user&quot;&gt; select * from tb_user where username=#&#123;username&#125; and password=#&#123;param2&#125;&lt;/select&gt; 运行程序结果没有报错。而如果将 #&#123;&#125; 中的 username 还是写成 arg0 1234567&lt;select id=&quot;select&quot; resultType=&quot;user&quot;&gt; select * from tb_user where username=#&#123;arg0&#125; and password=#&#123;param2&#125;&lt;/select&gt; 运行程序则可以看到错误 结论：以后接口参数是多个时，在每个参数上都使用 @Param 注解。这样代码的可读性更高。 1.10.2 单个参数 POJO 类型 直接使用。要求 属性名 和 参数占位符名称 一致 Map 集合类型 直接使用。要求 map集合的键名 和 参数占位符名称 一致 Collection 集合类型（看源码） Mybatis 会将集合封装到 map 集合中，如下： map.put(“arg0”，collection集合); map.put(“collection”，collection集合; 可以使用 @Param 注解替换map集合中默认的 arg 键名。 List 集合类型 Mybatis 会将集合封装到 map 集合中，如下： map.put(“arg0”，list集合); map.put(“collection”，list集合); map.put(“list”，list集合); 可以使用 @Param 注解替换map集合中默认的 arg 键名。 Array 类型 Mybatis 会将集合封装到 map 集合中，如下： map.put(“arg0”，数组); map.put(“array”，数组); 可以使用 @Param 注解替换map集合中默认的 arg 键名。 其他类型 比如int类型，参数占位符名称 叫什么都可以。尽量做到见名知意 2，注解实现CRUD 使用注解开发会比配置文件开发更加方便。如下就是使用注解进行开发 12@Select(value = &quot;select * from tb_user where id = #&#123;id&#125;&quot;)public User select(int id); 注意： 注解是用来替换映射配置文件方式配置的，所以使用了注解，就不需要再映射配置文件中书写对应的 statement Mybatis 针对 CURD 操作都提供了对应的注解，已经做到见名知意。如下： 查询 ：@Select 添加 ：@Insert 修改 ：@Update 删除 ：@Delete 接下来我们做一个案例来使用 Mybatis 的注解开发 代码实现： 将之前案例中 UserMapper.xml 中的 根据id查询数据 的 statement 注释掉 在 UserMapper 接口的 selectById 方法上添加注解 运行测试程序也能正常查询到数据 我们课程上只演示这一个查询的注解开发，其他的同学们下来可以自己实现，都是比较简单。 ==注意：==在官方文档中 入门 中有这样的一段话： 所以，注解完成简单功能，配置文件完成复杂功能。 而我们之前写的动态 SQL 就是复杂的功能，如果用注解使用的话，就需要使用到 Mybatis 提供的SQL构建器来完成，而对应的代码如下： 上述代码将java代码和SQL语句融到了一块，使得代码的可读性大幅度降低。 来源：it 黑马 JavaWeb 教程","categories":[{"name":"Java","slug":"Java","permalink":"http://littlewuuu.com/categories/Java/"}],"tags":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://littlewuuu.com/tags/JavaWeb/"}]},{"title":"新闻啥的","slug":"Francaise/新闻啥的","date":"2022-08-19T22:00:00.000Z","updated":"2022-08-27T12:17:24.175Z","comments":true,"path":"2022/08/20/Francaise/新闻啥的/","link":"","permalink":"http://littlewuuu.com/2022/08/20/Francaise/%E6%96%B0%E9%97%BB%E5%95%A5%E7%9A%84/","excerpt":"","text":"08-15 manœuvres militaires 军事演习 alors que 当，然而 délégation 代表团 Patlementaire 议员，议会 ouvertement dénoncée par Pékin communiqué 公报 commandement 统帅 patrouille 巡逻 combat 战斗 interarmées 陆、海、空三军的 l’espace aérien 领空 détroit 海峡 démarcation 分界线 amitié 友谊 effrayer 使恐惧 revendiquer 追还 survenir 突如其来 blocus 封锁 engagement 承诺 invasion 入侵 08-16 Elle sera chargée de mettre en place…… ces sept derniers jours On aura à tirer des leçons de ce qui s’est passé 单词 意思 Incendie 火灾 Fiscal,e 国库 sinistre 灾祸 sinistré 受灾的，灾民 cellule 单人间，细胞 suspension 吊起，暂停 pâtir de 吃……的苦 En lien avec 有关 amortisseur 缓冲器 subir 忍受，接受 ravager 摧毁 durablement touchés 持久影响 arriver à échéanceéchéance 满期 到期 report 延期 pouce 拇指 stade 阶段 feux 火 prévention 预防措施 anticipation 提前 payer par anticipation 提前付款 chiffrage 用数字估算 08-17 Si « la situation s’avère plus difficile que d’habitude » pour cette rentrée scolaire du fait d’une pénurie d’enseignants mais les besoins le sont tout autant valoriser 增值 le métier d’enseignant 教师职业 la grille salariale 工资单 ainsi que 以及 s’avérer 被证实 pénurie 匮乏 aveu 承认 ministre délégué 部长助理 contraint,e 受拘束的 les écoles primaires 小学 perplexité 困惑 de la manière 以……的方法 donne 分牌，局面 précédent 先前的 quinquennat 五年任职期 asséner 猛烈地给予（打击） porte-parole 发言人 discours 讲话演说 discours séducteur 吸引人的演讲 habitué,e 习惯于……的 prudent, e 谨慎的 carrière 职业生涯 le plat de résistance 主菜 déceptions 失望 08-18 parce qu’elle fait face à ce chapelet d’îles qui sont des pays avec lesquels elle entretient des relations relativement hostiles conquérir 征服 menace 威胁 autoritaire 专制的 démanteler 拆除 survive à 从……脱险 nier 否认 légitimité 合法性 la République de Chine 中华民国 la République populaire de Chine 中华人民共和国 ingérence 干涉 admettre 接受，承认 revendiquer 追还 souveraineté 主权 unification 统一 impérial 帝国的 annexer 附加，吞并 Défaire 拆除 n’a plus grand-chose à voir 没有什么联系 lors de 在……期间 méridionale 南方的 contrarier 阻碍 hégémonique 霸权主义的 ambitions hégémonique confiner à 接壤 confiner dans 囚禁在 d’une certaine manière 某种程度上 en quelque sorte 某种程度上 relativement 相对的 vital 极其重要的，维持生命必须的 affaiblir 使虚弱 entre autres 尤其是 verrou 门栓 tactique 战术 déni 否认 en mesure 能 en tant que 由于 garant,e 保证的，担保人 éventuelle 可能的 prolifération 迅速繁殖 compter sur 指望 traité 条款 portée 荷载 composante 成分 sous-marins lanceurs d’engins 潜艇发射器 engin 导弹 repérer 定位发现 pister 追查 méridionale 南面的 peu profonde 浅的 trois quarts 四分之三 balistiques 导弹 missile balistique 弹道导弹 sol-sol 地对地 sous-marin 潜水艇 par nature 天性 maritime 沿海的 porter sur 专注于 souveraine 有主权的 importation 进口 inhabité 无人居住的 raviver 使复苏 dispute 争吵 préoccuper 缠住 使担心 convoiter 觊觎 régime de Pékin gain 收益，获胜 indéniable 不可否认的 aisément 轻松的 interrompre 中断 déstabilisation 失稳 hégémonique 霸权的 faire contrepoids à …作为…的平衡力量, 与…抗衡 rivalité 竞争 08-25 approvisionnement 供应 corrosion 腐蚀 flambée 旺火 inédite 新颖的，从未见过的 tendre 拉紧 intermédiaire 中间人，中间的 fourchette 范围，餐叉 soupçonner 怀疑 soudure 连接，焊接 coude 肘关节 circuit 环形线路 sûreté 安全可靠 ultrason 超声波 délestage 切除负载 rattraper 追上 la période de confinement 禁闭期 sans précédent 空前的 08-26 Oh je vais regarder un film tiens 你的电影 festivalier 联欢节的参与者 se changer les idées 换换脑子 époustouflant 惊奇的 splendide 辉煌的 magistrale 杰出的 cours magistrale 由老师讲授的课 [与学生参与的实践课相对] usant 损害健康的 nostalgique 思乡的 cinéphile 电影爱好者 hôtesse 女主人 arrondissement 大区 périple 航行，游历 aérer 通风 classique 经典 tituber 蹒跚 allant aller 的现在分词 ivre 喝醉的 sous le signe de 在……的影响下","categories":[{"name":"le français","slug":"le-francais","permalink":"http://littlewuuu.com/categories/le-francais/"}],"tags":[{"name":"le français","slug":"le-francais","permalink":"http://littlewuuu.com/tags/le-francais/"}]},{"title":"SpringBootVueOneDay","slug":"SpringBootVueOneDayNotes/SpringBootVueOneDayNotes","date":"2022-07-02T22:00:00.000Z","updated":"2022-12-01T15:41:56.283Z","comments":true,"path":"2022/07/03/SpringBootVueOneDayNotes/SpringBootVueOneDayNotes/","link":"","permalink":"http://littlewuuu.com/2022/07/03/SpringBootVueOneDayNotes/SpringBootVueOneDayNotes/","excerpt":"","text":"Maven maven helper spring boot 实现热部署：debug 模式下使用 p4 文件上传 500 后端出问题 12spring.servlet.multipart.max-file-size=10MB//更改前端上传的文件的大小 12spring.web.resources.static-locations=/upload/// 前面的“/”表示 tomcat 目录 拦截器 拦截器注册 src/main/java/com/example/helloworld/config src/main/java/com/example/helloworld/interceptor postman 用来测试后端 API p5 : RESTful + Swagger swagger：要在项目中加入依赖 pom 文件 也可以在 swagger 里面测试 api，就不用 postman P6 : MyBatis ORM 对象关系映射 Objet Relational Mapping Mybatis-plus 是 数据持久层 ORM 的框架 数据库的文件都写在 mapper 包 pom.xml application.properties 添加 MapperScan 注解，放到启动类 1@MapperScan(&quot;com.example.mpdemo.mapper&quot;) MyBatis 例子 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970//*******************启动类@SpringBootApplication@MapperScan(&quot;com.example.mpdemo.mapper&quot;)public class MpdemoApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(MpdemoApplication.class, args); &#125;&#125;//******************* UserMapper 接口//用于操作用户表,MyBaits会根据Mapper注解，动态实现UserMapper接口（实现类），动态代理技术//Spring会自动创建UserMapper接口实现类对应的实例@Mapperpublic interface UserMapper extends BaseMapper&lt;User&gt; &#123;// 查询用户，根据用户id查询信息 select * from user where id = @Select(&quot;select * from user where id = #&#123;id&#125;&quot;) //#&#123;id&#125; 使用下面函数的传入参数 id User selectById(int id); @Select(&quot;select * from user&quot;) //会自动去找配置文件里面的数据库，并且自动传到 list 里面去 👇🏻 public List&lt;User&gt; find(); @Insert(&quot;insert into user values(#&#123;id&#125;,#&#123;username&#125;,#&#123;password&#125;,#&#123;birthday&#125;)&quot;) public int insert(User user);&#125;//******************* UserController 类@RestControllerpublic class UserContoller &#123; @Autowired //spring 功能 UserMapper userMapper; @GetMapping(&quot;/user/findAllUser&quot;) public List&lt;User&gt; findAllUser()&#123; return userMapper.find(); &#125; /* //改成 list 就会自动转成 json 文件传给前端 @GetMapping(&quot;/user/findAllUser&quot;) public List findAllUser()&#123; List&lt;User&gt; list = userMapper.find(); System.out.println(list) return list; &#125; */// 插入数据 @PostMapping(&quot;/user/insert&quot;) public String save(User user)&#123; int r = userMapper.insert(user); if(r &gt; 0)&#123; return &quot;插入成功&quot;; &#125;else&#123; return &quot;插入失败&quot;; &#125; &#125; @GetMapping(&quot;/user/selectById&quot;) public void select(int id)&#123; System.out.println(userMapper.selectById(id)); &#125;&#125; MyBits-Plus 123456789101112131415161718192021222324252627//*************INTERFACE@Mapper //主要是继承，这个类里面已经有一些方法public interface UserMapper extends BaseMapper&lt;User&gt; &#123;&#125;//*************CLASS@RestController@CrossOriginpublic class UserContoller &#123; @Autowired //spring 功能， UserMapper userMapper; // 插入数据 @PostMapping(&quot;/user/insert&quot;) public String save(User user)&#123; int r = userMapper.insert(user); if(r &gt; 0)&#123; return &quot;插入成功&quot;; &#125;else&#123; return &quot;插入失败&quot;; &#125; &#125;&#125; MyBatis plus 只对单表查询增强 VUE install npm 类似于 maven 的包管理工具，需要先安装 node Vue CLI 是官方提供的构建工具，脚手架 1npm install -g @vue/cli ​ -g 表示全局安装 在终端打开指定文件夹目录 或者 把文件夹拖到 vscode 里，开 vscode 的终端 12345678npm install -g @vue/clivue create 项目名字//之后会有询问//选择1. manually select features2. 取消 linter/fromatter 空格选择package.json 记录依赖相关信息 Component App.vue 是根组件 .vue 文件是组件的后缀名 每个.vue 包括 template：模板结构，可以包含 html script ：JavaScript 代码 style：组件的样式 自己写的组件一般放那个在 component 文件夹里面 使用组件步骤： 导入组件 在 script 里面写 注册组件 使用组件 自定义组件使用 propos 得到外部传的值，组件之间还不能传值，要通过 vuex 第三方组件 Element-ui 通过 npm 安装，下载到 node_modules目录，第三方的东西都在这里，同时在 package.json 里面记录 下载到当前项目文件夹 1npm install element-plus --save 导入，看官网 quick start 12345678910// main.tsimport &#123; createApp &#125; from &#x27;vue&#x27;import ElementPlus from &#x27;element-plus&#x27; //新添加import &#x27;element-plus/dist/index.css&#x27; //新添加import App from &#x27;./App.vue&#x27;const app = createApp(App)app.use(ElementPlus) //全局注册，新添加app.mount(&#x27;#app&#x27;) node_modules 可以没有，因为依赖记录在 package.json 文件里面了，可以通过 npm install 下载依赖，npm install 会自动查找 package.json 文件然后下载 第三方图标库 font awesome Axios 在实际项目开发中，前端页面所需要 的数据往往从服务器端获取，这必然涉及和服务器的通信。 Axios 是极具 promise 网络请求库，作用于 node.js 和 浏览器 Axios 在浏览器端使用XMLHttpRequests 发送网络请求，并能自动完成 json 数据转换 安装：https://www.axios-http.cn/ 1npm install axios VueRouter 实现同一个网址切换不同的组件 1npm install vue-router@4 表示4.x版本","categories":[{"name":"Case","slug":"Case","permalink":"http://littlewuuu.com/categories/Case/"}],"tags":[{"name":"SpringBootVueOneDay","slug":"SpringBootVueOneDay","permalink":"http://littlewuuu.com/tags/SpringBootVueOneDay/"}]},{"title":"HTML & CSS & JavaScript","slug":"HTML+CSS/HTML+CSS","date":"2022-02-26T23:00:00.000Z","updated":"2022-12-01T15:42:26.415Z","comments":true,"path":"2022/02/27/HTML+CSS/HTML+CSS/","link":"","permalink":"http://littlewuuu.com/2022/02/27/HTML+CSS/HTML+CSS/","excerpt":"","text":"Tomcat Tomcat 安装使用 12./startup.sh./shutdown.sh 浏览器地址栏输入：localhost:8080，验证是否成功启动 tomcat 版本：apache-tomcat-8.5.83 目录结构说明： bin 可执行文件目录 conf 配置文件目录 lib 存放lib的目录 logs 日志文件目录 webapps 项目部署的目录 work 工作目录 temp 临时目录 例子：http://localhost:8080/baidu/demo09.html IDEA 配置 Tomcat","categories":[{"name":"SKILLS","slug":"SKILLS","permalink":"http://littlewuuu.com/categories/SKILLS/"}],"tags":[{"name":"学了又忘的杂七杂八","slug":"学了又忘的杂七杂八","permalink":"http://littlewuuu.com/tags/%E5%AD%A6%E4%BA%86%E5%8F%88%E5%BF%98%E7%9A%84%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/"}]},{"title":"算法框架","slug":"算法框架/算法基本格式","date":"2022-02-10T23:00:00.000Z","updated":"2022-11-26T08:04:07.607Z","comments":true,"path":"2022/02/11/算法框架/算法基本格式/","link":"","permalink":"http://littlewuuu.com/2022/02/11/%E7%AE%97%E6%B3%95%E6%A1%86%E6%9E%B6/%E7%AE%97%E6%B3%95%E5%9F%BA%E6%9C%AC%E6%A0%BC%E5%BC%8F/","excerpt":"","text":"算法基本格式 数组 基本方法 二分法 双指针 滑动窗口，和双指针类似，通过窗口大小的变换来解题 哈希表 关于哈希表的一些事情 常见的哈希表结构 数组 set（unordered_set） map（unordered_map） 适用题型 当我们遇到了要快速判断一个元素是否出现集合里的时候，就要考虑哈希法。 但是哈希法也是牺牲了空间换取了时间，因为我们要使用额外的数组，set或者是map来存放数据，才能实现快速的查找。 字符串 KMP 算法 在一个串里查找是否出现过另外一个串 1. next 数组 next 数组就是一个前缀表 前缀表是用来回退的，它记录了模式串与主串(文本串)不匹配的时候，模式串应该从哪里开始重新匹配。 next数组就可以是前缀表，但是很多实现都是把前缀表统一减一（右移一位，初始位置为-1）之后作为next数组。 求前缀表： 队列与栈 栈 栈是以底层容器完成其所有的工作，对外提供统一的接口，底层容器是可插拔的（也就是说我们可以控制使用哪种容器来实现栈的功能）。 所以STL中栈和队列往往不被归类为容器，而被归类为container adapter（容器适配器）。 队列中先进先出的数据结构，栈先进后出的数据结构，不允许有遍历行为，不提供迭代器 从下图中可以看出，栈的内部结构，栈的底层实现可以是vector，deque，list 都是可以的， 主要就是数组和链表的底层实现。 12默认使用deque 实现栈的底层结构std::stack&lt;int, std::vector&lt;int&gt; &gt; third; // 指定使用vector为底层容器的栈 队列实现栈 输出栈顶元素的时候只需要不断把队列的头取出来重新添加到队列中（除了最后一个元素），然后从队列中取出来的就是栈的顺序（注意队列取出只能按照先进先出） 栈实现队列 两个栈，一个输入栈，一个输出栈，输出的时候如果输出栈有元素则输出，没有则把输入栈里所有元素弹出添加到输出栈里面 括号匹配问题 使用栈解决的经典问题，栈适合做对称匹配类的问题 有三种情况： 括号匹配完成了但是栈里还剩有元素，说明括号对应个数不一样。 栈已经空了，但是表达式还没有匹配完。 栈里和表达式的匹配不上。 stack.empty() returns 1 if stack is empty, return 0 if is not empty. 1234567891011121314151617class Solution &#123;public: bool isValid(string s) &#123; stack&lt;int&gt; st; for (int i = 0; i &lt; s.size(); i++) &#123; if (s[i] == &#x27;(&#x27;) st.push(&#x27;)&#x27;); else if (s[i] == &#x27;&#123;&#x27;) st.push(&#x27;&#125;&#x27;); else if (s[i] == &#x27;[&#x27;) st.push(&#x27;]&#x27;); // 第三种情况：遍历字符串匹配的过程中，栈已经为空了，没有匹配的字符了，说明右括号没有找到对应的左括号 return false // 第二种情况：遍历字符串匹配的过程中，发现栈里没有我们要匹配的字符。所以return false。即字符串还没有匹配完栈已经空了 else if (st.empty() || st.top() != s[i]) return false; else st.pop(); // st.top() 与 s[i]相等，栈弹出元素 &#125; // 第一种情况：此时我们已经遍历完了字符串，但是栈不为空，说明有相应的左括号没有右括号来匹配，所以return false，否则就return true return st.empty(); &#125;&#125;; 逆波兰式求值 逆波兰式是一个后缀表达式 123456789101112131415161718192021222324class Solution &#123;public: int evalRPN(vector&lt;string&gt;&amp; tokens) &#123; stack&lt;int&gt; st; for (int i = 0; i &lt; tokens.size(); i++) &#123; //如果碰到运算符，就取出栈中的两个元素进行运算然后再把结果压入栈里 if (tokens[i] == &quot;+&quot; || tokens[i] == &quot;-&quot; || tokens[i] == &quot;*&quot; || tokens[i] == &quot;/&quot;) &#123; int num1 = st.top(); st.pop(); int num2 = st.top(); st.pop(); if (tokens[i] == &quot;+&quot;) st.push(num2 + num1); if (tokens[i] == &quot;-&quot;) st.push(num2 - num1); if (tokens[i] == &quot;*&quot;) st.push(num2 * num1); if (tokens[i] == &quot;/&quot;) st.push(num2 / num1); &#125; else &#123;//碰到元素直接入栈 st.push(stoi(tokens[i])); &#125; &#125; int result = st.top(); st.pop(); // 把栈里最后一个元素弹出（其实不弹出也没事） return result; &#125;&#125;; 单调队列 给定一个数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。 返回滑动窗口中的最大值。 1234567891011121314151617181920212223242526272829303132333435363738394041class Solution &#123;private: class MyQueue &#123; //单调队列（从大到小） public: deque&lt;int&gt; que; // 使用deque来实现单调队列 // 每次弹出的时候，比较当前要弹出的数值是否等于队列出口元素的数值，如果相等则弹出。 // 同时pop之前判断队列当前是否为空。 void pop(int value) &#123; if (!que.empty() &amp;&amp; value == que.front()) &#123; que.pop_front(); &#125; &#125; // 如果push的数值大于入口元素的数值，那么就将队列后端的数值弹出，直到push的数值小于等于队列入口元素的数值为止。 // 这样就保持了队列里的数值是单调从大到小的了。 void push(int value) &#123; while (!que.empty() &amp;&amp; value &gt; que.back()) &#123; que.pop_back(); &#125; que.push_back(value); &#125; // 查询当前队列里的最大值 直接返回队列前端也就是front就可以了。 int front() &#123; return que.front(); &#125; &#125;;public: vector&lt;int&gt; maxSlidingWindow(vector&lt;int&gt;&amp; nums, int k) &#123; MyQueue que; vector&lt;int&gt; result; for (int i = 0; i &lt; k; i++) &#123; // 先将前k的元素放进队列 que.push(nums[i]);//push()时就确保队列是单调的了 &#125; result.push_back(que.front()); // result 记录前k的元素的最大值 for (int i = k; i &lt; nums.size(); i++) &#123; que.pop(nums[i - k]); // 滑动窗口移除最前面元素 que.push(nums[i]); // 滑动窗口前加入最后面的元素 result.push_back(que.front()); // 记录对应的最大值 &#125; return result; &#125;&#125;; 前 k 个高频元素 给定一个非空的整数数组，返回其中出现频率前 k 高的元素。 三步： 统计出现频率（用 map），一般统计频率的都用 map &lt;key, value&gt; key存储元素，value 存储元素的出现次数 排序，使用 priority_queue 取出前 k 个，就要在使用优先队列排序的时候控制队列的大小为 k，如果大于 k，就弹出元素，最后把队列中的所有元素输出即可。 我的想法 哈希表（和 map 一个道理） 123456vector&lt;int&gt; nums;//给的数组results[];//结果for(int i = 0; i &lt; nums.size(); i++)&#123; nums[i]++; //nums[i]就是 i 出现的次数&#125; 使用 map，priority_queue， 堆（heap） 堆是完全二叉树，大根堆就是根节点的数值大于左右结点 优先队列，堆排序，快速找到一个集合中的最值 堆顶元素总是最值，但是另一个最值不确定在哪里 数组存储堆 一般都用数组来表示存储堆，i结点的父结点下标就为(i–1)/2。它的左右子结点下标分别为2 * i + 1和2 * i + 2。如第0个结点左右子结点下标分别为1和2。一个结点（i）的根节点就是 i/2（整除） 堆的操作 插入：新元素被加入到heap的末尾，然后更新树以恢复堆的次序。 删除：按定义，堆中每次都删除第0个数据。为了便于重建堆，实际的操作是将最后一个数据的值赋给根结点，然后再从根结点开始进行一次从上向下的调整。 堆排序 堆建好之后堆中第0个数据是堆中最大的数据。取出这个数据再执行下堆的删除操作。这样堆中第0个数据又是堆中最大的数据，重复上述步骤直至堆中只有一个数据时就直接取出这个数据。 ​ 树🌲 框架 树的基本概念 定义 是一种递归的数据结构 一个结点的孩子数为该节点的度，结点的最大度数为树的度 度为 0 的结点为叶子结点 高度和深度 高度是针对整棵树来说的，是深度的最大值（根节点深度为 1） 深度就是从根结点向下走，高度从下往上走 有序树和无序树 有序树的结点的左右子树有顺序不能换 路径和长度 树中两个结点之间的路径是这两个结点之间经过的结点序列构成的，路径长度是路径上边的个数 路径是从父节点到子节点，有方向的。所以同一结点的两个孩子之间没有路径 性质 二叉树 二叉树基本概念 是有序树，左右结点不能互换 二叉树与度为 2 的有序树的区别 二叉树可以是空树，有序树至少有三个结点 如果一个二叉树结点只有左子树，那么还是要区分左右，右子树为空树 特殊二叉树 满二叉树 完全二叉树 二叉排序树 左子树上所有结点的关键字都小于根节点的关键字 右子树上所有结点的关键字都大于根节点的关键字 平衡二叉树 任意结点的左子树和右子树的深度之差 &lt; = 1 二叉树的性质 n0=n2+1 n_0 = n_2 +1 n0​=n2​+1 第 k 层至多结点数 2k−12^{k-1} 2k−1 高度为 h 的二叉树至多节点数 2h−1(h&gt;=1)2^h-1(h&gt;=1) 2h−1(h&gt;=1) 二叉树的存储结构 顺序存储 链式存储 二叉树遍历 递归写法： 确定递归函数的参数和返回值 确定终止条件 确定单层递归的逻辑 先序 12345678910void PreOrder(BiTree T, vector&lt;T&gt;&amp; result)&#123; //result for recording the order if(T != NULL) &#123; visit(T); PreOrder(T-&gt;LeftChild); PreOrder(T-&gt;RightChild); &#125;&#125;//时间复杂度O(n)//空间复杂度O(n) 中序 12345678void PreOrder(BiTree T)&#123; if(T != NULL) &#123; PreOrder(T-&gt;LeftChild); visit(T); PreOrder(T-&gt;RightChild); &#125;&#125; 后序 12345678void PreOrder(BiTree T)&#123; if(T != NULL) &#123; PreOrder(T-&gt;LeftChild); PreOrder(T-&gt;RightChild); visit(T); &#125;&#125; 递归算法和非递归算法的转换（栈） 12345678910111213141516171819//中序遍历的非递归实现void InOrder(BiTree)&#123; InitStack(s); //初始化栈 BiTree p = T; //p 是遍历指针 while(p||!isEmpty(s)) &#123; if(p)//遍历左子树 &#123; Push(s,p); p=p-&gt;LeftChild; &#125; else //出栈，并转向出栈结点的右子树 &#123; Pop(s,p);visit(p);//栈顶元素出栈，访问出栈元素 p=p-&gt;RightChild; &#125; &#125;&#125; 层次遍历（队列） 123456789101112131415void LevelOrder(BiTree T)&#123; InitQueue(Q); BiTree p; EnQueue(Q,T); while(!IsEmpty(Q)) &#123; DeQueue(Q,p); visit(p); if(p-&gt;leftchild != NULL) EnQueue(Q,p-&gt;leftchild); if(p-&gt;leftchild != NULL) EnQueue(Q,p-&gt;rightchild) &#125;&#125; 翻转二叉树 可以用递归方式，先序后序都可以用 12345678void inverse(BiTree T)&#123; if(T == NULL) return; swap(T-&gt;left,T-&gt;right); inverse(T-&gt;left); inverse(T-&gt;right);&#125; 判断二叉树是否左右镜像 递归三部曲 确定递归参数和返回值 1bool compare(TreeNode* left, TreeNode* right) 确定终止条件 1234if (left == NULL &amp;&amp; right != NULL) return false;else if (left != NULL &amp;&amp; right == NULL) return false;else if (left == NULL &amp;&amp; right == NULL) return true;else if (left-&gt;val != right-&gt;val) return false; // 注意这里我没有使用else 确定单层递归逻辑 1234bool outside = compare(left-&gt;left, right-&gt;right); // 左子树：左、 右子树：右bool inside = compare(left-&gt;right, right-&gt;left); // 左子树：右、 右子树：左bool isSame = outside &amp;&amp; inside; // 左子树：中、 右子树：中（逻辑处理）return isSame; 二叉树最大深度 递归法 确定参数和返回值 1int getdepth(treenode *node) 确定终止条件 1if(node == NULL) return 0; 确定单层递归逻辑 12345678class solution &#123;public: int maxdepth(treenode* root) &#123; if (root == null) return 0; return 1 + max(maxdepth(root-&gt;left), maxdepth(root-&gt;right)); &#125;&#125;; 层序遍历 1234567891011121314151617181920class solution &#123;public: int maxdepth(treenode* root) &#123; if (root == NULL) return 0; int depth = 0; queue&lt;treenode*&gt; que; que.push(root); while(!que.empty()) &#123; int size = que.size(); depth++; // 记录深度 for (int i = 0; i &lt; size; i++) &#123; treenode* node = que.front(); que.pop(); if (node-&gt;left) que.push(node-&gt;left); if (node-&gt;right) que.push(node-&gt;right); &#125; &#125; return depth; &#125;&#125;; 线索二叉树 遍历二叉树就是逸一定的规则将二叉树中的结点排成一个线性序列，该序列中每个节点（除了开始和结束）都有一个直接前驱和直接后继 引入线索二叉树是为了加快查找结点的前驱和后继的速度 结构 12345typedef struct ThreadNode&#123; ElemType data; struct ThreadNode *lchild, *rchild; int ltag,rtag;//判断左右子树指针指向左右子树还是前后驱结点&#125;TreadNode; 中序线索二叉树的构造 将二叉链表的空指针改为指向前驱后驱的线索，而前后驱结点的消息只有在遍历的时候能得到，所以线索化的实质是遍历一次二叉树 123456789101112131415161718192021222324252627282930void CreateInTread(TreadNode T)&#123; TreadTree pre = NULL; if(T!=NULL)//非空二叉树，线索化 &#123; Intread(T,pre);//线索化 pre-&gt;rchild = NULL;//处理遍历最后一个结点 pre-&gt;rtag = 1; &#125;&#125;void Intread(TreadTree &amp;p,ThreadTree &amp;pre)&#123; if(p!=NULL) &#123; Intread(p-&gt;lchild,pre);//线索化左子树 if(p-&gt;lchild == NULL)//左子树为空，建立前驱线索 &#123; p-&gt;lchild = pre; ltag = 1; &#125; if(pre!=NULL &amp;&amp; pre-&gt;rchild == NULL)//建立前驱结点的后继线索 &#123; pre-&gt;rchild = p; pre-&gt;rtag = 1; &#125; pre = p; Intread(p-&gt;rchild,pre);//线索化右子树 &#125;//end of if(p!=NULL)&#125; 回溯法 基本题型： 关于回溯的一些事情 因为回溯的本质是穷举，穷举所有可能，然后选出我们想要的答案，如果想让回溯法高效一些，可以加一些剪枝的操作，但也改不了回溯法就是穷举的本质。 所有回溯法的问题都可以抽象为树形结构！因为回溯法解决的都是在集合中递归查找子集，集合的大小就构成了树的宽度，递归的深度，都构成的树的深度。 递归就要有终止条件，所以必然是一棵高度有限的树（N叉树）。 回溯框架 1234567891011void backtracking(参数) &#123; if (终止条件) &#123; 存放结果; return; &#125; for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) &#123; 处理节点; backtracking(路径，选择列表); // 递归 回溯，撤销处理结果 &#125;&#125; N皇后问题 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051class Solution &#123;private:vector&lt;vector&lt;string&gt;&gt; result;//存放结果棋盘们// n 为输入的棋盘大小// row 是当前递归到棋盘的第几行了// 回溯函数void backtracking(int n, int row, vector&lt;string&gt;&amp; chessboard) &#123; if (row == n) &#123; result.push_back(chessboard); return; &#125; for (int col = 0; col &lt; n; col++) &#123;//判断 row 这一行那个位置可以放 if (isValid(row, col, chessboard, n)) &#123; // 验证合法就可以放 chessboard[row][col] = &#x27;Q&#x27;; // 放置皇后 backtracking(n, row + 1, chessboard);//寻找下一行可以放的位置 chessboard[row][col] = &#x27;.&#x27;; // 回溯，撤销皇后 &#125; &#125;&#125;//判断(row,col)这个位置可不可以放bool isValid(int row, int col, vector&lt;string&gt;&amp; chessboard, int n) &#123; int count = 0; // 检查列(i,col) for (int i = 0; i &lt; row; i++) &#123; // 这是一个剪枝 if (chessboard[i][col] == &#x27;Q&#x27;) &#123; return false; &#125; &#125; // 检查 45度角是否有皇后 for (int i = row - 1, j = col - 1; i &gt;=0 &amp;&amp; j &gt;= 0; i--, j--) &#123; if (chessboard[i][j] == &#x27;Q&#x27;) &#123; return false; &#125; &#125; // 检查 135度角是否有皇后 for(int i = row - 1, j = col + 1; i &gt;= 0 &amp;&amp; j &lt; n; i--, j++) &#123; if (chessboard[i][j] == &#x27;Q&#x27;) &#123; return false; &#125; &#125; return true;&#125;public: vector&lt;vector&lt;string&gt;&gt; solveNQueens(int n) &#123; result.clear(); std::vector&lt;std::string&gt; chessboard(n, std::string(n, &#x27;.&#x27;)); backtracking(n, 0, chessboard); return result; &#125;&#125;; 组合问题 组合问题 1 给定两个整数 n 和 k，返回 1 … n 中所有可能的 k 个数的组合。每个元素只能用一次 1234567891011121314151617181920212223class Solution &#123;private: vector&lt;vector&lt;int&gt;&gt; result;//存放结果 vector&lt;int&gt; path;//保存每次选取结果 void backtracking(int n, int k, int startIndex) &#123; if (path.size() == k) &#123; //已经选取 k 个数了，该次递归结束 result.push_back(path);//存入结果集 return; &#125; for (int i = startIndex; i &lt;= n - (k - path.size()) + 1; i++) &#123; // 优化的地方 //就是说剩下的元素已经小于 K 了，那么无论怎么组合都选取不到 k 个，可以提前结束 //n - (k - path.size()) + 1 就是最后满足条件的坐标 path.push_back(i); // 处理节点 backtracking(n, k, i + 1); path.pop_back(); // 回溯，撤销处理的节点 &#125; &#125;public: vector&lt;vector&lt;int&gt;&gt; combine(int n, int k) &#123; backtracking(n, k, 1); return result; &#125;&#125;; 组合总和 1 给你一个 无重复元素 的整数数组 candidates 和一个目标整数 target ，找出 candidates 中可以使数字和为目标数 target 的 所有 不同组合 ，并以列表形式返回。你可以按 任意顺序 返回这些组合。 candidates 中的 同一个 数字可以 无限制重复被选取 。如果至少一个数字的被选数量不同，则两种组合是不同的。 对于给定的输入，保证和为 target 的不同组合数少于 150 个。 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/combination-sum 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 123456789101112131415161718192021222324252627282930313233343536373839404142class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; combinationSum(vector&lt;int&gt;&amp; candidates, int target) &#123; backtracking(target,0,candidates,0); return result; &#125;private: vector&lt;vector&lt;int&gt;&gt; result; vector&lt;int&gt; path; void backtracking(int targetsum,int sum,const vector&lt;int&gt; candidates,int startindex)//如何解决重复的结果：可重复选取当前的元素 &#123; if(sum&gt;targetsum)//另外一种结束出口 &#123; return; &#125; if(sum == targetsum)//找到组合 &#123; result.push_back(path); return; &#125; for(int i = startindex;i&lt;candidates.size();i++) &#123; path.push_back(candidates[i]); sum+=candidates[i]; backtracking(targetsum,sum,candidates,i); sum-=candidates[i]; path.pop_back(); &#125; &#125;&#125;;/* for(int i = startindex;i&lt;candidates.size();i++) //注意这里使用了 startindex 而不是从 0 开始，因为如果从 0 开始当前元素前面的元素也会纳入计算，就会使得结果重复， &#123; path.push_back(candidates[i]); sum+=candidates[i]; backtracking(targetsum,sum,candidates,i);//i不用+1，当前元素也可以选取 sum-=candidates[i]; path.pop_back(); &#125;*/ 组合总和 2 给定一个数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。 candidates 中的每个数字在每个组合中只能使用一次。canadidates 的元素可以重复 说明： 所有数字（包括目标数）都是正整数。 解集不能包含重复的组合。 示例 1: 输入: candidates = [10,1,2,7,6,1,5], target = 8, 所求解集为: [ [1, 7], [1, 2, 5], [2, 6], [1, 1, 6] ] 示例 2: 输入: candidates = [2,5,2,1,2], target = 5, 所求解集为: [ [1,2,2], [5] ] 为实现去重，要先对数组排序，然后设置 used 数组记录同一层的相同元素是否被使用过 组合问题总结： 给你一个无重复的 candidate 数组，里面的数字不可以重复使用，使其和等于target，那么下一层的 startindex 就是当前层的 stratindex 的下一个 给你一个无重复的 candidate 数组，里面的数字可以重复使用，使其和等于target，那么下一层的startindex和当前的一样。 给你一个重复的 candidate 数组，那么同一树层不能用相同的元素，同一树枝可以用相同的元素 电话号码的字母组合 给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。答案可以按 任意顺序 返回。 给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 12345678910111213141516171819202122232425262728293031323334353637383940414243class Solution &#123;public: vector&lt;string&gt; letterCombinations(string digits) &#123; result.clear(); path.clear(); if(digits.size() == 0) return result; backtracking(digits,0); return result; &#125;private: vector&lt;string&gt; result;//存放结果集 string path;//存放每次的结果 const string lettermap[10]= &#123;//建立数字字母映射关系 &quot;&quot;,//0 &quot;&quot;,//1 &quot;abc&quot;,//2 &quot;def&quot;,//3 &quot;ghi&quot;,//4 &quot;jkl&quot;,//5 &quot;mno&quot;,//6 &quot;pqrs&quot;,//7 &quot;tuv&quot;,//8 &quot;wxyz&quot;,//9 &#125;; void backtracking(const string &amp;digits, int index) &#123; if(path.size() == digits.size()) &#123; result.push_back(path); return ; &#125; int digit = digits[index] - &#x27;0&#x27;;//获得 index 指向的 digit 字符串中的数字 string letters = lettermap[digit];//获取该数字对应的字符集 for(int i=0;i&lt;letters.size();i++)//对获取到的字符集进行遍历 &#123; path.push_back(letters[i]); backtracking(digits,index+1); path.pop_back(); &#125; &#125;&#125;; 分割问题 分割回文串 当下一层的开始元素和当前层不一样的时候，就需要使用 startindex 子集问题 如果把 子集问题、组合问题、分割问题都抽象为一棵树的话，那么组合问题和分割问题都是收集树的叶子节点，而子集问题是找树的所有节点！ 子集1 给定一组不含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。 说明：解集不能包含重复的子集。 123456789101112131415161718192021222324252627282930class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; subsets(vector&lt;int&gt;&amp; nums) &#123; result.clear(); path.clear(); back(0,nums); return result; &#125;private: vector&lt;int&gt; path; vector&lt;vector&lt;int&gt;&gt; result; void back(int startindex,vector&lt;int&gt;&amp; nums) &#123; result.push_back(path);//和组合排列问题的差别主要体现在这里 //每次向下递归的时候都要收集结果 if(startindex&gt;=nums.size()) &#123; return; &#125; for(int i = startindex;i&lt;nums.size();i++) &#123; path.push_back(nums[i]); back(i + 1,nums); path.pop_back(); &#125; &#125;&#125;; 子集 2 给你一个整数数组 nums ，其中可能包含重复元素，请你返回该数组所有可能的子集（幂集）。 解集 不能 包含重复的子集。返回的解集中，子集可以按 任意顺序 排列。 12345678910111213141516171819202122232425262728293031323334class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; subsetsWithDup(vector&lt;int&gt;&amp; nums) &#123; sort(nums.begin(),nums.end()); vector&lt;bool&gt; used(nums.size(), false); backtracking(nums, 0, used); return result; &#125;private: vector&lt;int&gt; path; vector&lt;vector&lt;int&gt;&gt; result; void backtracking(vector&lt;int&gt;&amp; nums,int startindex,vector&lt;bool&gt;&amp; used) &#123; result.push_back(path); for (int i = startindex; i &lt; nums.size(); i++) &#123; // used[i - 1] == true，说明同一树枝candidates[i - 1]使用过 // used[i - 1] == false，说明同一树层candidates[i - 1]使用过 // 而我们要对同一树层使用过的元素进行跳过 if(i&gt;0 &amp;&amp; nums[i] == nums[i-1] &amp;&amp; used[i-1] == false) &#123; continue; &#125; path.push_back(nums[i]); used[i] = true; backtracking(nums, i + 1, used); used[i] = false; path.pop_back(); &#125; &#125;&#125;; 贪心算法 基本题型 关于贪心的一些事情 贪心的本质是选择每一阶段的局部最优，从而达到全局最优。 验证问题是不是可以用贪心，可以举几个例子看结果是不是最优的 动态规划 基本题型 关于动态规划的一些事情 如果某一问题有很多重叠子问题，使用动态规划是最有效的。 动态规划中每一个状态一定是由上一个状态推导出来的，这一点就区分于贪心，贪心没有状态推导（和上一个状态没有关系），而是从局部直接选最优的， 所以贪心解决不了动态规划的问题。 动态规划框架 五部曲： 确定 dp数组及其下标含义 确定递推公式 初始化 dp 数组 确定遍历顺序 举例推导 dp 数组","categories":[{"name":"COURS","slug":"COURS","permalink":"http://littlewuuu.com/categories/COURS/"}],"tags":[{"name":"有点难学的","slug":"有点难学的","permalink":"http://littlewuuu.com/tags/%E6%9C%89%E7%82%B9%E9%9A%BE%E5%AD%A6%E7%9A%84/"}]},{"title":"Unbelievable!","slug":"生活/一些惊人的事","date":"2022-01-31T23:00:00.000Z","updated":"2022-02-07T15:23:18.474Z","comments":true,"path":"2022/02/01/生活/一些惊人的事/","link":"","permalink":"http://littlewuuu.com/2022/02/01/%E7%94%9F%E6%B4%BB/%E4%B8%80%E4%BA%9B%E6%83%8A%E4%BA%BA%E7%9A%84%E4%BA%8B/","excerpt":"","text":"2022-2-1 我的电饭锅被偷了！还顺走冰箱里的鸡蛋和辣椒，还好米没拿走，应该是太重了，素质没掉了😠 2022-2-2 讨论滑雪假出行，沪（lu二声）漂 from NI，这个女子总是能让我们惊掉下巴","categories":[{"name":"生活","slug":"生活","permalink":"http://littlewuuu.com/categories/%E7%94%9F%E6%B4%BB/"}],"tags":[]},{"title":"Vivre à Nantes","slug":"生活/在南特","date":"2022-01-27T23:00:00.000Z","updated":"2022-05-20T07:41:08.807Z","comments":true,"path":"2022/01/28/生活/在南特/","link":"","permalink":"http://littlewuuu.com/2022/01/28/%E7%94%9F%E6%B4%BB/%E5%9C%A8%E5%8D%97%E7%89%B9/","excerpt":"","text":"Vivre à Nantes 只要未来可期，每天都值得欣喜 有花才浪漫 菜市场也浪漫 有点想回到那个地方了 夏天 好好看的天空 La Fanfrale 好有生命力的 好满意我房间的位置，日落绝美，就是只能看一个夏天 大笨和姜姜，每次下课抱到他们都很快乐 小笨和甜甜 巧克力豆豆：没有耳朵的棕色小熊的总称，具有脑袋圆乎乎，小手胖乎乎的特点，眼睛像豆豆，超级可爱，大小笨是巧克力豆豆的典型代表。 还没有好好逛过 Nantes 春天应该有花 2022-03-12 春天太美好了 2022-03-12 嗨！ 2022-03-12 2022-03-21 整棵春天 2022-04-11 2022-04-15 搬家啦 2022-04-17 --- 我太喜欢画画了 2022-05-19","categories":[{"name":"生活","slug":"生活","permalink":"http://littlewuuu.com/categories/%E7%94%9F%E6%B4%BB/"}],"tags":[{"name":"好好生活","slug":"好好生活","permalink":"http://littlewuuu.com/tags/%E5%A5%BD%E5%A5%BD%E7%94%9F%E6%B4%BB/"}]},{"title":"SSTEM","slug":"SSTEM/SSTEM","date":"2022-01-26T23:00:00.000Z","updated":"2022-11-10T14:45:50.159Z","comments":true,"path":"2022/01/27/SSTEM/SSTEM/","link":"","permalink":"http://littlewuuu.com/2022/01/27/SSTEM/SSTEM/","excerpt":"","text":"BPMN 一些词 la finalié, la mission, les objectif les parties prenantes Le client Hervé Durand a retiré( 删除 ) tous les “Saint-Emilion” de sa commande. Yvon Manac’h a décidé de faire valoir ses droits à la retraite（退休） 模型 1. Modele entité association（有 1:n 的） 是概念模型的一种，可以看成 ER 图 2. Modele logique (把 0:n 转化成箭头) 3. Modele Physique des Données (加上每个属性的类型，integer，varchar 什么的) 也是关系模型 DATE 只有日期 TIMESTAMP 包括日期和时间 SQL 基本格式 SELECT [ DISTINCT ] [ COUNT( ) / SUM( ) / AVG( ) / MAX( ) / MIN( )] FROM [ NARURAL JOIN ] WHERE [ AND/OR/NOT/BETWEEN AND/ ] [ &lt;&gt; 不等于 ] [ IN(…) ] [ LIKE/ILIKE %(remplace quel nombre de caractères),_ (remplace un caractères) ] [ IS NOT NULL/IS NULL ] [ UPPER nom LIKE UPPER(‘ass’) ] [ IN SELECT (是 where 后面的在不在这个 select 里面)] GROUP BY [ ] ORDER BY [ 可以有多个 order by 的对象，ORDER BY 语句默认按照升序对记录进行排序。要按照降序对记录进行排序，可以使用 DESC 关键字。 ] UNION 操作符用于合并两个或多个 SELECT 语句的结果集。UNION 内部的每个 SELECT 语句必须拥有相同数量的列。列也必须拥有相似的数据类型。同时，每个 SELECT 语句中的列的顺序必须相同。 UNION 结果集中的列名总是等于 UNION 中第一个 SELECT 语句中的列名。 增删查改 数据库操作 CREATE DATABASE nom DROP DATABASE nom 表操作 CREATE TABLE（） INSERT INTO table_name [ ( 可以选择属性 ) ] VALUES ( 属性值 ) UPDATE table_name SET WHERE DELETE FROM teble_name WHERE 增删列 ALTER TABLE table_name ADD column_name datatype/DROP COLUMN column_name 更改属性 SQL Server / MS Access： ALTER TABLE table_name ALTER COLUMN column_name datatype My SQL / Oracle： ALTER TABLE table_name MODIFY COLUMN column_name datatype COMMIT ROLLBACK","categories":[{"name":"COURS","slug":"COURS","permalink":"http://littlewuuu.com/categories/COURS/"}],"tags":[{"name":"ECN","slug":"ECN","permalink":"http://littlewuuu.com/tags/ECN/"}]},{"title":"ENCLI CM notes","slug":"ENCLI/CM","date":"2022-01-21T23:00:00.000Z","updated":"2022-11-10T15:29:35.612Z","comments":true,"path":"2022/01/22/ENCLI/CM/","link":"","permalink":"http://littlewuuu.com/2022/01/22/ENCLI/CM/","excerpt":"","text":"CM4 1. Pourquoi réaliser une comptabilité carbone (碳计算)? 1.1 Contexte（背景） et chiffres clés（关键数字） mot Hausse prévisible(预计) des températures quota d’émission carbone 碳排放配额 la deuxième moitié du 21ème siècle. 下半世纪 l’inventaire national 国家清单 Temps de séjours(停留时间) des GES dans l’atmosphère éternel 永久的 1.2 Neutralité carbone（碳中和） Def: Séquestrer（绑架，拘禁） autant de carbone que nous en émettons de manière à stabiliser(稳定) son niveau de concentration（集中，浓度） dans l’atmosphère Puits de carbone : Tout système qui absorbe plus de carbone qu’il n’en émet Comment appliquer le concept de neutralité carbone ? deux leviers: • Réduire les émissions de GES • Séquestrer le CO2 dans des puits biologiques ou technologiques 1.3 Stratégie bas carbone（低碳策略） 2. La comptabilité carbone : C’est quoi ? 2.1 Référentiels(基准) et principes 3 facteurs du climat Énergie solaire, Effet de serre Circulations atmosphériques et océaniques Une unité de mesure commune, l’équivalent CO2 Le PRG (Pouvoir de réchauffement global) PRG représente l’effet combiné(综合影响) du temps de séjour du gaz dans l’atmosphère et son pouvoir（能力） relatif d’absorption du rayonnement（辐射）infrarouge（红外线）, cumulé sur une durée de 100 ans. bilans GES Def: Un Bilan GES est une évaluation de la quantité de gaz à effet de serre émise (ou captée) dans l’atmosphère sur une année par les activités d’une organisation ou d’un territoire(地区). Postes d’émissions Classer les émissions comptabilisées dans des catégories prédéterminées appelées « postes » Pourquoi calculer les émissions GES ? Objectif principal: Identifier les « postes » les plus émetteurs afin de déterminer les leviers d’actions pour diminuer les émissions de gaz à effet de serre. 2.2 Méthodes 3. Stratégie bas carbone :Vers une trajectoire 1,5°C Cas d’une organisation 3.1 Evaluation des émissions GES 3.2 Emissions évitées 3.3 Développement d’une stratégie bas carbone 3.4 Mise en œuvre et suivi du plan d’action 3.5 Evaluation de la stratégie 4. Comment s’aligner sur une trajectoire compatible avec les 1,5°C ? 4.1 Equation de Kaya 4.2 Conclusion CM7 objectif zéro 1 une problème complexe 1.1 médicament avec effct secondaire Il y a quelques mois nous fêtions(fêter) le 6 ème anniversaire de l’accord de Paris. Si à certains égards(在某些方面) cet accord fut（etre 的虚拟式） un succès, force est de constater（观察到） que depuis très peu de progrès ont été accomplis et seule une pandémie mondiale est venue inverser la courbe des émissions de CO2. Pourquoi cela ? Pourquoi est-ce si dure（费劲的） de changer ? Pourquoi patinons nous dans cette course contre le réchauffement climatique ? correction: –les energie fossiles fournissent toujours environ 80% de l’approvisionnement mondiale d’energie primaire –sans precedent croissance economique synonyme de progres humains 1.2 inertie(惯性) –l’inertie de nos systemes –nous avons appris à vivre avec les énergie fossiles. –les remplacer necessitera de très lourd, couteux et profonds changement dans nos infrastructure et notre économie 1.3 dilemme du prisonnier(囚徒困境) tout le mond veut sauver la planète mai personne ne veut pas descendre les poubelles c’est quoi? Un procureur détient deux complices d’un braquage dans des cellules séparées. Il n’a pas suffisamment de preuves pour les inculper et leur propose un marché（交易） : • Si l’un deux accepte de témoigner contre l’autre il sera libéré et le complice ira en prison pour 10 ans • Si chacun balance, c’est 6 ans pour les deux • Si ils restent loyaux, le procureur ne pourra que les condamner pour un chef d’accusation mineur (6 mois de prison chacun). une variante: le probleme du passager clandestin(freerider) Dans un train, le passager clandestin, celui qui ne paie pas son billet, profite d’un service auquel il ne contribue pas. Pour le RC c’est pareil. Les pays qui ne feront pas d’effort de réduction des émissions de CO2 bénéficient de l’effort des autres pays. On a toujours intérêt, égoïstement, à être le dernier à passer à l’action. Et à l’inverse, un pays qui déciderait seul de faire des efforts ne récupérait qu’une part marginale des bénéfices. baisse des rendements（产量）agricoles = hausse des prix montée du niveau de la mer = construction de digue augmentation du nombre de canicules(酷暑) = climatisation Beaucoup de dépenses contre la lutte = peu de dommage peu de dépenses = beaucoup de dommage Il y a donc un optimum entre coût de la lutte contre le RC et coût des impacts du RC Pour caricaturer mieux vaut-il vivre dans un monde à +2 °C pauvre ou un monde à +3 °C riche avec clim Jusqu’à récemment le consensus semblait être assez haut (+3 °C) Avec l’amélioration de la science climatique et la baisse du coût des ENR, l’optimum semble se déplacer vers le bas 1.4 pas de coupable ideal complique != complexe Jouer au golf c’est compliqué (le jonglage（杂技） est aussi un bon exemple). Acquérir le bon geste(姿势) peut prendre des années. Mais les règles et la stratégie sont relativement simples. Les échecs(国际象棋) sont tout le contraire. Déplacer un pièce est simple mais les règles sont complexes et les stratégies infinis. Le jeu est complexe. C’est la multiplicité des possibilités, des interactions, des combinaisons, des rétroactions（反馈） qui rend un problème complexe plus que compliqué. Les enjeux énergétiques, environnementaux et climatiques sont complexes, les problèmes sont mal posés, difficile à simuler, il a des multiples solutions et aucune n’est parfaite. Il est même très difficile de dire qu’une solution est meilleure qu’une autre, ceci relevant souvent des préférences personnelles comme la politique (exemple : nucléaire vs renouvelables) 2 trajectoire bas carbone（低碳） 4 commandements de la neutralité carbone Réduire ne suffit pas. Dans certains secteurs comme les transports ou le bâtiment il faudra quasiment intégralement stopper la combustion d’énergies fossiles ! D’autres secteurs au contraire seront très difficile à décarboner et donc … L’immense majorité des scénarios de transition énergétique s’appuient plus ou moins sur des émissions négatives Il est possible de réduire très rapidement nos émissions ou les réduire moins vite mais il faudra alors compenser avec plus d’émissions négatives Les émissions négatives sont faites par la main de l’homme. Ne pas confondre avec les puits naturels forcés qui ne comptent pas dans la neutralité carbone et cesseront d’être forcé et donc d’absorber une partie de nos émissions au fur et à mesure que la concentration de CO2 baissera Équation de Kaya CO2 = P×S×E×C （Les termes ne sont pas indépendants） 1. Population Baisse du taux de croissance du à la (由于): transition démographique（人口转型） 2. S Le PIB c’est la somme des revenus 3. E –Moins d’énergie pour le même service –Plus on progresse plus il est difficile de progresser (low hanging fruits) –E = Energ/PIB –Le PIB mesure la valeur des choses ! Pas l’énergie –E x 0,4 à 0,7 4. PSEE Réduire ne suffit pas! Il faut arriver à ~ 0 5. C –contenu(含量) CO2 de l’énergie. Seul terme qui pourrait s’annuler. La combinaison des trois premiers facteurs pourrait, par miracle(奇迹), être inférieure à 1 (être inférieur à…比……低)， mais aucun des termes ne pourra tomber à zéro. En effet, comme Kaya est une multiplication, il suffit qu’un seul des termes s’annule pour que tout s’annule. découplage：chaque nouvelle unité de richesse produite, l’humanité consomme moins d’énergie. 3. Les 8 piliers(支柱) de la transition(转型) global sources of GES 右边三个通常是被注意到的，左边除了 industry fuel use，通常被忽略 –Il n’y a aucun coupable idéal, aucune cause majeure. Viser la suppression plutôt que la réduction（Réduire ne suffit pas） –Baisser la consommation des moteurs(发动机) à combustion n’est que retarder l’échéance（期限） –Adapter les moteurs à combustion pour qu’ils brulent des carburants propres(清洁材料) est une solution à 100 % Critères pour évaluer si une solution est bonne : ▪ Prix ▪ Échelle ▪ Nombre de personnes impliquées ▪ Mode de vie ▪ Solution 10 ou 100 % 8 piliers (Il n’est pas nécessaire de procéder(进行) de manière séquentielle.) Maitrise（控制）des consommation Sobriété + efficacité énergétique ▪ Sobriété : potentiel faible ▪ Efficacité énergétique : fort potentiel (électrification) Les deux sont essentiels Bonne efficacité économique Réduit investissement énergie décarbonée, émissions négatives Électricité propre(清洁能源) –La génération d’électricité est aussi le poste le plus facile à décarboner : c’est donc notre premier pilier –Renouvelables –hydroélectrique ▪ Bas carbone ▪ Pas cher à exploiter ▪ Sûr ▪ Renouvelable ▪ Stockage ▪ Pilotable ▪ Centralisée mais ▪ Couteux à construire / matériaux ▪ Biodiversité ▪ Espace ▪ Méthane ? –Solaire ▪ Bas carbone ▪ Pas cher à exploiter ▪ Sûr ▪ Renouvelable ▪ Facile à déployer mais ▪ Non pilotable (不可控) / Intermittent（间断的） ▪ Matériaux ▪ Espace ▪ Décentralisée –Éolien –Biomasse –Nucléaire Brown coal = lignite（褐煤） : charbon de mauvais qualité Equilibre du réseau Def: L’électricité ne se stocke pas，Si bien que pour ne pas faire exploser le réseau, « les électrons produits doivent être consommés aussi tôt ». “La production d’électricité doit toujours être égale à la consommation sous peine de coupures voir de black out. Cette tâche cruciale de suivie de charge est assurée en France par RTE, le gestionnaire du réseau électrique. A l’aide des prévisions météo et de profils de consommation étonnamment régulier, RTE est capable de prédire quelle sera la consommation électrique du lendemain.” Électrification（电气化） –les voitures élec sont meilleures pour l’environnement que les voitures thermiques (y compris hybride) Mais l’électrification c’est bien plus que la voiture. Les équivalents électriques（电动同类产品） sont souvent plus chers à l’achat et moins chers à l’usage. Ils ont besoin d’être subventionné（补贴）. Les subventions et les gens qui acceptent de payer plus cher donnent une indication（指示）au marché qui se met alors à en produire plus. En produisant plus on devient meilleur à la production et les coûts de fabrication baissent, entrainant（带动）une baisse du coût d’achat et donc une hausse de la demande, etc. Cercle vertueux. Mais les équivalents électriques seront rarement intéressant au point de jeter une machine thermique encore fonctionnelle. Carburant（燃料） de synthèse（合成） Hydrogène 氢气-&gt;Ammoniac 氨水 Solutions pour émissions non liées à de la combustion 1/3 des émissions sont liées à des processus n’impliquant pas de production d’énergie Production de ciment Deux sources de CO2 Énergie fossile pour chauffer le four La décarbonatation du calcaire pendant la phase de pré-calcination dans le four : CaCO 3 → CaO + CO2 Production d’acier Deux sources de CO2 : Énergie fossile pour chauffer le four CO2 du à l’utilisation de charbon pour faire l’acier AFOLU : Agriculture, Forestry, and Other Land Use Capturer et stocker CCS En anglais : carbone capture and storage, adapté pour le stockage de sources ponctuelles En français : Séquestration géologique de CO2 Carbone Dioxyde Removal (CDR) les techniques visant à retirer le CO2 atmosphérique P190看到 7. Adaptation 8. Géo-ingéniérie TD 重要公式： 1tep = 11630 kWh 1Wh = 1W * 3600s = 3600 J (w = J/s) 1 BTU = 1055 J 1 Calorie = 4.18 J 1 kCal = 4184 J 电池功率（Wh）=电池电压（V）x电池容量（Ah） W = V * A = J/s energir(J) -&gt; puissance moyenne(W = J/s) -&gt; puissance moyenne surfacique(W/m2) puissance moyenne (W) = puissance installe * facteur de charge puissance moyenne surfacique(W/m2)= puissance moyenne/surface (W/m2) production annuelle(TWh) puissance moyenne(MW) = production anuelle / (365*24) puissance moyenne surfacique(W) = puissance moyenne / surface","categories":[{"name":"COURS","slug":"COURS","permalink":"http://littlewuuu.com/categories/COURS/"}],"tags":[{"name":"ECN","slug":"ECN","permalink":"http://littlewuuu.com/tags/ECN/"}]},{"title":"去过的一些地方","slug":"SomePlaces/去过的一些地方","date":"2022-01-01T23:00:00.000Z","updated":"2022-11-10T16:10:13.157Z","comments":true,"path":"2022/01/02/SomePlaces/去过的一些地方/","link":"","permalink":"http://littlewuuu.com/2022/01/02/SomePlaces/%E5%8E%BB%E8%BF%87%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9C%B0%E6%96%B9/","excerpt":"","text":"Vichy 很快乐的一个月，应该会再去一次吧 Feu d'artifice Spectacle de umière 第一次被这个小镇浪漫到 Lac d'Allier 很喜欢夏天的河边 Cavilam 突然想起高中的时候，在这里学会了 tranquillement 很喜欢这样的小镇 很自由的感觉 超好的房东， 看我不敢讲法语还找个学长来陪我聊天😭，超好的瑞士小哥 还有马来西亚的小伙伴人都好好，（忽略你们说我讲国语有口音） Lyon Vieux Lyon 老城还是有魅力的 有够幸运的我们仨 在一个公园看到的， Paris 还是浪漫的 Malta 姜姜也开心，住上大房子，坐上大邮轮 还是喜欢海 Roma 永远喜欢日落 不是很喜欢罗马， 手机是在那里摔的，衣服是邮局门口被鸟屎淋的，但是还是人间值得了 Milan 大教堂和大圣诞树 在米兰过了小半个圣诞节 还有在邮局买邮票，被意大利语一通输出，这辈子不进意大利邮局了 La Baule 一直很喜欢海边 Strasbourg 2022 - 02 - 12 Nantes->Paris->Strasbourg 第一次自驾 自驾的惊喜吧 突然有了回家的感觉 小小的好可爱 全是自由 Marseille 13-05-2022 Marseille(calanque) 30-06-2022 Nice 04-07-2022 Monaco 06-07-2022 Paris 14-07-2022 ColdplayParis 16-07-2022 Swiss 31-10-2022","categories":[{"name":"生活","slug":"生活","permalink":"http://littlewuuu.com/categories/%E7%94%9F%E6%B4%BB/"}],"tags":[{"name":"到处玩","slug":"到处玩","permalink":"http://littlewuuu.com/tags/%E5%88%B0%E5%A4%84%E7%8E%A9/"}]},{"title":"不知名大厨的美食","slug":"整活/奇奇怪怪的菜","date":"2021-12-30T23:00:00.000Z","updated":"2022-02-04T17:25:35.708Z","comments":true,"path":"2021/12/31/整活/奇奇怪怪的菜/","link":"","permalink":"http://littlewuuu.com/2021/12/31/%E6%95%B4%E6%B4%BB/%E5%A5%87%E5%A5%87%E6%80%AA%E6%80%AA%E7%9A%84%E8%8F%9C/","excerpt":"","text":"暂时称作蝴蝶碳 Via: Wenli ZHANG 鸡腿碳 Via: Li NI 鸡腿碳 Via: Li NI 绿色心情 Via: Zilong WU","categories":[{"name":"做饭区","slug":"做饭区","permalink":"http://littlewuuu.com/categories/%E5%81%9A%E9%A5%AD%E5%8C%BA/"}],"tags":[{"name":"一些奇奇怪怪的吃的","slug":"一些奇奇怪怪的吃的","permalink":"http://littlewuuu.com/tags/%E4%B8%80%E4%BA%9B%E5%A5%87%E5%A5%87%E6%80%AA%E6%80%AA%E7%9A%84%E5%90%83%E7%9A%84/"}]},{"title":"markdown 没学明白指南","slug":"markdown基本语法","date":"2021-12-29T23:00:00.000Z","updated":"2022-12-01T15:39:40.784Z","comments":true,"path":"2021/12/30/markdown基本语法/","link":"","permalink":"http://littlewuuu.com/2021/12/30/markdown%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/","excerpt":"","text":"#一级标题 ##二级 ###三级 *** 斜体加粗 *** 删除线 引用1 引用2 引用3 ​ 分割线 加粗了 也可以使用 command+b 来加粗 斜体 也可以使用 command+i 来斜体 1.第一个 2.第二个 3.第三个 插入图片 12![图片名称](图片地址)*图片标题* ##输入 LaTeX 公式 enter latex between these two 美元符号 enterlatexbetweenthesetwoenter latex between these two enterlatexbetweenthesetwo command + m 连续按两下，出现四个$ command + m 出现两个在一段句子中插入公式 在一段句子中插入公式在一段句子中插入公式 sin (x) $ 表格 | 姓名 | 学号 | | -------😐 :--------- | :--------: | ---- | | wuzilong | 2019110473 | 计算机一班 | ##插入链接 复制链接，然后选中想要添加链接的文字，command+v，就可以自动添加了，这是一个链接 code 12int main(void)美式键盘下打出这三个小撇 超链接 微博 Markdown本身语法不支持链接在新页面中打开，貌似简书做了处理，是可以的。别的平台可能就不行了，如果想要在新页面中打开的话可以用html语言的a标签代替。 超链接名 示例 简书 列表 无序列表 “-”可以表示列表 “+”也可以 “*”也可以 有序列表 第一个 第二个,可以用 tab 键来实现不同级别 第三个 序号和后面的内容要有空格 流程图 1234567st=&gt;start: 开始op=&gt;operation: 选择cond=&gt;condition: Yes or No?e=&gt;end: endst-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;op 图片并排 123&lt;center class=&quot;half&quot;&gt;&lt;img src=&quot;https://...&quot; width=40%/&gt; &lt;img src=&quot;https://...&quot; width=40%/&gt; &lt;/center&gt; 标题居中加粗 12&lt;div align=&#x27;center&#x27; &gt;&lt;font size=&#x27;5&#x27;&gt; &lt;strong&gt;&quot;...&quot;&lt;/strong&gt;&lt;/font&gt;&lt;/div&gt;&lt;br/&gt; 换行符 1&lt;br/&gt; 空格 12&amp;nbsp LaTeX 希腊字母 \\leq 小于等于 \\geq 大于等于 \\forall 任意 \\in 存在 \\frac{}{} 分式 \\triangleup \\triangledown \\sum \\lambda \\rho \\bar{} : aˉ\\bar{a}aˉ","categories":[{"name":"SKILLS","slug":"SKILLS","permalink":"http://littlewuuu.com/categories/SKILLS/"}],"tags":[{"name":"学了又忘的杂七杂八","slug":"学了又忘的杂七杂八","permalink":"http://littlewuuu.com/tags/%E5%AD%A6%E4%BA%86%E5%8F%88%E5%BF%98%E7%9A%84%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/"}]},{"title":"计算机图形学","slug":"计算机图形学","date":"2021-12-29T23:00:00.000Z","updated":"2022-11-10T14:44:59.537Z","comments":true,"path":"2021/12/30/计算机图形学/","link":"","permalink":"http://littlewuuu.com/2021/12/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/","excerpt":"","text":"还没开始学 😦 开始学了，学了视角变换，投影，透视，光栅化，shading。 MVP","categories":[{"name":"COURS","slug":"COURS","permalink":"http://littlewuuu.com/categories/COURS/"}],"tags":[{"name":"有点难学的","slug":"有点难学的","permalink":"http://littlewuuu.com/tags/%E6%9C%89%E7%82%B9%E9%9A%BE%E5%AD%A6%E7%9A%84/"}]},{"title":"conditionnel","slug":"Francaise/conditionnel","date":"2021-12-29T23:00:00.000Z","updated":"2021-12-31T19:14:47.046Z","comments":true,"path":"2021/12/30/Francaise/conditionnel/","link":"","permalink":"http://littlewuuu.com/2021/12/30/Francaise/conditionnel/","excerpt":"","text":"conditionnel présent 组成 简单将来词干+未完成过去词尾 avoir 单数 复数 第一人称 j’aurais nous aurions 第二人称 tu aurais vous auriez 第三人称 il aurait ils auraient être 单数 复数 第一人称 je serais nous serions 第二人称 tu serais vous seriez 第三人称 il serait ils seraient 用法 表示委婉请求建议 Tu devrais faire plus d’attention au temps．(委婉建议) Il y aurait plus de possibilités de réussir．(表推测，不能肯定) Je voudrais aller en France dans un an．(表示愿望) Marie viendrait chercher ses enfants demain. 玛丽也许明天会来接她的孩子。 表示与实际情况相反 Si elle était riche，elle voudrait acheter un chateau．(她如果富有的话，她想买一个城堡。） 表示将来可能发生的情况 S’il pleuvait demain，ma copine et moi resteraient à la maison 如果动作实现的可能性极大，主句也可以用直陈式简单将来时，从句用直陈式现在时。试比较： S’il fait beau demain, on ira au bord de la mer. （如果明天天气好，我们就去海边。） 根据现在的迹象表明明天的天气很可能会很好，我们去海边的可能性很大。 S’il faisait beau demain, on irait au bord de la mer.（如果明天天气好，我们就去海边。） 但是根据现在的迹象表明很有可能明天天气不好，我们去海边的可能性很小。","categories":[{"name":"le français","slug":"le-francais","permalink":"http://littlewuuu.com/categories/le-francais/"}],"tags":[{"name":"le français","slug":"le-francais","permalink":"http://littlewuuu.com/tags/le-francais/"}]},{"title":"好吃的","slug":"好吃的/真好吃","date":"2021-12-29T23:00:00.000Z","updated":"2022-03-19T14:46:14.246Z","comments":true,"path":"2021/12/30/好吃的/真好吃/","link":"","permalink":"http://littlewuuu.com/2021/12/30/%E5%A5%BD%E5%90%83%E7%9A%84/%E7%9C%9F%E5%A5%BD%E5%90%83/","excerpt":"","text":"糊弄一下 龙虾意面 ( ROMA ) 土豆炖排骨 ( REZ B ) &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp 土豆炖虾 ( REZ B ) 沙拉 ( Vichy )&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp 土豆牛腩 ( REZ B ) 豚骨汤 ( REZ B ) &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp 卤鸡腿 ( REZ B ) &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp Via: Li NI 干锅鸡 ( REZ B ) &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp 卤鸡腿 ( REZ B ) Via: Li NI &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp 猪肘子( REZ B ) and 科尔马的猪肘子（Le Fer Rouge）","categories":[{"name":"做饭区","slug":"做饭区","permalink":"http://littlewuuu.com/categories/%E5%81%9A%E9%A5%AD%E5%8C%BA/"}],"tags":[{"name":"一些正正经经的吃的","slug":"一些正正经经的吃的","permalink":"http://littlewuuu.com/tags/%E4%B8%80%E4%BA%9B%E6%AD%A3%E6%AD%A3%E7%BB%8F%E7%BB%8F%E7%9A%84%E5%90%83%E7%9A%84/"}]},{"title":"教会自己用 git","slug":"Git/git_usage1","date":"2021-12-02T23:00:00.000Z","updated":"2022-12-01T15:23:54.260Z","comments":true,"path":"2021/12/03/Git/git_usage1/","link":"","permalink":"http://littlewuuu.com/2021/12/03/Git/git_usage1/","excerpt":"","text":"练习网站：https://learngitbranching.js.org/?locale=zh_CN I. 常用命令 123git reflog //查看引用日志git log //查看详细日志git status //查看状态 ^ 表示上一个提交 ~n 表示上 n 个提交 git reset 用于本地 git revert 用于远程仓库 git cherry-pick &lt;提交号&gt;… 基于 head 所在的位置 交互式 rebase 指的是使用带参数 --interactive 的 rebase 命令, 简写为 -i Git branch -f three c2 强制把 three 分支移动到c2 Remote remote 用于管理远程仓库。 II. 版本穿梭 12git reflog 查看版本号git reset --hard + 版本号 实现原理是 git 有一个 head 指针，指向不同的版本 III. 实现本地文件和 Github 仓库同步 Macbook Air M1 ssh 等配置 在 GitHub 上创建仓库 准备好本地的文件存放位置 切换终端目录到本地文件夹 初始化本地文件夹 1git init 连接到 GitHub 仓库 1git remote add origin 仓库网址（注意是 ssh 不是 url） 切换 1git branch -M main 把想要上传的文件拖放到本地文件夹 上传 将文件送到缓区 所有文件 1git add . //把本地文件夹的所有内容送到缓存区 指定文件 1git add filename //把指定的文件送到缓存区 暂存区的文件可以删除 commit 提交本地库 必须要有这一步，如果是全部文件到缓存区，则所有的文件都是这个注释，如果是指定文件到缓存区，则对指定文件注释 1git commit -m “注释” 上传 1git push -u origin main 取消链接 1git remote remove origin IV. 分支 1234git branch -v //查看当前分支git branch + 分支名 //创建分支git chekout + 分支名 //切换到指定分支git merge + 分支名 //把指定的分支合并到当前的分支 分支合并冲突（merge conflict） 合并分支的时候，两个分支在同一个文件的同一个位置有两种不同的修改。git 无法替我们决定使用哪一个，必须人为决定。 &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;head 和 ==== 之间的是当前分支的代码 ==== 和 &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;hot-fix 之间的是 hot-fix 分支的代码 修改的时候要把&lt;&lt;&lt;&lt;&lt;head 等都删掉，保留自己想要的代码 V. 团队协作 1. 团队内 push 要先成为远程库的 collaborator 2. 跨团队 VI. 三种分支合并 HEAD 一直指向当前所在的分支的 commit（相当于指针） 1. fast-forward 12git checkout mastergit merge test 2. no-ff 12git checkout mastergit merge –no-ff test 3. rebase 1 VII. 分支引用 git checkout 是把 head 移动到指定位置 Head 指向的是当前所在的最后一次commit 可以通过 git checkout pushed 把 head 切换到 pushed 这里，就变成 pushed*，* 表示 head 当前在这里","categories":[{"name":"SKILLS","slug":"SKILLS","permalink":"http://littlewuuu.com/categories/SKILLS/"}],"tags":[{"name":"学了又忘的杂七杂八","slug":"学了又忘的杂七杂八","permalink":"http://littlewuuu.com/tags/%E5%AD%A6%E4%BA%86%E5%8F%88%E5%BF%98%E7%9A%84%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/"}]},{"title":"JAVA","slug":"Java/JavaNotes","date":"2021-09-06T22:00:00.000Z","updated":"2022-12-01T15:43:06.309Z","comments":true,"path":"2021/09/07/Java/JavaNotes/","link":"","permalink":"http://littlewuuu.com/2021/09/07/Java/JavaNotes/","excerpt":"","text":"String 类 使用 Unicode 编码，一个字符（不区分字母汉字）占两个字节 String 是 final 类 属性 private final char value[] 存放字符串内容，指向的地址不能修改，但是地址里的内容可以改 创建 String 的两种方式的区别 如果父类该属性是私有的，就直接报错，即使父类的父类有该属性且不是私有 方法重写 多态 （方法+对象） 1、 方法的多态就是 【重写】 +【 重载】 2、 对象的多态 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172package com.hspedu.poly_.detail_;public class Animal &#123; String name = &quot;动物&quot;; int age = 10; public void sleep()&#123; System.out.println(&quot;睡&quot;); &#125; public void run()&#123; System.out.println(&quot;跑&quot;); &#125; public void eat()&#123; System.out.println(&quot;吃&quot;); &#125; public void show()&#123; System.out.println(&quot;hello,你好&quot;); &#125;&#125;---------------------------package com.hspedu.poly_.detail_;public class Cat extends Animal &#123; public void eat()&#123;//方法重写 System.out.println(&quot;猫吃鱼&quot;); &#125; public void catchMouse()&#123;//Cat特有方法 System.out.println(&quot;猫抓老鼠&quot;); &#125;&#125;---------------------------package com.hspedu.poly_.detail_;public class Dog extends Animal &#123;//Dog是Animal的子类&#125;---------------------------package com.hspedu.poly_.detail_;public class PolyDetail &#123; public static void main(String[] args) &#123; //向上转型: 父类的引用指向了子类的对象 //语法：父类类型引用名 = new 子类类型(); Animal animal = new Cat(); Object obj = new Cat();//可以吗? 可以 Object 也是 Cat的父类 //向上转型调用方法的规则如下: //(1)可以调用父类中的所有成员(需遵守访问权限) //(2)但是不能调用子类的特有的成员 //(#)因为在编译阶段，能调用哪些成员,是由编译类型来决定的 //animal.catchMouse();错误 //(4)最终运行效果看子类(运行类型)的具体实现, 即调用【方法】时，按照从子类(运行类型)开始查找方法 //，然后调用，规则我前面我们讲的方法调用规则一致。 animal.eat();//猫吃鱼.. animal.run();//跑 animal.show();//hello,你好 animal.sleep();//睡 //老师希望，可以调用Cat的 catchMouse方法 //多态的向下转型 //(1)语法：子类类型 引用名 =（子类类型）父类引用; //cat 的编译类型 Cat,运行类型是 Cat Cat cat = (Cat) animal;//之前的 animal 本来就是指向 Cat，所以可以向下转型 cat.catchMouse();//猫抓老鼠 //(2)要求父类的引用必须指向的是当前目标类型的对象 Dog dog = (Dog) animal; //不可以 System.out.println(&quot;ok~~&quot;); &#125;&#125; 3、instanceof 判断对象的【运行类型】是否为 XX 类型或其子类 123456789101112131415161718192021222324package com.hspedu.poly_.detail_;public class PolyDetail03 &#123; public static void main(String[] args) &#123; BB bb = new BB(); System.out.println(bb instanceof BB);// true System.out.println(bb instanceof AA);// true //aa 编译类型 AA, 运行类型是BB //BB是AA子类 AA aa = new BB(); System.out.println(aa instanceof AA); System.out.println(aa instanceof BB); Object obj = new Object(); System.out.println(obj instanceof AA);//false String str = &quot;hello&quot;; //System.out.println(str instanceof AA); System.out.println(str instanceof Object);//true &#125;&#125;class AA &#123;&#125; //父类class BB extends AA &#123;&#125;//子类 4、练习 5、动态绑定机制 1234567891011121314151617181920212223242526272829303132333435363738394041424344package com.hspedu.poly_.dynamic_;public class DynamicBinding &#123; public static void main(String[] args) &#123; //a 的编译类型 A, 运行类型 B A a = new B();//向上转型 System.out.println(a.sum());//?40 -&gt; 30(把 B的 sum（）注释) System.out.println(a.sum1());//?30-&gt; 20（把 B 的 sum1（）注释） &#125;&#125;class A &#123;//父类 public int i = 10; //动态绑定机制: public int sum() &#123;//父类sum() return getI() + 10;//20 + 10 &#125; public int sum1() &#123;//父类sum1() return i + 10;//10 + 10 &#125; public int getI() &#123;//父类getI return i; &#125;&#125;class B extends A &#123;//子类 public int i = 20;// public int sum() &#123;// return i + 20;// &#125; public int getI() &#123;//子类getI() return i; &#125;// public int sum1() &#123;// return i + 10;// &#125;&#125; 多态数组 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128package com.hspedu.poly_.polyarr_;public class Person &#123;//父类 private String name; private int age; public Person(String name, int age) &#123; this.name = name; this.age = age; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public String say() &#123;//返回名字和年龄 return name + &quot;\\t&quot; + age; &#125;&#125;-------------------- package com.hspedu.poly_.polyarr_;public class Student extends Person &#123; private double score; public Student(String name, int age, double score) &#123; super(name, age); this.score = score; &#125; public double getScore() &#123; return score; &#125; public void setScore(double score) &#123; this.score = score; &#125; //重写父类say @Override public String say() &#123; return &quot;学生 &quot; + super.say() + &quot; score=&quot; + score; &#125; //特有的方法 public void study() &#123; System.out.println(&quot;学生 &quot; + getName() + &quot; 正在学java...&quot;); &#125;&#125;------------------- package com.hspedu.poly_.polyarr_;public class Teacher extends Person &#123; private double salary; public Teacher(String name, int age, double salary) &#123; super(name, age); this.salary = salary; &#125; public double getSalary() &#123; return salary; &#125; public void setSalary(double salary) &#123; this.salary = salary; &#125; //写重写父类的say方法 @Override public String say() &#123; return &quot;老师 &quot; + super.say() + &quot; salary=&quot; + salary; &#125; //特有方法 public void teach() &#123; System.out.println(&quot;老师 &quot; + getName() + &quot; 正在讲java课程...&quot;); &#125;&#125;------------- package com.hspedu.poly_.polyarr_;public class PloyArray &#123; public static void main(String[] args) &#123; //应用实例:现有一个继承结构如下：要求创建1个Person对象、 // 2个Student 对象和2个Teacher对象, 统一放在数组中，并调用每个对象say方法 Person[] persons = new Person[5]; persons[0] = new Person(&quot;jack&quot;, 20); persons[1] = new Student(&quot;mary&quot;, 18, 100); persons[2] = new Student(&quot;smith&quot;, 19, 30.1); persons[3] = new Teacher(&quot;scott&quot;, 30, 20000); persons[4] = new Teacher(&quot;king&quot;, 50, 25000); //循环遍历多态数组，调用say for (int i = 0; i &lt; persons.length; i++) &#123; //老师提示: person[i] 编译类型是 Person ,运行类型是是根据实际情况有JVM来判断 System.out.println(persons[i].say());//动态绑定机制 //这里大家聪明. 使用 类型判断 + 向下转型. if(persons[i] instanceof Student) &#123;//判断person[i] 的运行类型是不是Student Student student = (Student)persons[i];//向下转型 student.study(); //小伙伴也可以使用一条语句 ((Student)persons[i]).study(); &#125; else if(persons[i] instanceof Teacher) &#123; Teacher teacher = (Teacher)persons[i]; teacher.teach(); &#125; else if(persons[i] instanceof Person)&#123; //System.out.println(&quot;你的类型有误, 请自己检查...&quot;); &#125; else &#123; System.out.println(&quot;你的类型有误, 请自己检查...&quot;); &#125; &#125; &#125;&#125; 多态参数 形参父类，实参可以是子类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108package com.hspedu.poly_.polyparameter_;public class Employee &#123; private String name; private double salary; public Employee(String name, double salary) &#123; this.name = name; this.salary = salary; &#125; //得到年工资的方法 public double getAnnual() &#123; return 12 * salary; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public double getSalary() &#123; return salary; &#125; public void setSalary(double salary) &#123; this.salary = salary; &#125;&#125;---------------------- package com.hspedu.poly_.polyparameter_;public class Manager extends Employee&#123; private double bonus; public Manager(String name, double salary, double bonus) &#123; super(name, salary); this.bonus = bonus; &#125; public double getBonus() &#123; return bonus; &#125; public void setBonus(double bonus) &#123; this.bonus = bonus; &#125; public void manage() &#123; System.out.println(&quot;经理 &quot; + getName() + &quot; is managing&quot;); &#125; //重写获取年薪方法 @Override public double getAnnual() &#123; return super.getAnnual() + bonus; &#125;&#125;-------------------- package com.hspedu.poly_.polyparameter_;public class Worker extends Employee &#123; public Worker(String name, double salary) &#123; super(name, salary); &#125; public void work() &#123; System.out.println(&quot;普通员工 &quot; + getName() + &quot; is working&quot;); &#125; @Override public double getAnnual() &#123; //因为普通员工没有其它收入，则直接调用父类方法 return super.getAnnual(); &#125;&#125;----------------------- package com.hspedu.poly_.polyparameter_;public class PloyParameter &#123; public static void main(String[] args) &#123; Worker tom = new Worker(&quot;tom&quot;, 2500); Manager milan = new Manager(&quot;milan&quot;, 5000, 200000); PloyParameter ployParameter = new PloyParameter(); ployParameter.showEmpAnnual(tom); ployParameter.showEmpAnnual(milan); ployParameter.testWork(tom); ployParameter.testWork(milan); &#125; //showEmpAnnual(Employee e) //实现获取任何员工对象的年工资,并在main方法中调用该方法 [e.getAnnual()] public void showEmpAnnual(Employee e) &#123; System.out.println(e.getAnnual());//动态绑定机制. &#125; //添加一个方法，testWork,如果是普通员工，则调用work方法，如果是经理，则调用manage方法 public void testWork(Employee e) &#123; if(e instanceof Worker) &#123; ((Worker) e).work();//有向下转型操作 &#125; else if(e instanceof Manager) &#123; ((Manager) e).manage();//有向下转型操作 &#125; else &#123; System.out.println(&quot;不做处理...&quot;); &#125; &#125;&#125; 当一个方法是 static 时，可以直接通过类名调用 匿名对象：new Person().show() 继承 123456789101112131415public class test &#123; public static void main(String[] args) &#123; person stu = new student(); student.show(); //注意这里虽然是父类里面的方法的 this，但是 this 其实还是 stu 的，因为只有一个 this。 &#125;&#125;class person&#123; public void show()&#123; System.out.println(this.getClass()); &#125;&#125; class student extends person&#123;&#125; 集合 Java集合大致可以分为两大体系，一个是Collection，另一个是Map Collection ：主要由List、Set、Queue接口组成 List代表有序、重复的集合； ArrayList ArrayList是一个动态数组结构，支持随机存取，尾部插入删除方便，内部插入删除效率低（因为要移动数组元素）；如果内部数组容量不足则自动扩容，因此当数组很大时，效率较低。 1List&lt;String&gt; list = new ArrayList&lt;&gt;(); LinkedList LinkedList是一个双向链表结构，在任意位置插入删除都很方便，但是不支持随机取值，每次都只能从一端开始遍历，直到找到查询的对象，然后返回；不过，它不像 ArrayList 那样需要进行内存拷贝，因此相对来说效率较高，但是因为存在额外的前驱和后继节点指针，因此占用的内存比 ArrayList 多一些。 Vector Set代表无序、不可重复的集合； HashSet： HashSet类按照哈希算法来存取集合中的对象，存取速度比较快 TreeSet ：TreeSet类实现了SortedSet接口，能够对集合中的对象进行排序 Queue代表一种队列集合实现。 Map：则代表具有映射关系的键值对集合。 HashMap 重复放入key-value并不会有任何问题，但是一个key只能关联一个value。新加入的会覆盖掉原来的。也就是说 key不能重复，但是 value 可以重复。 无序 123456789101112public class Main &#123; public static void main(String[] args) &#123; Student s = new Student(&quot;Xiao Ming&quot;, 99); Map&lt;String, Student&gt; map = new HashMap&lt;&gt;(); map.put(&quot;Xiao Ming&quot;, s); // 将&quot;Xiao Ming&quot;和Student实例映射并关联 Student target = map.get(&quot;Xiao Ming&quot;); // 通过key查找并返回映射的Student实例 System.out.println(target == s); // true，同一个实例 System.out.println(target.score); // 99 Student another = map.get(&quot;Bob&quot;); // 通过另一个key查找 System.out.println(another); // 未找到返回null &#125;&#125; 泛型 E 具体的数据类型在定义 Person 对象的时候指定,即在编译期间，就确定 E 是什么类型 Tiger 后面泛型，所以我们把 Tiger 就称为自定义泛型类 T, R, M 泛型的标识符, 一般是单个大写字母 泛型标识符可以有多个. 普通成员可以使用泛型 (属性、方法) 使用泛型的数组，不能初始化 (new) 因为数组在 new 不能确定 T 的类型，就无法在内存开空间 静态方法中不能使用类的泛型 因为静态是和类相关的，在类加载时，对象还没有创建 所以，如果静态方法和静态属性使用了泛型，JVM 就无法完成初始化 所以如果static方法要使用泛型能力，就必须使其成为泛型方法。 无论何时，如果你能做到，你就该尽量使用泛型方法。也就是说，如果使用泛型方法将整个类泛型化， 那么就应该使用泛型方法。另外对于一个static的方法而已，无法访问泛型类型的参数。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475public class GenericTest &#123; //这个类是个泛型类，在上面已经介绍过 public class Generic&lt;T&gt;&#123; private T key; public Generic(T key) &#123; this.key = key; &#125; //我想说的其实是这个，虽然在方法中使用了泛型，但是这并不是一个泛型方法。 //这只是类中一个普通的成员方法，只不过他的返回值是在声明泛型类已经声明过的泛型。 //所以在这个方法中才可以继续使用 T 这个泛型。 public T getKey()&#123; return key; &#125; /** * 这个方法显然是有问题的，在编译器会给我们提示这样的错误信息&quot;cannot reslove symbol E&quot; * 因为在类的声明中并未声明泛型E，所以在使用E做形参和返回值类型时，编译器会无法识别。 public E setKey(E key)&#123; this.key = keu &#125; */ &#125; /** * 这才是一个真正的泛型方法。 * 首先在public与返回值之间的&lt;T&gt;必不可少，这表明这是一个泛型方法，并且声明了一个泛型T * T 表示的是返回值类型 * 这个T可以出现在这个泛型方法的任意位置. * 泛型的数量也可以为任意多个 * 如：public &lt;T,K&gt; K showKeyName(Generic&lt;T&gt; container)&#123; * ... * &#125; */ public &lt;T&gt; T showKeyName(Generic&lt;T&gt; container)&#123; System.out.println(&quot;container key :&quot; + container.getKey()); //当然这个例子举的不太合适，只是为了说明泛型方法的特性。 T test = container.getKey(); return test; &#125; //这也不是一个泛型方法，这就是一个普通的方法，只是使用了Generic&lt;Number&gt;这个泛型类做形参而已。 public void showKeyValue1(Generic&lt;Number&gt; obj)&#123; Log.d(&quot;泛型测试&quot;,&quot;key value is &quot; + obj.getKey()); &#125; //这也不是一个泛型方法，这也是一个普通的方法，只不过使用了泛型通配符? //同时这也印证了泛型通配符章节所描述的，?是一种类型实参，可以看做为Number等所有类的父类 public void showKeyValue2(Generic&lt;?&gt; obj)&#123; Log.d(&quot;泛型测试&quot;,&quot;key value is &quot; + obj.getKey()); &#125; /** * 这个方法是有问题的，编译器会为我们提示错误信息：&quot;UnKnown class &#x27;E&#x27; &quot; * 虽然我们声明了&lt;T&gt;,也表明了这是一个可以处理泛型的类型的泛型方法。 * 但是只声明了泛型类型T，并未声明泛型类型E，因此编译器并不知道该如何处理E这个类型。 public &lt;T&gt; T showKeyName(Generic&lt;E&gt; container)&#123; ... &#125; */ /** * 这个方法也是有问题的，编译器会为我们提示错误信息：&quot;UnKnown class &#x27;T&#x27; &quot; * 对于编译器来说T这个类型并未项目中声明过，因此编译也不知道该如何编译这个类。 * 所以这也不是一个正确的泛型方法声明。 public void showkey(T genericObj)&#123; &#125; */ public static void main(String[] args) &#123; &#125;&#125; 反射 12345678910111213141516171819202122232425public class ReflectionQuestion &#123; public static void main(String[] args) throws IOException, ClassNotFoundException, IllegalAccessException, InstantiationException, NoSuchMethodException, InvocationTargetException, NoSuchFieldException &#123;//1. 使用 Properties 类, 可以读写配置文件 Properties properties = new Properties(); properties.load(new FileInputStream(&quot;src\\\\re.properties&quot;)); //得到类名 String classfullpath = properties.get(&quot;classfullpath&quot;).toString();//&quot;com.hspedu.Cat&quot; //得到方法 String methodName = properties.get(&quot;method&quot;).toString();//&quot;hi&quot; System.out.println(&quot;classfullpath=&quot; + classfullpath); System.out.println(&quot;method=&quot; + methodName); //(1) 加载类, 返回 Class 类型的对象 cls Class cls = Class.forName(classfullpath); //(2) 通过 cls 得到你加载的类 com.hspedu.Cat 的对象实例 Object o = cls.newInstance(); System.out.println(&quot;o 的运行类型=&quot; + o.getClass()); //运行类型 //(3) 通过 cls 得到你加载的类 com.hspedu.Cat 的 methodName&quot;hi&quot; 的方法对象 // 即：在反射中，可以把方法视为对象（万物皆对象） Method method1 = cls.getMethod(methodName); //(4) 通过 method1 调用方法: 即通过方法对象来实现调用方法 System.out.println(&quot;=============================&quot;); method1.invoke(o); //传统方法 对象.方法() , 反射机制 方法.invoke(对象)&#125; 多线程使用 vector 安全 线程什么时候生成和退出 静态方法重写 父类的静态方法不能被重写（overide），可以被重载。 在编译时所分配的内存会一直存在（不会被回收），直到程序退出内存才会释放这个空间，在实例化之前这个方法就已经存在于内存，跟类的对象没什么关系。子类中如果定义了相同名称的静态方法，并不会重写，而应该是在内存中又分配了一块给子类的静态方法，没有重写这一说，只是单纯的名字重复了。 12345678910111213141516171819202122public class Fu &#123; public static void show() &#123; System.out.println(&quot;父类的静态方法&quot;); &#125; public void method() &#123; System.out.println(&quot;父类的一般方法&quot;); &#125; &#125;public class Zi extends Fu &#123; public static void main(String[] args) &#123; Fu fu = new Zi(); fu.show(); fu.method(); &#125; public static void show() &#123; System.out.println(&quot;子类的静态&quot;); &#125; public void method() &#123; System.out.println(&quot;子类的一般方法&quot;); &#125;&#125; 输出结果： 父类的静态方法 子类的一般方法 ArrayList 的 contains() 方法 12345678910111213141516171819202122232425public boolean contains(Object o) &#123; return indexOf(o) &gt;= 0;&#125;public int indexOf(Object o) &#123; return indexOfRange(o, 0, size);&#125;int indexOfRange(Object o, int start, int end) &#123; Object[] es = elementData; if (o == null) &#123; for (int i = start; i &lt; end; i++) &#123; if (es[i] == null) &#123; return i; &#125; &#125; &#125; else &#123; for (int i = start; i &lt; end; i++) &#123; if (o.equals(es[i])) &#123; //注意有没有重写 equals() return i; &#125; &#125; &#125; return -1;&#125; 匿名内部类 匿名内部类也就是没有名字的内部类 正因为没有名字，所以匿名内部类只能使用一次，它通常用来简化代码编写 但使用匿名内部类还有个前提条件：必须继承一个父类或实现一个接口 123456789101112131415161718192021222324252627282930313233//不使用匿名内部类abstract class Person &#123; public abstract void eat();&#125; class Child extends Person &#123; public void eat() &#123; System.out.println(&quot;eat something&quot;); &#125;&#125; public class Demo &#123; public static void main(String[] args) &#123; Person p = new Child(); p.eat(); &#125;&#125;//使用匿名内部类abstract class Person &#123; public abstract void eat();&#125; public class Demo &#123; public static void main(String[] args) &#123; Person p = new Person()&#123; public void eat() &#123; System.out.println(&quot;eat something&quot;); &#125; &#125;; p.eat(); &#125;&#125; 子类只用一次就不用了，创建类太麻烦，然后使用匿名类，就是在创建原有抽象类的基础上，在其构造函数方法体内部新建了一个方法，直接调用。看似是创建了原有的对象，但是实际上确实一个隐藏的实现类。 法语 Modèle de gestion de la mémoire en Java Mode de passage des parametre aux fonctions passage par valeur passage par reference/addresse Passage de parametre de type simple ou primitif Copie 1. Théorie 2. Copie Superfificielle 3. Copie profonde","categories":[{"name":"Java","slug":"Java","permalink":"http://littlewuuu.com/categories/Java/"}],"tags":[{"name":"JavaNotes","slug":"JavaNotes","permalink":"http://littlewuuu.com/tags/JavaNotes/"}]},{"title":"Quelques connaissances（Quelques exemples spécifiques）","slug":"Francaise/法语笔记","date":"2021-02-02T23:00:00.000Z","updated":"2022-08-15T18:00:07.345Z","comments":true,"path":"2021/02/03/Francaise/法语笔记/","link":"","permalink":"http://littlewuuu.com/2021/02/03/Francaise/%E6%B3%95%E8%AF%AD%E7%AC%94%E8%AE%B0/","excerpt":"","text":"2021 12 30 test1 vieux le jour de l’ouverture, il y a des bougies allumées sur des table #过去分词当形容词 passer le temps à faire qch un sur cinq #五分之一 changer A contre B voulez-vous me dire ce que vous ferezde ce dictionnaire #ce que 当宾语 le temps qu’il a perdu ne se retrouve jamais une saison faire attention à aucun #指人 se mettre à plusieurs #几个人一起干 n’importe où #无论什么地方 quelqu’un de compétent #形容词修饰指示代词要加 de une personne compétente dans chacune des fermes #chacun,e 是指示代词 chaque fois #chaque 是形容词 2021 12 29 adverbes Je veux bien faire une randonnée à vélo mais il faudra rouler lentement pour que nous puissions profiter du paysage. mal mauvais rapide vite léopard 非洲豹 Je suis d’accord avec toi. En revanche, je ne suis pas d’accord avec Paul. Nous avons marché toute la matinée puis nous nous sommes arrêtés pour pique-niquer. Mes voisins m’ont certes recommandé de rester chez moi aux heures chaudes, je dois pourtant sortir pour aller à la bibliothèque. préposition près de - loin de après - avant avant 时间 - devant 地点 D’après la météo, il fera beau la semaine prochaine.（根据天气预报） test 2 compter sur qn 信任某人 compter avec qn 重视考虑 pour + 一段时间 à + 时间点 dans dix minutes #十分钟后 même s’ 哪怕 quoique 尽管 Avant de signer, lisez bien ce qui est écrit sue le contrat. #ce qui 作 est écrit 的主语，判断的标准是看是不是后面接的句子的主语，而不是看整个句子的主语 songer à 想什么，思念什么 en apprenant que（知道） l’équipe de France avait gagné, il a sauté de joie. #de 表示原因 trop pour 太 以至于 etre responsable de 对 有责任 pourtant je le leur （先直接后间接）ai déjà expliqué dix fois #j’ai deja explique cettes questions à les étudiants il fait un temps bizzare #有形容词修饰 temps，用不定冠词 la famille a passé d’excellentes vacances au bord de la mer vacance 空缺 vacances 假期 vacances 有 excellentes 修饰，用不定冠词 des 当不定冠词直接在形容词之前，将 des 改成 de bijou - bijoux beau - beaux l’histoire a de quoi vous étonner #avoir de quoi faire 有足够的的东西来 les chiens dont il a le plus peur #il a le plus peur des les chiens rends-le-moi demain matin sans faute #肯定命令句中 le moi y en toute jeune fille a rêvé du prince #tout/toute + 单数 : 任何 test 3 comme tel #像这样 telle chose #这样的事情 ses parents lui font pratiquer régulièrement du sport #faire faire qch à qn 让某人做某事 tout heureuses aucun 的用法 ne/sans aucun 没有一个的 任何 名词 + quelconque – n’importe quel + 名词 beaucoup 的同等比较级 autant que se faire sentir 使自己感到 se sentir 自己感到 faute de quoi etre fier de 自豪 quelque chose de drôle #泛指代词和形容词之间用 de 链接 etre + 序数词 + à + inf #第几个做 test 4 punir pour mentir voir qn faire(inf.) qqch si le temp est bon, on mengera sur la terrasse bien - mieux | bon meilleur souhaiter qqch à qn c’est que/qui 强调句式 re rendre au rendez-vous 赴约 la fille à qui je me suis adressé est très belle veux-tu un café non, je n’en prends pas veux-tu le café non, je ne le prends pas il parraît que 直陈式（表事实）/虚拟式（表推测） 看似。。。 désigner qn comme 挑选某人为。。 il interroge Valerie sur son intentions interroger qn sur qqch 向某人询问某事 personne 接形容词要加 de souhaiter faire qqch test5 Le Général de Gaulle 戴高乐 penser à qn qn不用间接宾语，直接用重读人称 appartenir à qn 属于某人 sévère – indulgents grippe 感冒 faire à qcn 习惯于某事 mordre 咬 se souvenir de qch me le lui y en 除肯定命令式中 le moi y en 肯定命令式中 代词顺序 on lui avait déjà expliqué qu’il ne pourrait revenir au collège qu’avec des cheveux courts pourrait条件式现在时表示过去将来 comme si + imparfait c’est le meilleur chanteur que je connaisse 最高级表示主观，用connaisse虚拟式 test 6 autoroute 在过去时态里表示一个将来的时间，用 “时间 + après” savant 有学识的 devoir à qn 多亏某人 les uns … les autres 一些人 另一些人 c’est une maladie qui est facile à guérir(治愈) s’évanouir 晕倒 en partant de bonne heure, ils ont réussi à éviter les embouteillages en可以引导表示原因 qu‘est-ce que vous choisissez comme dessert comme 作为而不用 pour 为了 anfin de tous les étudiants puissent lire cet article, j’ai fait des photocopies anfin de 为了 ce chauffeur a dit que l’autocar partirait quand tout le momde serait arrivé 条件式现在时（partirait）表示过去将来，条件式过去时（serait arrivé）表示过去先将来时即先发生 six mètres sur quatre 表示 6×4 平方米 profiter de 利用 demander à qn de faire qch aider qn à faire qcn il n’y a personne de compétent dans cette société 此时 personne 后面有de，可以用 personne，表示没有人 envoyer qn faire qcn 派遣某人做某事 test 7 en cas 如果 au-delà de 超过 durée hebdomadaire 每周持续时间 s’attendre à 预计 passer son temps à dater de 追溯到 des + adj + n 时，des -&gt; de prendre des risques 冒风险 s’identifier à 与…同化 se féliciter de 感到庆幸 lutte contre 与 斗争 lutte pour 为 斗争 à l’époque 在那个时候，表示过去 espèrer faire malgré que 尽管+虚拟式 a la suite 由于，在 后面 si bien que 以至于 dès que 一 就 féliciter qn de faire qch penser + inf se tromper 搞错 croire à 相信 test8 dans quelques instants 过一会（将来） TFI matin 和 matinée nous avons rendez-vous dans la matinée la matinée 强调整个时间段， le matin 就不用 dans 了 表示过去习惯：未完成过去式 表示现在习惯：直陈式现在时 depuis que 时间间隔较长，自从 dès que 时间间隔较短，一…就… duquel, de laquelle, desquels, desquelles 都与 de 有关 auquel, à laquelle, auxquels, auxquelles à moins que 除非 Il restera là à moins que vous ne l’invitiez（注意后面用 ne） alors que 然而；却 和 while 一样 Il est gros alors que son frère est maigre. pourvu que 主从复合句表示只要；独立句表示但愿 Nous irons faire du ski pourvu qu’il y ait de la neige（ait 是 avoir 的虚拟式现在时） Pourvu qu’il fasse beau demain ! （fasse 虚拟式现在时） Maison最常用，指一个很确实的建筑，和famille相关。 Demeure的概念会更宽泛，就是居住、住所，但是它的用法会偏向文学性，或者说更soutenu一些 Domicile法律性用词会更多，比如你的户籍所在地啊，投票时的登记地址，公司的官方所在地。 Résidence也是居所，但是它可以是有好几个的，而且有时会有豪华住宅的意味。 le jour où j’ai perdu ma montre, j’étais à Malta. La directrice m’a envoyé chercher des documents s’il fait beau, j’irai à pied au bureau il n’a parlé à personne durant tout le week-end //为什么不能用 aucun？ les contes sont de belles histoires qui se passent dans des endroits magnifique //为啥？ au cas où = si + conditionnel préparation TFI vocabulaire à étudier diriger Mettre au point Ant-infectieux 法语课堂实录 six/dix 后面加名词，x 一般不发音 特殊形容词 beau bel belle Nouveau nouvel nouvelle Vieux vieil vieille fou fol folle Mou mol molle 软弱的、温和 quoique = bien que quoi que je fasse, il est avec moi Subjonctif Indicatif 1. Verbes + indicatif je constate que / je remarque que j’observe que je crois que / je pense que / je trouve que je suppose que / je’imagine que Je déclare que / je dis que j’affirme que J’espère que 2. Construction impersonnelles 无人称的 il est claire que il est certain que Après que Subjonctif 1. verbes + subjonctif je souhaite que / je désire que / j’aimerais que J’ai peur que / je crains que / je redoute que je regrette que / je suis désolé que je veux que / j’ordonne que / j’exige（要求） que / je supplie（请求） que 2. Verbes a la forme negative je ne crois pas que je ne pense pas que Je ne trouve que 3. Construction impersonnelles il faut que il vaut mieux que il est important que il est dommage que","categories":[{"name":"le français","slug":"le-francais","permalink":"http://littlewuuu.com/categories/le-francais/"}],"tags":[{"name":"le français","slug":"le-francais","permalink":"http://littlewuuu.com/tags/le-francais/"}]}],"categories":[{"name":"le français","slug":"le-francais","permalink":"http://littlewuuu.com/categories/le-francais/"},{"name":"SQL","slug":"SQL","permalink":"http://littlewuuu.com/categories/SQL/"},{"name":"SKILLS","slug":"SKILLS","permalink":"http://littlewuuu.com/categories/SKILLS/"},{"name":"COURS","slug":"COURS","permalink":"http://littlewuuu.com/categories/COURS/"},{"name":"Java","slug":"Java","permalink":"http://littlewuuu.com/categories/Java/"},{"name":"Case","slug":"Case","permalink":"http://littlewuuu.com/categories/Case/"},{"name":"生活","slug":"生活","permalink":"http://littlewuuu.com/categories/%E7%94%9F%E6%B4%BB/"},{"name":"做饭区","slug":"做饭区","permalink":"http://littlewuuu.com/categories/%E5%81%9A%E9%A5%AD%E5%8C%BA/"}],"tags":[{"name":"le français","slug":"le-francais","permalink":"http://littlewuuu.com/tags/le-francais/"},{"name":"SQL","slug":"SQL","permalink":"http://littlewuuu.com/tags/SQL/"},{"name":"ECN","slug":"ECN","permalink":"http://littlewuuu.com/tags/ECN/"},{"name":"学了又忘的杂七杂八","slug":"学了又忘的杂七杂八","permalink":"http://littlewuuu.com/tags/%E5%AD%A6%E4%BA%86%E5%8F%88%E5%BF%98%E7%9A%84%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/"},{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://littlewuuu.com/tags/JavaWeb/"},{"name":"JavaJDBC","slug":"JavaJDBC","permalink":"http://littlewuuu.com/tags/JavaJDBC/"},{"name":"SpringBootVueOneDay","slug":"SpringBootVueOneDay","permalink":"http://littlewuuu.com/tags/SpringBootVueOneDay/"},{"name":"有点难学的","slug":"有点难学的","permalink":"http://littlewuuu.com/tags/%E6%9C%89%E7%82%B9%E9%9A%BE%E5%AD%A6%E7%9A%84/"},{"name":"好好生活","slug":"好好生活","permalink":"http://littlewuuu.com/tags/%E5%A5%BD%E5%A5%BD%E7%94%9F%E6%B4%BB/"},{"name":"到处玩","slug":"到处玩","permalink":"http://littlewuuu.com/tags/%E5%88%B0%E5%A4%84%E7%8E%A9/"},{"name":"一些奇奇怪怪的吃的","slug":"一些奇奇怪怪的吃的","permalink":"http://littlewuuu.com/tags/%E4%B8%80%E4%BA%9B%E5%A5%87%E5%A5%87%E6%80%AA%E6%80%AA%E7%9A%84%E5%90%83%E7%9A%84/"},{"name":"一些正正经经的吃的","slug":"一些正正经经的吃的","permalink":"http://littlewuuu.com/tags/%E4%B8%80%E4%BA%9B%E6%AD%A3%E6%AD%A3%E7%BB%8F%E7%BB%8F%E7%9A%84%E5%90%83%E7%9A%84/"},{"name":"JavaNotes","slug":"JavaNotes","permalink":"http://littlewuuu.com/tags/JavaNotes/"}]}